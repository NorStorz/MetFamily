This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-10-14T14:21:13.807Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
.github/
  workflows/
    build.yml
binder/
  install.R
  runtime.txt
inst/
  MetFamily/
    app_files/
      server_functionsDownloads.R
      server_functionsFilters.R
      server_functionsSelections.R
      server_functionsSerialization.R
      server_functionsTableGui.R
      server_guiAnnotation.R
      server_guiDialogs.R
      server_guiMs2plot.R
      server_guiPlotControls.R
      server_guiPlots.R
      server_guiTabAnnotation.R
      server_guiTabClassifier.R
      server_guiTabExport.R
      server_guiTabHca.R
      server_guiTabInput.R
      server_guiTabMsmsFilter.R
      server_guiTabPca.R
      server_guiTabSampleFilter.R
      server_guiTabSearch.R
      ui_rightColumn.R
    tests/
      testthat/
        _snaps/
          linux-4.3/
            shinytest2/
              MetFamilyLoadExample-002.json
        setup-shinytest2.R
        test-shinytest2.R
      testthat.R
    www/
      css/
        ipb-styles.css
      img/
        denbi-logo-white.svg
        Leibniz__Logo_EN_Negative_100mm.svg
      ipbfooter.html
    server.R
    ui.R
    version.R
man/
  calcPlotDendrogram_plotly.Rd
  calcPlotHeatmapLegend.Rd
  castListEntries.Rd
  data.numericmatrix.Rd
  metaboliteFamilyVersusClass.Rd
  mzClustGeneric.Rd
  processMS1data.Rd
  readClusterDataFromProjectFile.Rd
  readProjectData.Rd
  runMetFamily.Rd
R/
  Analysis.R
  Annotation.R
  Classifiers.R
  DataProcessing.R
  FragmentMatrixFunctions.R
  parsePeakAbundanceMatrixQF.R
  Plots.R
  R_packages.R
  readMetaboScape.R
  readMSDial.R
  runMetFamily.R
  TreeAlgorithms.R
tests/
  testthat/
    test_dataprocessing.R
    test_fileinput.R
    test-readMetaboScape.R
    test-readMSDial.R
  testthat.R
vignettes/
  biomed-central.csl
  discoveringregulatedmetabolitefamilies.Rmd
  references.bib
.gitignore
.Rbuildignore
DESCRIPTION
Dockerfile
Dockerfile-base
Dockerfile-rstudio
LICENSE
MetFamily.Rproj
NAMESPACE
NEWS
README.md
supervisord-rstudio.conf
supervisord.conf

================================================================
Repository Files
================================================================

================
File: .github/workflows/build.yml
================
## Acronyms:
## * GHA: GitHub Action
## * OS: operating system

on:
  push:
  pull_request:

# Define the GitHub Actions workflow for R CMD check of the MetFamily package
name: R-CMD-check-MetFamily

# Define environment variables for the workflow
env:
  has_testthat: 'true'
#  run_covr: 'true' # Disabled until later
  run_covr: 'false'
#  run_pkgdown: 'true' # Disabled until later
  run_pkgdown: 'false'
  has_RUnit: 'false'
  has_BiocCheck: 'false'
  cache-version: 'cache-v1'

# Define the jobs for different operating systems
jobs:
  build-check:
    runs-on: ${{ matrix.config.os }}
    name: ${{ matrix.config.os }} (${{ matrix.config.r }})
    container: ${{ matrix.config.cont }}

    # Define the matrix for different configurations
    strategy:
      fail-fast: false
      matrix:
        config:
          - { os: ubuntu-latest, r: '4.3', bioc: '3.18', cont: "bioconductor/bioconductor_docker:RELEASE_3_18", rspm: "https://packagemanager.rstudio.com/cran/__linux__/focal/latest" }
#          - { os: ubuntu-latest, r: 'devel', bioc: 'devel', cont: "bioconductor/bioconductor_docker:devel", rspm: "https://packagemanager.rstudio.com/cran/__linux__/focal/latest" }
# Disabling additional architectures until later
#          - { os: macOS-latest, r: 'next', bioc: '3.18'}
#          - { os: windows-latest, r: 'next', bioc: '3.18'}

    # Define environment variables for the job
    env:
      R_REMOTES_NO_ERRORS_FROM_WARNINGS: true
      RSPM: ${{ matrix.config.rspm }}
      NOT_CRAN: true
      TZ: UTC
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      GITHUB_PAT: ${{ secrets.GITHUB_TOKEN }}

    # Define the steps to be executed
    steps:
      # Step 1: Set R Library home on Linux
      - name: Set R Library home on Linux
        if: runner.os == 'Linux'
        run: |
          mkdir /__w/_temp/Library
          echo ".libPaths('/__w/_temp/Library')" > ~/.Rprofile

      # Step 2: Checkout the repository
      - name: Checkout Repository
        uses: actions/checkout@v2

      # Step 3: Setup R from r-lib
      - name: Setup R from r-lib
        if: runner.os != 'Linux'
        uses: r-lib/actions/setup-r@v2
        with:
          r-version: ${{ matrix.config.r }}
          extra-repositories: https://janmarvin.r-universe.dev

      # Step 4: Setup pandoc from r-lib
      - name: Setup pandoc from r-lib
        if: runner.os != 'Linux'
        uses: r-lib/actions/setup-pandoc@v2

      # Step 5: Query dependencies and save RDS file
      - name: Query dependencies
        run: |
          install.packages('remotes')
          saveRDS(remotes::dev_package_deps(dependencies = TRUE), ".github/depends.Rds", version = 2)
        shell: Rscript {0}

      # Step 6: Cache R packages based on configuration
      - name: Cache R packages
        if: "!contains(github.event.head_commit.message, '/nocache') && runner.os != 'Linux'"
        uses: actions/cache@v2
        with:
          path: ${{ env.R_LIBS_USER }}
          key: ${{ env.cache-version }}-${{ runner.os }}-biocversion-devel-r-devel-${{ hashFiles('.github/depends.Rds') }}
          restore-keys: ${{ env.cache-version }}-${{ runner.os }}-biocversion-devel-r-devel-

      # Step 7: Cache R packages on Linux
      - name: Cache R packages on Linux
        if: "!contains(github.event.head_commit.message, '/nocache') && runner.os == 'Linux' "
        uses: actions/cache@v2
        with:
          path: /home/runner/work/_temp/Library
          key: ${{ env.cache-version }}-${{ runner.os }}-biocversion-devel-r-devel-${{ hashFiles('.github/depends.Rds') }}
          restore-keys: ${{ env.cache-version }}-${{ runner.os }}-biocversion-devel-r-devel-

      # Step 8: Install Linux system dependencies
      - name: Install Linux system dependencies
        if: runner.os == 'Linux'
        run: |
          sysreqs=$(Rscript -e 'cat("apt-get update -y && ", paste(remotes::system_requirements("ubuntu", "20.04"), collapse = " && "))')
          echo $sysreqs
          sudo -s eval "$sysreqs"

      # Steps 9 and 10 (macOS and Windows dependencies) removed
      - uses: r-lib/actions/setup-r-dependencies@v2
        with:
          extra-packages: any::rcmdcheck, testthat, openxlsx2
          needs: check
          dependencies: '"hard"'
  

      # Step 11: Install BiocManager
      - name: Install BiocManager
        run: |
          message(paste('****', Sys.time(), 'installing BiocManager ****'))
          remotes::install_cran("BiocManager")
        shell: Rscript {0}

      # Step 12: Set BiocVersion
      - name: Set BiocVersion
        run: |
          BiocManager::install(version = "${{ matrix.config.bioc }}", ask = FALSE)
        shell: Rscript {0}
      # Step 13: Install dependencies pass 1
      - name: Install dependencies pass 1
        run: |
          ## Try installing the package dependencies in steps. First the local
          ## dependencies, then any remaining dependencies to avoid the
          ## issues described at
          ## https://stat.ethz.ch/pipermail/bioc-devel/2020-April/016675.html
          ## https://github.com/r-lib/remotes/issues/296
          ## Ideally, all dependencies should get installed in the first pass.

          ## Pass #1 at installing dependencies
          BiocManager::install(c(
            "mzR", "htmltools", "shiny", "shinyBS", "shinyjs", "shinybusy",
            "DT", "colourpicker", "Matrix", "squash", "FactoMineR", "mixOmics",
            "pcaMethods", "cba", "tools", "stringr", "xcms", "matrixStats",
            "plotrix"
          ))
          message(paste('****', Sys.time(), 'pass number 1 at installing dependencies: local dependencies ****'))
          remotes::install_local(dependencies = TRUE, repos = BiocManager::repositories(), build_vignettes = FALSE, upgrade = TRUE)

          BiocManager::install(c("rmarkdown", "BiocStyle"))
        continue-on-error: true
        shell: Rscript {0}

      # Step 14: Install dependencies pass 2
      - name: Install dependencies pass 2
        run: |
          ## Pass #2 at installing dependencies
          message(paste('****', Sys.time(), 'pass number 2 at installing dependencies: any remaining dependencies ****'))
          remotes::install_local(dependencies = TRUE, repos = BiocManager::repositories(), build_vignettes = FALSE, upgrade = TRUE)

          ## Manually install packages that seem to be skipped.
          message(paste('****', Sys.time(), 'force installation of selected packages  ****'))
          BiocManager::install("mzR", type = "source", force = TRUE)
          BiocManager::install("Spectra")

          ## For running the checks
          message(paste('****', Sys.time(), 'installing rcmdcheck and BiocCheck ****'))
          remotes::install_cran("rcmdcheck")
          BiocManager::install(c("BiocCheck", "DBI"))
        shell: Rscript {0}

      # Step 15: Install BiocGenerics
      - name: Install BiocGenerics
        if:  env.has_RUnit == 'true'
        run: |
          ## Install BiocGenerics
          BiocManager::install("BiocGenerics")
        shell: Rscript {0}

      # Skipping Step 16: Install covr

      # Step 17: Install pkgdown
      - name: Install pkgdown
        if: github.ref == 'refs/heads/devel' && env.run_pkgdown == 'true' && runner.os == 'Linux'
        run: |
          remotes::install_github("r-lib/pkgdown")
        shell: Rscript {0}

      # Step 18: Session info
      - name: Session info
        run: |
          options(width = 100)
          pkgs <- installed.packages()[, "Package"]
          sessioninfo::session_info(pkgs, include_base = TRUE)
        shell: Rscript {0}

      # Step 19: Run CMD check
      - name: Run CMD check
        env:
          _R_CHECK_CRAN_INCOMING_: false
        run: |
          rcmdcheck::rcmdcheck(
              args = c("--no-build-vignettes", "--no-manual", "--timings"),
              build_args = c("--no-manual", "--no-resave-data"),
              error_on = "error",
              check_dir = "check"
          )
        shell: Rscript {0}

      # Step 20: Reveal testthat details
      - name: Reveal testthat details
        if:  env.has_testthat == 'true' && runner.os == 'Linux'
        run: find . -name testthat.Rout -exec cat '{}' ';'

      # Step 21: Run RUnit tests
      - name: Run RUnit tests
        if:  env.has_RUnit == 'true' && runner.os == 'Linux'
        run: |
          BiocGenerics:::testPackage()
        shell: Rscript {0}

      # Step 22: Run BiocCheck
      - name: Run BiocCheck
        if:  env.has_BiocCheck == 'true' && runner.os == 'Linux'
        run: |
          BiocCheck::BiocCheck(
              dir('check', 'tar.gz$', full.names = TRUE),
              `quit-with-status` = TRUE,
              `no-check-R-ver` = TRUE,
              `no-check-bioc-help` = TRUE
          )
        shell: Rscript {0}

      # Step 23: Test coverage
      - name: Test coverage
        if: github.ref == 'refs/heads/devel' && env.run_covr == 'true' && runner.os == 'Linux'
        run: |
          covr::codecov()
        shell: Rscript {0}

      # Step 24: Install package
      - name: Install package
        if: github.ref == 'refs/heads/devel' && env.run_pkgdown == 'true' && runner.os == 'Linux'
        run: R CMD INSTALL .

      # Step 25: Test Shiny App in package
      - name: Test Shiny App
        uses: rstudio/shinytest2/actions/test-app@actions/v1
        with:
          app-dir: "inst/MetFamily"

      # Step 26: Deploy package
      - name: Deploy package
        if: github.ref == 'refs/heads/devel' && env.run_pkgdown == 'true' && runner.os == 'Linux'
        run: |
          git config --global user.email "actions@github.com"
          git config --global user.name "GitHub Actions"
          git config --global --add safe.directory /__w/your-package-name
          Rscript -e "pkgdown::deploy_to_branch(new_process = FALSE)"
        shell: bash {0}
        ## Note that you need to run pkgdown::deploy_to_branch(new_process = FALSE)
        ## at least one locally before this will work. This creates the gh-pages
        ## branch (erasing anything you haven't version controlled!) and
        ## makes the git history recognizable by pkgdown.

      # Step 27: Upload check results
      - name: Upload check results
        if: failure()
        uses: actions/upload-artifact@master
        with:
          name: ${{ runner.os }}-biocversion-devel-r-devel-results
          path: check

================
File: binder/install.R
================
install.packages("devtools")
install.packages("BiocManager")

library("devtools")
devtools::install_deps("..")


# install.packages("shiny")
# install.packages("testthat")
# 
# devtools::install_github("rstudio/htmltools")
# devtools::install_github("decisionpatterns/searchable")
# 
# install.packages("shinyjs")
# install.packages("shinybusy")
# install.packages("DT")
# install.packages("colourpicker")
# install.packages("shinyBS")
# install.packages("egg")
# install.packages("cowplot")
# install.packages("searchable")
# install.packages("gdata")
# 
# BiocManager::install("mzR")
# BiocManager::install("xcms")
# BiocManager::install("mixOmics")
# BiocManager::install("pcaMethods")
# 
# install.packages("car")
# install.packages("FactoMineR")
# install.packages("matrixStats")
# install.packages("Matrix")
# install.packages("stringi")
# install.packages("slam")
# install.packages("knitr")
# install.packages("cba")
# install.packages("squash")
# install.packages("plotrix")
# install.packages("RColorBrewer")
# install.packages("plotly")
# install.packages("rlang")

================
File: binder/runtime.txt
================
r-2019-05-17

================
File: inst/MetFamily/app_files/server_functionsDownloads.R
================
timeStampForFiles <- function(){
  timeStamp <- gsub(" ", "_", gsub(":", ".", Sys.time()))
  return(timeStamp)
}
createImportParameterSetExportFileName <- function(){
  fileProjectName <- dataList$importParameterSet$projectName
  fileProjectName <- gsub(" ", "_", gsub(":", ".", fileProjectName))
  fileName <- paste(timeStampForFiles(), "_", fileProjectName, "_import_parameters.txt", sep = "")
  return(fileName)
}
createExportMatrixName <- function(){
  fileName <- paste(timeStampForFiles(), "_selectedPrecursorMatrix.csv.gz", sep = "")
  return(fileName)
}
createConsensusSpectrumName <- function(annotation){
  fileName <- paste(timeStampForFiles(), "_ConsensusSpectrum_", gsub(pattern = " ", replacement = "_", x = annotation), ".csv", sep = "")
  return(fileName)
}
createClassifierAnnotationName <- function(annotation){
  fileName <- paste(timeStampForFiles(), "_ClassifierAnnotation_", gsub(pattern = " ", replacement = "_", x = annotation), ".csv", sep = "")
  return(fileName)
}
createMetaboliteFamilyProjectFileName <- function(annotation){
  fileName <- paste(timeStampForFiles(), "_", gsub(pattern = " ", replacement = "_", x = annotation), ".csv.gz", sep = "")
  return(fileName)
}
createExportImageName <- function(item, extension){
  fileName <- paste(timeStampForFiles(), "_", item, ".", extension, sep = "")
  return(fileName)
}
createExportDistanceMatrixName <- function(distanceMeasure){
  fileName <- paste(timeStampForFiles(), "_distanceMatrix_", distanceMeasure, ".csv", sep = "")
  return(fileName)
}
createExportMatrix <- function(precursorSet){
  ################################################################################
  ## fragment matrix
  fragmentMatrix      <- dataList$featureMatrix[precursorSet, ]
  dgTMatrix <- as(fragmentMatrix, "dgTMatrix")
  matrixRows <- dgTMatrix@i + 1
  matrixCols <- dgTMatrix@j + 1
  matrixVals <- dgTMatrix@x
  
  numberOfColumns <- ncol(fragmentMatrix)
  numberOfRows <- nrow(fragmentMatrix)
  chunkSize <- 1000
  numberOfChunks <- ceiling(numberOfColumns / chunkSize)
  
  fragmentCounts      <- vector(mode = "integer", length = numberOfColumns)
  fragmentIntensities <- vector(mode = "numeric", length = numberOfColumns)
  fragmentMasses      <- dataList$fragmentMasses
  linesMatrix <- matrix(nrow = numberOfRows, ncol = numberOfChunks)
  
  for(chunkIdx in seq_len(numberOfChunks)){
    colStart <- 1 + (chunkIdx - 1) * chunkSize
    colEnd <- colStart + chunkSize - 1
    if(chunkIdx == numberOfChunks)
      colEnd <- numberOfColumns
    
    numberOfColumnsHere <- colEnd - colStart + 1
    numberOfRowsHere <- max(matrixRows)
    indeces <- matrixCols >= colStart & matrixCols <= colEnd
    
    fragmentMatrixPart <- matrix(data = rep(x = "", times = numberOfRowsHere * numberOfColumnsHere), nrow = numberOfRowsHere, ncol = numberOfColumnsHere)
    fragmentMatrixPart[cbind(matrixRows[indeces], matrixCols[indeces] - colStart + 1)] <- matrixVals[indeces]
    
    fragmentCountsPart      <- apply(X = fragmentMatrixPart, MARGIN = 2, FUN = function(x){ sum(x != "") })
    fragmentIntensitiesPart <- apply(X = fragmentMatrixPart, MARGIN = 2, FUN = function(x){ sum(as.numeric(x), na.rm = TRUE) }) / fragmentCountsPart
    
    linesPart <- apply(X = fragmentMatrixPart, MARGIN = 1, FUN = function(x){paste(x, collapse = "\t")})
    
    fragmentCounts[colStart:colEnd] <- fragmentCountsPart
    fragmentIntensities[colStart:colEnd] <- fragmentIntensitiesPart
    linesMatrix[, chunkIdx] <- linesPart
  }
  
  ## assemble
  linesFragmentMatrixWithHeader <- c(
    paste(fragmentCounts, collapse = "\t"),
    paste(fragmentIntensities, collapse = "\t"),
    paste(fragmentMasses, collapse = "\t"),
    apply(X = linesMatrix, MARGIN = 1, FUN = function(x){paste(x, collapse = "\t")})
  )
  
  ################################################################################
  ## MS1 matrix
  dataList$dataFrameMS1Header[[1,2]] <<- serializeSampleSelectionAndOrder(dataList$groupSampleDataFrame)
  ms1Matrix     <- rbind(
    dataList$dataFrameMS1Header,
    dataList$dataFrameInfos[precursorSet, ]
  )
  ms1Matrix     <- as.matrix(ms1Matrix)
  
  ###########################################################
  ## export annotations
  
  ## process annotations
  annotations <- dataList$annoArrayOfLists
  for(i in 1:length(annotations))
    if(dataList$annoArrayIsArtifact[[i]])
      annotations[[i]] <- c(annotations[[i]], dataList$annotationValueIgnore)
  
  annotationStrings <- vector(mode = "character", length = length(annotations))
  for(i in 1:length(annotations)){
    if(length(annotations[[i]]) > 0)
      annotationStrings[[i]] <- paste(annotations[[i]], collapse = ", ")
    else
      annotationStrings[[i]] <- ""
  }
  annotationStrings <- annotationStrings[precursorSet]
  
  ## process annotaiotn-color-map
  annoPresentAnnotations <- dataList$annoPresentAnnotationsList[-1]
  annoPresentColors      <- dataList$annoPresentColorsList[-1]
  
  if(length(annoPresentAnnotations) > 0){
    annotationColors <- paste(annoPresentAnnotations, annoPresentColors, sep = "=", collapse = ", ")
  } else {
    annotationColors <- ""
  }
  annotationColors <- paste(dataList$annotationColorsName, "={", annotationColors, "}", sep = "")
  
  ## box
  annotationColumn <- c("", annotationColors, dataList$annotationColumnName, annotationStrings)
  
  ms1Matrix[, dataList$annotationColumnIndex] <- annotationColumn
  
  ################################################################################
  ## assemble
  #dataFrame <- cbind(
  #  ms1Matrix,
  #  ms2Matrix
  #)
  linesMS1MatrixWithHeader <- apply(X = ms1Matrix, MARGIN = 1, FUN = function(x){paste(x, collapse = "\t")})
  lines <- paste(linesMS1MatrixWithHeader, linesFragmentMatrixWithHeader, sep = "\t")
  
  return(lines)
}

writeTable <- function(precursorSet, file){
  show_modal_spinner(spin="scaling-squares", 
                     text="\nMerging project files to csv. This can take several minutes!")
  lines <- createExportMatrix(precursorSet)
  gz1 <- gzfile(description = file, open = "w")
  writeLines(text = lines, con = gz1)
  close(gz1)
  remove_modal_spinner()
}

## individual downloads
output$downloadGlobalMS2filteredPrecursors <- downloadHandler(
  filename = function() {
    createExportMatrixName()
  },
  content = function(file) {
    precursorSet <- filterGlobal$filter
    writeTable(precursorSet = precursorSet, file = file)
  },
  contentType = 'text/csv'
)
output$downloadHcaFilteredPrecursors <- downloadHandler(
  filename = function() {
    createExportMatrixName()
  },
  content = function(file) {
    precursorSet <- filterHca$filter
    writeTable(precursorSet = precursorSet, file = file)
  },
  contentType = 'text/csv'
)
output$downloadPcaFilteredPrecursors <- downloadHandler(
  filename = function() {
    createExportMatrixName()
  },
  content = function(file) {
    precursorSet <- filterPca$filter
    writeTable(precursorSet = precursorSet, file = file)
  },
  contentType = 'text/csv'
)
output$downloadSearchPrecursors <- downloadHandler(
  filename = function() {
    createExportMatrixName()
  },
  content = function(file) {
    precursorSet <- filterPca$filter
    writeTable(precursorSet = precursorSet, file = file)
  },
  contentType = 'text/csv'
)
output$downloadSelectedPrecursors <- downloadHandler(
  filename = function() {
    createExportMatrixName()
  },
  content = function(file) {
    precursorSet <- selectedPrecursorSet
    writeTable(precursorSet = precursorSet, file = file)
  },
  contentType = 'text/csv'
)

#Obvserve button for exporting the project
observeEvent(input$prepareAllPrecursors, {
  ExportMatrixName <<- createExportMatrixName()
  precursorSet <- 1:dataList$numberOfPrecursors
  writeTable(precursorSet = precursorSet, file = file.path(tempdir(),ExportMatrixName))
  showModal(modalDialog(title = "Download", footer = NULL, size="s", 
                        fluidRow(column(12, p("Your download is ready."))), 
                        fluidRow(column(3,downloadButton(outputId = "downloadAllpreparedPrecursors", 
                                                         label = "Download project"))),
  ))
})

#Serving the modal with the download button to download the project
output$downloadAllpreparedPrecursors <- downloadHandler(
  filename <- ExportMatrixName, 
  content = function(file){
    file.copy(file.path(tempdir(),ExportMatrixName), file)
    file.remove(file.path(tempdir(),ExportMatrixName))
    removeModal()
  },
  contentType = 'text/csv'
)

## download selected
output$downloadHcaSelectedPrecursors <- downloadHandler(
  filename = function() {
    createExportMatrixName()
  },
  content = function(file) {
    ## get selected precursors
    if(is.null(selectionAnalysisTreeNodeSet)){
      ## all precursors
      precursorSet <- filterHca$filter
    } else {
      precursorSet <- getPrecursorSetFromTreeSelections(clusterDataList = clusterDataList, clusterLabels = selectionAnalysisTreeNodeSet)
    }
    
    writeTable(precursorSet = precursorSet, file = file)
  },
  contentType = 'text/csv'
)

output$downloadImportParameterSet <- downloadHandler(
  filename = function() {
    createImportParameterSetExportFileName()
  },
  content = function(file) {
    fileLines <- serializeParameterSetFile(dataList$importParameterSet, toolName, toolVersion)
    writeLines(text = fileLines, con = file)
  },
  contentType = 'text/csv'
)

## download images
output$downloadHcaImage <- downloadHandler(
  filename = function() {
    fileType <- input$downloadHcaImageType
    createExportImageName("HCA", fileType)
  },
  content = function(file) {
    fileType <- input$downloadHcaImageType
    plotHCA(file, fileType)
  }#,
  #contentType = 'image/png'
)

plotHCA <- function(file, fileType, plotMS2 = TRUE){
  ## parameters
  widthInInch     <- 10
  heigthInInch    <- ifelse(test = plotMS2, yes = 7.5, no = (5.2-1.5)/5.2 * 7.5)
  resolutionInDPI <- 650
  widthInPixel    <- widthInInch  * resolutionInDPI
  heightInPixel   <- heigthInInch * resolutionInDPI
  
  switch(fileType,
         "png"={
           png(filename = file, 
               width = widthInPixel, 
               height = heightInPixel, 
               res = resolutionInDPI, bg = "white")
         },
         "svg"={
           svg(filename = file)
         },
         "pdf"={
           pdf(file = file, title = "PCA image export from MetFam")
         },
         stop(paste("Unknown file type (", fileType, ")!", sep = ""))
  )
  
  if(plotMS2) {
    graphics::layout(
      mat = matrix(
        data = c(1, 1, 1, 1, 2, 2,3, 4, 5, 5,5, 5), nrow = 6, ncol = 2),
      widths = c(4.58, 1.59), 
      heights = c(0.0052, 0.011, 0.01112, 0.01112,0.001111, 0.0111)
    )
  } else {
    graphics::layout(
      mat = matrix(
        data = c(1, 1, 1, 1, 2, 
                 3, 4, 5, 6, 6), 
        nrow = 5, ncol = 2), 
      widths = c(4, 1), 
      heights = c(0.6, 1.4, 0.6, 1.2, 0.5)
    )
  }
  
  drawDendrogramPlotImpl() #1
  drawHeatmapPlotImpl() #2
  
  drawFragmentDiscriminativityLegendImpl() #4
  drawHeatmapLegendImpl() #3
  
  drawAnnotationLegendForImageHCAimpl() #5

  dev.off()
}

output$downloadPcaImage <- downloadHandler(
  filename = function() {
    fileType <- input$downloadPcaImageType
    createExportImageName("PCA", fileType)
  },
  content = function(file) {
    fileType <- input$downloadPcaImageType
    plotPCA(file, fileType)
  }
)

plotPCA <- function(file, fileType, plotMS2 = TRUE){
  ## parameters
  widthInInch     <- 10
  heigthInInch    <- ifelse(test = plotMS2, yes = 6, no = (5.2-1.5)/5.2 * 6)  
  resolutionInDPI <- 650
  widthInPixel    <- widthInInch  * resolutionInDPI
  heightInPixel   <- heigthInInch * resolutionInDPI
  
  switch(fileType,
         "png"={
           png(filename = file, 
               width = widthInPixel, 
               height = heightInPixel, 
               res = resolutionInDPI, bg = "white")
         },
         "svg"={
           svg(filename = file)
         },
         "pdf"={
           pdf(file = file, title = "PCA image export from MetFam")
         },
         stop(paste("Unknown file type (", fileType, ")!", sep = ""))
  )
  
  if(plotMS2){
    graphics::layout(
      mat = matrix(
        data = c(1,1,2,2,1,1,2,2,3,3,4,4,3,3,4,4,5,5,5,5,6,6,6,6,7,7,7,7),nrow=4,ncol=7),
      widths =  c(0.85, 1.15),
      heights = c(1.02,1.01)
    )
  } else {
    graphics::layout(
      mat = matrix(
        data = c(1, 1, 1, 
                 2, 2, 2, 
                 3, 4, 5), 
        nrow = 3, ncol = 3), 
      widths = c(2, 2, 1), 
      heights = c(0.7, 0.6, 2.4)
    )
  }
  
  drawPcaScoresPlotImpl1()
  calcPlotScoresGroupsLegendForImage1(scoresGroups$grouXXXps, scoresGroups$colors, 30)
  drawPcaLoadingsPlotImpl()
  drawAnnotationLegendForImagePCAimpl()
  dev.off()
}

output$downloadDistanceMatrix <- downloadHandler(
  filename = function() {
    createExportDistanceMatrixName(currentDistanceMatrixObj$distanceMeasure)
  },
  content = function(file) {
    write.table(x = currentDistanceMatrixObj$distanceMatrix, file = file, sep = "\t", row.names = TRUE, quote = FALSE, col.names=NA)
  },
  contentType = 'text/csv'
)

## download publication data
output$downloadMsData <- downloadHandler(
  filename = function() {
    return("Metabolite_profile_showcase.txt")
  },
  content = function(file) {
    ## copy data for download
    file.copy(system.file("extdata/showcase/Metabolite_profile_showcase.txt", package = "MetFamily"),
              file)
  },
  contentType = "application/zip"
)

## STN: should this really be a fixed fileName ??
output$downloadMsMsData <- downloadHandler(
  filename = function() {
    return("MSMS_library_showcase.msp")
  },
  content = function(file) {
    ## copy data for download
    file.copy(system.file("extdata/showcase/Metabolite_profile_showcase.txt", package = "MetFamily"),
              file)
  },
  contentType = "application/zip"
)

## STN: should this really be a fixed fileName ??
output$downloadFragmentMatrix <- downloadHandler(
  filename = function() {
    return("Fragment_matrix_showcase.csv")
  },
  content = function(file) {
    ## copy data for download
    file.copy(system.file("Fragment_matrix_showcase.csv", package = "MetFamily"),
      file)
  },
  contentType = "application/zip"
)

output$downloadDocShowcaseProtocol <- downloadHandler(
  filename = function() {
    return("MetFamily_Showcase_protocol.pdf")
  },
  content = function(file) {
    ## copy data for download
    file.copy(system.file("extdata/showcase/MetFamily_Showcase_protocol.pdf", package = "MetFamily"),
      file)
  },
  contentType = "application/pdf"
)

output$downloadDocUserGuide <- downloadHandler(
  filename = function() {
    return("MetFamily_user_guide.pdf")
  },
  content = function(file) {
    ## copy data for download
    file.copy(system.file("extdata/showcase/MetFamily_user_guide.pdf", package = "MetFamily"), 
              file)
  },
  contentType = "application/pdf"
)

output$downloadDocInputSpecification <- downloadHandler(
  filename = function() {
    return("MetFamily_Input_Specification.pdf")
  },
  content = function(file) {
    ## copy data for download
    file.copy(system.file("extdata/showcase/MetFamily_Input_Specification.pdf", package = "MetFamily"), 
      file)
  },
  contentType = "application/pdf"
)

#########################################################################################
## consensus spectrum for metabolite families
output$downloadMetaboliteFamilyConsensusSpectrum <- downloadHandler(
  filename = function() {
    createConsensusSpectrumName(allAnnotationNames[[input$familySelectionTable_rows_selected]])
  },
  content = function(file) {
    annotation <- allAnnotationNames[[input$familySelectionTable_rows_selected]]
    precursorSet <- which(unlist(lapply(X = dataList$annoArrayOfLists, 
                                        FUN = function(y){any(y==annotation)})))
    returnObj <- getSpectrumStatistics(dataList = dataList, precursorSet = precursorSet)
    fragmentMasses = returnObj$fragmentMasses
    fragmentCounts = returnObj$fragmentCounts
    fragmentProportion = fragmentCounts / length(precursorSet)
    consensusSpectrumDf <- data.frame(
      "Mass" = fragmentMasses, 
      "Count" = fragmentCounts, 
      "Frequency" = fragmentProportion
    )
    
    write.table(x = consensusSpectrumDf, file = file, sep = "\t", 
                row.names = FALSE, quote = FALSE)
  },
  contentType = 'text/csv'
)

output$downloadMetaboliteFamilyFilteredPrecursors <- downloadHandler(
  filename = function() {
    createMetaboliteFamilyProjectFileName(allAnnotationNames[[input$familySelectionTable_rows_selected]])
  },
  content = function(file) {
    annotation <- allAnnotationNames[[input$familySelectionTable_rows_selected]]
    precursorSet <- which(unlist(lapply(X = dataList$annoArrayOfLists, 
                                        FUN = function(y){any(y==annotation)})))
    writeTable(precursorSet = precursorSet, file = file)
  },
  contentType = 'text/csv'
)

#########################################################################################
## classifier annotation result export
createAnnotationResultTableAll <- function(){
  precursorIndeces <- sort(as.integer(unique(unlist(lapply(X = classToSpectra_class, FUN = names)))))
  
  rows <- list()
  for(precursorIndex in precursorIndeces){
    precursorLabel     <- dataList$precursorLabels[[precursorIndex]]
    mz                 <- dataList$dataFrameInfos[[precursorIndex, "m/z"]]
    rt                 <- dataList$dataFrameInfos[[precursorIndex, "RT"]]
    metaboliteName     <- dataList$dataFrameInfos[[precursorIndex, "Metabolite name"]]
    
    presentAnnotations <- unlist(dataList$annoArrayOfLists[[precursorIndex]])
    if(length(presentAnnotations) == 0){
      presentAnnotations <- ""
    } else {
      presentAnnotations <- sort(unlist(presentAnnotations))
      presentAnnotations <- paste(presentAnnotations, collapse = "; ")
    }
    
    for(classIdx in seq_along(classToSpectra_class)){
      if(!(precursorIndex %in% as.integer(names(classToSpectra_class[[classIdx]]))))
        next
      
      class <- names(classToSpectra_class)[[classIdx]]
      pValue <- format(unname( classToSpectra_class[[classIdx]][[which( precursorIndex == as.integer(names(classToSpectra_class[[classIdx]])) )]] ), digits=4)
      rows[[length(rows)+1]] <- c(
        "Index" = precursorIndex, 
        "Label" = precursorLabel, 
        "m/z"   = mz, 
        "RT"    = rt, 
        "Metabolite name" = metaboliteName, 
        "Annotation (present)" = presentAnnotations, 
        "Annotation (putative)" = class, 
        "pValue" = pValue
      )
    }
  }
  
  head <- c(
    "Index", 
    "Label", 
    "m/z", 
    "RT", 
    "Metabolite name", 
    "Annotation (present)", 
    "Annotation (putative)", 
    "pValue"
  )
  outputDf <- as.data.frame(t(matrix(data = unlist(rows), nrow = length(head))))
  colnames(outputDf) <- head
  return(outputDf)
}

createAnnotationResultTableForClass <- function(){
  selectedRowIdx <- input$annotationResultTableClass_rows_selected
  
  class          <- names(classToSpectra_class)[[selectedRowIdx]]
  classToSpectra <-       classToSpectra_class [[selectedRowIdx]]
  
  precursorIndeces   <- as.integer(names(classToSpectra))
  pValues            <- format(unname(classToSpectra), digits=4)
  precursorLabels    <- dataList$precursorLabels[precursorIndeces]
  mzs                <- dataList$dataFrameInfos[precursorIndeces, "m/z"]
  rts                <- dataList$dataFrameInfos[precursorIndeces, "RT"]
  metaboliteNames    <- dataList$dataFrameInfos[precursorIndeces, "Metabolite name"]
  presentAnnotations <- unlist(lapply(X = dataList$annoArrayOfLists[precursorIndeces], 
                                      FUN = function(x){
                                        if(length(x) == 0){
                                          return("")
                                        } else {
                                          x <- sort(unlist(x))
                                          s <- paste(x, collapse = "; ")
                                          return(s)
                                        }
                                      }))
  
  outputDf <- data.frame(
    "Index" = precursorIndeces, 
    "Label" = precursorLabels, 
    "m/z"   = mzs, 
    "RT"    = rts, 
    "Metabolite name" = metaboliteNames, 
    "Annotation (present)" = presentAnnotations, 
    "Annotation (putative)" = rep(x = class, times = length(precursorIndeces)), 
    "pValue" = pValues
  )
  
  return(outputDf)
}

output$downloadAllAnnotationResults <- downloadHandler(
  filename = function() {
    createClassifierAnnotationName( "All" )
  },
  content = function(file) {
    print(file)
    outputDf <- createAnnotationResultTableAll()
    write.table(x = outputDf, file = file, sep = "\t", row.names = FALSE, quote = FALSE)
  },
  contentType = 'text/csv'
)

output$downloadMetaboliteFamilyAnnotationResults <- downloadHandler(
  filename = function() {
    createClassifierAnnotationName( names(classToSpectra_class)[[input$annotationResultTableClass_rows_selected]] )
  },
  content = function(file) {
    outputDf <- createAnnotationResultTableForClass()
    write.table(x = outputDf, file = file, sep = "\t", row.names = FALSE, quote = FALSE)
  },
  contentType = 'text/csv'
)

#########################################################################################
## report
output$downloadReport2 <- downloadHandler(
  filename = function() {
    return("MetFamilyReport.pdf")
    #return("MetFamilyReport.html")
  },
  content = function(file) {
    ##########################################################################
    ## files
    
    ## source file and tmp file
    tempReportFile <- file.path(tempdir(), "MetFamilyReport.Rmd")
    reportSourceFile <- "report/Report.Rmd"
    
    ## copy template to tmp dir for reasons of file permissions
    file.copy(from = reportSourceFile, to = tempReportFile, overwrite = TRUE)
    
    ##########################################################################
    ## HCA analyses
    drawHCA = state$showHCAplotPanel
    drawPCA = state$showPCAplotPanel
    
    ##########################################################################
    ## HCA analysis
    if(drawHCA){
      imageFileHCA <- file.path(tempdir(), "HcaTmpFile.png")
      plotHCA(file = imageFileHCA, fileType = "png")
    } else {
      imageFileHCA <- ""
    }
    
    ##########################################################################
    ## PCA analysis
    if(drawPCA){
      imageFilePCA <- file.path(tempdir(), "PcaTmpFile.png")
      plotPCA(file = imageFilePCA, fileType = "png")
    } else {
      imageFilePCA <- ""
    }
    
    # Set up parameters to pass to Rmd document
    params <- list(
      creationTime = date(),
      importParameterSet = dataList$importParameterSet,
      drawHCA = drawHCA,
      drawPCA = drawPCA,
      imageFileHCA = imageFileHCA,
      imageFilePCA = imageFilePCA,
      clusterDataList = clusterDataList,
      pcaDataList = pcaDataList
    )
    
    # Knit the document and eval it in a child of the global environment (this isolates the code in the document from the code in this app)
    rmarkdown::render(input = tempReportFile, output_file = file,
                      output_format = "pdf_document",
                      params = params,
                      envir = new.env(parent = globalenv()),
                      quiet = FALSE
    )
  },
  contentType = "application/pdf"
)

================
File: inst/MetFamily/app_files/server_functionsFilters.R
================
## filter
filterGlobal <- NULL
filterHca <- NULL
filterPca <- NULL
filterSearch <- NULL


state_filters <- reactiveValues(
  ## filter stuff
  globalMS2filterValid = FALSE, 
  hcaFilterValid = FALSE, 
  pcaFilterValid = FALSE,
  searchFilterValid = TRUE,
  filterSearchActive = FALSE
)
resetWorkspaceFunctions <- c(resetWorkspaceFunctions, function(){
  print("Reset filters state")
  
  #########################################################################################
  ## update filter
  sampleSet <- dataList$grouXXXpsampleDataFrame[, "Sample"][!dataList$groupSampleDataFrame[, "Exclude"]]
  filter <- doPerformFiltering(dataList$grouXXXps, sampleSet, FALSE, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, TRUE)$filter
  if(length(dataList$grouXXXps) == 1)
    filter2 <- doPerformFiltering(c(dataList$grouXXXps[[1]], dataList$grouXXXps[[1]]), NULL, FALSE, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, TRUE)$filter
  else
    filter2 <- filter
  
  filterGlobal <<- filter
  filterHca    <<- filter2
  filterPca    <<- filter
  state_filters$filterSearchActive <<- FALSE
  state_filters$searchFilterValid <<- TRUE
  filterSearch    <<- NULL
  
  updateGlobalMS2filterInformation()
  updateHcaFilterInformation()
  updatePcaFilterInformation()
  updateSearchInformation()
  
  state_filters$globalMS2filterValid <<- TRUE
  state_filters$hcaFilterValid <<- TRUE
  state_filters$pcaFilterValid <<- TRUE
  
  checkHcaFilterValidity(filter2$numberOfPrecursorsFiltered)
  checkPcaFilterValidity(filter$numberOfPrecursorsFiltered)
  
  #########################################################################################
  ## update filter input values
  
  ## grouXXXps
  switch(as.character(length(dataList$grouXXXps)), 
         "0"={
           stop("No grouXXXps available")
         },
         "1"={
           selectedOne <- dataList$grouXXXps[[1]]
           selectedTwo <- dataList$grouXXXps[[1]]
         },
         {
           selectedOne <- dataList$grouXXXps[[1]]
           selectedTwo <- dataList$grouXXXps[[2]]
         }
  )
  
  sampleNames <- dataList$groupSampleDataFrame[, "Sample"]
  
  ## input fields: global MS/MS filter
  updateTextInput(session = session, inputId = "globalFilter_ms2_masses1", value = "")
  updateTextInput(session = session, inputId = "globalFilter_ms2_masses2", value = "")
  updateTextInput(session = session, inputId = "globalFilter_ms2_masses3", value = "")
  updateTextInput(session = session, inputId = "globalFilter_ms2_ppm", value = "20")
  
  ## input fields: HCA filter
  updateRadioButtons(session = session, inputId = "hcaFilterGroupOne", choices = dataList$grouXXXps, selected = selectedOne)
  updateRadioButtons(session = session, inputId = "hcaFilterGroupTwo", choices = dataList$grouXXXps, selected = selectedTwo)
  updateTextInput(session = session, inputId = "hcaFilter_average", value = "0")
  updateTextInput(session = session, inputId = "hcaFilter_lfc", value = "0")
  updateCheckboxInput(session = session, inputId = "hcaFilterIncludeIgnoredPrecursors", value = FALSE)
  
  ## input fields: PCA filter
  updateCheckboxGroupInput(session = session, inputId = "pcaGroups",   choices = dataList$grouXXXps, selected = dataList$grouXXXps)
  updateCheckboxGroupInput(session = session, inputId = "pcaSamples",  choices = sampleNames,     selected = sampleNames)
  updateTextInput(session = session, inputId = "pcaFilter_average", value = "0")
  updateTextInput(session = session, inputId = "pcaFilter_lfc", value = "0")
  updateCheckboxInput(session = session, inputId = "pcaFilterIncludeIgnoredPrecursors", value = FALSE)
})


## filter info
updateGlobalMS2filterInformation <- function(){
  if(is.null(filterGlobal)){
    output$globalMS2filteredPrecursors <- renderText({
      print(paste("update output$globalMS2filteredPrecursors invalid filters", sep = ""))
      paste("There are invalid filter values", sep = "")
    })
  } else {
    output$globalMS2filteredPrecursors <- renderText({
      print(paste("update output$globalMS2filteredPrecursors", sep = ""))
      paste("Number of filtered MS1 features: ", filterGlobal$numberOfPrecursorsFiltered, " / ", dataList$numberOfPrecursors, sep = "")
    })
  }
}
updateHcaFilterInformation <- function(){
  if(is.null(filterHca)){
    ## errors
    output$hcaFilteredPrecursors <- renderText({
      print(paste("update output$hcaFilteredPrecursors invalid filters", sep = ""))
      paste("There are invalid filter values.", sep = "")
    })
  } else {
    ## no errors
    globalMs2Filter <- ifelse(filterGlobal$numberOfPrecursorsFiltered != dataList$numberOfPrecursors, paste("\n(Global MS/MS filter: ", filterGlobal$numberOfPrecursorsFiltered, " / ", dataList$numberOfPrecursors, " precursors)", sep = ""), "")
    
    if(filterHca$numberOfPrecursorsFiltered >= minimumNumberOfPrecursorsForHca & filterHca$numberOfPrecursorsFiltered <= maximumNumberOfPrecursorsForHca){
      ## filter valid
      output$hcaFilteredPrecursors <- renderText({
        print(paste("update output$hcaFilteredPrecursors ", minimumNumberOfPrecursorsForHca, " <= # <= ", maximumNumberOfPrecursorsForHca, sep = ""))
        paste("Number of filtered MS1 features: ", filterHca$numberOfPrecursorsFiltered, " / ", filterGlobal$numberOfPrecursorsFiltered, globalMs2Filter, sep = "")
      })
    } else {
      ## filter invalid
      
      ## update info
      if(filterHca$numberOfPrecursorsFiltered == 0){
        output$hcaFilteredPrecursors <- renderText({
          print(paste("update output$hcaFilteredPrecursors # = 0", sep = ""))
          paste("There are no MS\u00B9 features which fulfill the given criteria.", globalMs2Filter, sep = "")
        })
      }
      if(filterHca$numberOfPrecursorsFiltered > 0 & filterHca$numberOfPrecursorsFiltered < minimumNumberOfPrecursorsForHca){
        output$hcaFilteredPrecursors <- renderText({
          print(paste("update output$hcaFilteredPrecursors 0 < # < ", minimumNumberOfPrecursorsForHca, sep = ""))
          paste("There are only ", filterHca$numberOfPrecursorsFiltered, " / ", filterGlobal$numberOfPrecursorsFiltered, " MS\u00B9 features which fulfill the given criteria. There must be at least more than five MS\u00B9 features to proceed.", globalMs2Filter, sep = "")
        })
      }
      if(filterHca$numberOfPrecursorsFiltered > maximumNumberOfPrecursorsForHca){
        output$hcaFilteredPrecursors <- renderText({
          print(paste("update output$hcaFilteredPrecursors # > ", maximumNumberOfPrecursorsForHca, sep = ""))
          paste("There are ", filterHca$numberOfPrecursorsFiltered, " / ", filterGlobal$numberOfPrecursorsFiltered, " MS\u00B9 features which fulfill the given criteria. There must be at most ", maximumNumberOfPrecursorsForHca, " MS\u00B9 features to proceed.", globalMs2Filter, sep = "")
        })
      }
    }
  }
}
updatePcaFilterInformation <- function(){
  if(is.null(filterPca)){
    output$pcaFilteredPrecursors <- renderText({
      print(paste("update output$pcaFilteredPrecursors invalid filters", sep = ""))
      paste("There are invalid filter values.", sep = "")
    })
  } else {
    globalMs2Filter <- ifelse(filterGlobal$numberOfPrecursorsFiltered != dataList$numberOfPrecursors, paste("\n(Global MS/MS filter: ", filterGlobal$numberOfPrecursorsFiltered, " / ", dataList$numberOfPrecursors, " precursors)", sep = ""), "")
    if(filterPca$numberOfPrecursorsFiltered > 0){
      output$pcaFilteredPrecursors <- renderText({
        print(paste("update output$pcaFilteredPrecursors", sep = ""))
        paste("Number of filtered MS1 features: ", filterPca$numberOfPrecursorsFiltered, " / ", filterGlobal$numberOfPrecursorsFiltered, globalMs2Filter, sep = "")
      })
    } else {
      output$pcaFilteredPrecursors <- renderText({
        print(paste("update output$pcaFilteredPrecursors", sep = ""))
        paste("There are no MS\u00B9 features which fulfill the given criteria.", globalMs2Filter, sep = "")
      })
    }
  }
}

## perform filtering
doPerformFiltering <- function(groupSet, sampleSet, filterBySamples, filter_average, filter_lfc, filter_ms2_masses1, filter_ms2_masses2, filter_ms2_masses3, filter_ms2_ppm, filter_ms1_masses, filter_ms1_ppm, includeIgnoredPrecursors, preFilter = NULL){
  suppressWarnings(
    doPerformFiltering_impl(groupSet, sampleSet, filterBySamples, filter_average, filter_lfc, filter_ms2_masses1, filter_ms2_masses2, filter_ms2_masses3, filter_ms2_ppm, filter_ms1_masses, filter_ms1_ppm, includeIgnoredPrecursors, preFilter)
  )
}
doPerformFiltering_impl <- function(groupSet, sampleSet, filterBySamples, filter_average, filter_lfc, filter_ms2_masses1, filter_ms2_masses2, filter_ms2_masses3, filter_ms2_ppm, filter_ms1_masses, filter_ms1_ppm, includeIgnoredPrecursors, preFilter = NULL){
  print(paste("Observe applyFilters1", "gs", paste(groupSet, collapse = "-"), "a", filter_average, "lfc", filter_lfc, "ms2_1", filter_ms2_masses1, "ms2_2", filter_ms2_masses2, "ms2_3", filter_ms2_masses3, "ppm", filter_ms2_ppm, "ig", includeIgnoredPrecursors))
  
  groupSetOriginal                 <- groupSet
  sampleSetOriginal                <- sampleSet
  filterBySamplesOriginal          <- filterBySamples
  filter_averageOriginal           <- filter_average
  filter_lfcOriginal               <- filter_lfc
  filter_ms2_masses1Original       <- filter_ms2_masses1
  filter_ms2_masses2Original       <- filter_ms2_masses2
  filter_ms2_masses3Original       <- filter_ms2_masses3
  filter_ms2_ppmOriginal           <- filter_ms2_ppm
  filter_ms1_massesOriginal        <- filter_ms1_masses
  filter_ms1_ppmOriginal           <- filter_ms1_ppm
  includeIgnoredPrecursorsOriginal <- includeIgnoredPrecursors
  
  #################################################
  ## parse inputs
  print(paste("Observe applyFilters2", "gs", paste(groupSet, collapse = "-"), "ss", paste(sampleSet, collapse = "-"), "fbss", filterBySamples, "a", filter_average, "lfc", filter_lfc, "ms2 1", filter_ms2_masses1, "ms2 2", filter_ms2_masses2, "ms2 3", filter_ms2_masses3, "ppm", filter_ms2_ppm, "i", includeIgnoredPrecursors))
  print(paste("Observe applyFilters3", "gs", is.null(groupSet), "ss", is.null(sampleSet), "gs", is.null(filterBySamples), "a", is.null(filter_average), "lfc", is.null(filter_lfc), "ms2 1", is.null(filter_ms2_masses1), "ms2 2", is.null(filter_ms2_masses2), "ms2 3", is.null(filter_ms2_masses3), "ppm", is.null(filter_ms2_ppm), "i", includeIgnoredPrecursors))
  
  #################################################
  ## sanity checks
  if(all(!is.null(filter_lfc), !is.na(filter_lfc), filter_lfc != 0) & length(groupSet) != 2)
    stop("lfc filter for not exactly two groups")
  
  #################################################
  ## check for errors in inputs amd process ms2
  error <- FALSE
  if(any(is.null(groupSet), is.na(groupSet), length(groupSet) == 0, any(nchar(groupSet) == 0)))
    error <- TRUE
  
  if(any(is.null(filter_average), is.na(filter_average), length(filter_average) == 0, nchar(filter_average) == 0))
    filter_average <- NULL
  else{
    filter_average <- as.numeric(filter_average)
    error <- error | is.na(filter_average)
  }
  
  if(any(is.null(filter_lfc), is.na(filter_lfc), length(filter_lfc) == 0, nchar(filter_lfc) == 0))
    filter_lfc <- NULL
  else{
    filter_lfc <- as.numeric(filter_lfc)
    error <- error | is.na(filter_lfc)
  }
  
  if(any(is.null(filter_ms2_masses1), is.na(filter_ms2_masses1), length(filter_ms2_masses1) == 0, nchar(filter_ms2_masses1) == 0))
    filter_ms2_masses1 <- NULL
  else{
    ms2Masses <- strsplit(x = filter_ms2_masses1, split = "[,; ]+")[[1]]
    filter_ms2_masses1 <- vector(mode = "numeric", length = length(ms2Masses))
    for(idx in 1:length(ms2Masses))
      filter_ms2_masses1[[idx]] <- as.numeric(ms2Masses[[idx]])
    error <- error | any(is.na(filter_ms2_masses1))
  }
  if(any(is.null(filter_ms2_masses2), is.na(filter_ms2_masses2), length(filter_ms2_masses2) == 0, nchar(filter_ms2_masses2) == 0))
    filter_ms2_masses2 <- NULL
  else{
    ms2Masses <- strsplit(x = filter_ms2_masses2, split = "[,; ]+")[[1]]
    filter_ms2_masses2 <- vector(mode = "numeric", length = length(ms2Masses))
    for(idx in 1:length(ms2Masses))
      filter_ms2_masses2[[idx]] <- as.numeric(ms2Masses[[idx]])
    error <- error | any(is.na(filter_ms2_masses2))
  }
  if(any(is.null(filter_ms2_masses3), is.na(filter_ms2_masses3), length(filter_ms2_masses3) == 0, nchar(filter_ms2_masses3) == 0))
    filter_ms2_masses3 <- NULL
  else{
    ms2Masses <- strsplit(x = filter_ms2_masses3, split = "[,; ]+")[[1]]
    filter_ms2_masses3 <- vector(mode = "numeric", length = length(ms2Masses))
    for(idx in 1:length(ms2Masses))
      filter_ms2_masses3[[idx]] <- as.numeric(ms2Masses[[idx]])
    error <- error | any(is.na(filter_ms2_masses3))
  }
  
  if(any(is.null(filter_ms2_ppm), is.na(filter_ms2_ppm), length(filter_ms2_ppm) == 0, nchar(filter_ms2_ppm) == 0))
    filter_ms2_ppm <- NULL
  else{
    filter_ms2_ppm <- as.numeric(filter_ms2_ppm)
    error <- error | is.na(filter_ms2_ppm)
  }
  
  if(any(is.null(filter_ms1_masses), is.na(filter_ms1_masses), length(filter_ms1_masses) == 0, nchar(filter_ms1_masses) == 0))
    filter_ms1_masses <- NULL
  else{
    ms1Masses <- strsplit(x = filter_ms1_masses, split = "[,; ]+")[[1]]
    filter_ms1_masses <- vector(mode = "numeric", length = length(ms1Masses))
    for(idx in 1:length(ms1Masses))
      filter_ms1_masses[[idx]] <- as.numeric(ms1Masses[[idx]])
    error <- error | any(is.na(filter_ms1_masses))
  }
  
  if(any(is.null(filter_ms1_ppm), is.na(filter_ms1_ppm), length(filter_ms1_ppm) == 0, nchar(filter_ms1_ppm) == 0))
    filter_ms1_ppm <- NULL
  else{
    filter_ms1_ppm <- as.numeric(filter_ms1_ppm)
    error <- error | is.na(filter_ms1_ppm)
  }
  
  ## sanity check
  error <- error | (!is.null(filter_ms1_masses) & any(is.null(filter_ms1_ppm), is.na(filter_ms1_ppm)))
  error <- error | (any(!is.null(filter_ms2_masses1), !is.null(filter_ms2_masses2), !is.null(filter_ms2_masses3)) & any(is.null(filter_ms2_ppm), is.na(filter_ms2_ppm)))
  
  print(paste("Observe applyFilters4", "e", error, "gs", paste(groupSet, collapse = "-"), "ss", paste(sampleSet, collapse = "-"), "fbss", filterBySamples, "a", filter_average, "lfc", filter_lfc, "ms2 1", filter_ms2_masses1, "ms2 2", filter_ms2_masses2, "ms2 3", filter_ms2_masses3, "ppm", filter_ms2_ppm, "i", includeIgnoredPrecursors))
  
  ## collect ms2 masses
  filterList_ms2_masses <- list()
  if(!is.null(filter_ms2_masses1))
    filterList_ms2_masses[[length(filterList_ms2_masses) + 1]] <- filter_ms2_masses1
  if(!is.null(filter_ms2_masses2))
    filterList_ms2_masses[[length(filterList_ms2_masses) + 1]] <- filter_ms2_masses2
  if(!is.null(filter_ms2_masses3))
    filterList_ms2_masses[[length(filterList_ms2_masses) + 1]] <- filter_ms2_masses3
  
  #################################################
  ## do filtering and wrap results
  resultObj <- list()
  resultObj$error  <- error
  
  if(error){
    resultObj$filter <- NULL
  } else {
    filterHere <- filterData(
      dataList = dataList, 
      #groupOne = groupOne, groupTwo = groupTwo, 
      grouXXXps = groupSet, sampleSet, filterBySamples, filter_average = filter_average, filter_lfc = filter_lfc, 
      filterList_ms2_masses = filterList_ms2_masses, filter_ms2_ppm = filter_ms2_ppm, 
      filter_ms1_masses = filter_ms1_masses, filter_ms1_ppm = filter_ms1_ppm,
      includeIgnoredPrecursors = includeIgnoredPrecursors,
      progress = FALSE
    )
    
    ## set original values
    if(is.null(groupSetOriginal)){
      filterHere$groupSetOriginal <- list()
    } else {
      filterHere$groupSetOriginal  <- groupSetOriginal
      filterHere$sampleSetOriginal <- sampleSetOriginal
      filterHere$filterBySamplesOriginal <- filterBySamplesOriginal
    }
    #filterHere$groupSetOriginal                 <- ifelse(test = is.null(groupSetOriginal),                 yes = NA, no = groupSetOriginal)
    filterHere$filter_averageOriginal           <- ifelse(test = is.null(filter_averageOriginal),           yes = 0,  no = filter_averageOriginal)
    filterHere$filter_lfcOriginal               <- ifelse(test = is.null(filter_lfcOriginal),               yes = 0,  no = filter_lfcOriginal)
    if(is.null(filter_ms2_masses1Original)){
      filterHere$filter_ms2_masses1Original <- list()
    } else {
      filterHere$filter_ms2_masses1Original <- filter_ms2_masses1Original
    }
    #filterHere$filter_ms2_masses1Original       <- ifelse(test = is.null(filter_ms2_masses1Original),       yes = "", no = filter_ms2_masses1Original)
    if(is.null(filter_ms2_masses2Original)){
      filterHere$filter_ms2_masses2Original <- list()
    } else {
      filterHere$filter_ms2_masses2Original <- filter_ms2_masses2Original
    }
    #filterHere$filter_ms2_masses2Original       <- ifelse(test = is.null(filter_ms2_masses2Original),       yes = "", no = filter_ms2_masses2Original)
    if(is.null(filter_ms2_masses3Original)){
      filterHere$filter_ms2_masses3Original <- list()
    } else {
      filterHere$filter_ms2_masses3Original <- filter_ms2_masses3Original
    }
    #filterHere$filter_ms2_masses3Original       <- ifelse(test = is.null(filter_ms2_masses3Original),       yes = "", no = filter_ms2_masses3Original)
    filterHere$filter_ms2_ppmOriginal           <- ifelse(test = is.null(filter_ms2_ppmOriginal),           yes = "", no = filter_ms2_ppmOriginal)
    if(is.null(filter_ms1_massesOriginal)){
      filterHere$filter_ms1_massesOriginal <- list()
    } else {
      filterHere$filter_ms1_massesOriginal <- filter_ms1_massesOriginal
    }
    #filterHere$filter_ms1_massesOriginal        <- ifelse(test = is.null(filter_ms1_massesOriginal),        yes = "", no = filter_ms1_massesOriginal)
    filterHere$filter_ms1_ppmOriginal           <- ifelse(test = is.null(filter_ms1_ppmOriginal),           yes = "", no = filter_ms1_ppmOriginal)
    filterHere$includeIgnoredPrecursorsOriginal <- ifelse(test = is.null(includeIgnoredPrecursorsOriginal), yes = NA, no = includeIgnoredPrecursorsOriginal)
    
    resultObj$error  <- error
    resultObj$filter <- filterHere
    print(paste("Observe applyFilters5", "n", resultObj$filter$numberOfPrecursorsFiltered))
  }
  
  return(resultObj)
}

checkHcaFilterValidity <- function(numberOfPrecursorsFiltered){
  if(numberOfPrecursorsFiltered >= minimumNumberOfPrecursorsForHca & numberOfPrecursorsFiltered <= maximumNumberOfPrecursorsForHca){
    ## filter valid
    print(paste("Observe applyFilters ", minimumNumberOfPrecursorsForHca, " <= # <= ", maximumNumberOfPrecursorsForHca, sep = ""))
    
    shinyjs::enable("drawHCAplots")
    #enableActionButton(session, "drawHCAplots")
    state_filters$hcaFilterValid <<- TRUE
  } else {
    ## filter invalid
    
    shinyjs::disable("drawHCAplots")
    #disableActionButton(session, "drawHCAplots")
    state_filters$hcaFilterValid <<- FALSE
  }
}
checkPcaFilterValidity <- function(numberOfPrecursorsFiltered){
  if(numberOfPrecursorsFiltered > 0){
    ## filter valid
    print(paste("Observe applyFilters # > 0", sep = ""))
    
    shinyjs::enable("drawPCAplots")
    state_filters$pcaFilterValid <<- TRUE
  } else {
    ## filter invalid
    print(paste("Observe applyFilters # = 0", sep = ""))
    
    shinyjs::disable("drawPCAplots")
    state_filters$pcaFilterValid <<- FALSE
  }
}

applyGlobalMS2filters <- function(filter_ms2_masses1, filter_ms2_masses2, filter_ms2_masses3, filter_ms2_ppm){
  groupSet        <- dataList$grouXXXps
  filter_average  <- NULL
  filter_lfc      <- NULL
  includeIgnoredPrecursors  <- TRUE
  filter_ms1_masses <- NULL
  filter_ms1_ppm <- NULL
  
  #################################################
  ## do filtering
  sampleSet <- dataList$groupSampleDataFrame[, "Sample"][!dataList$groupSampleDataFrame[, "Exclude"]]
  filterBySamples <- TRUE
  resultObj <- doPerformFiltering(groupSet, sampleSet, filterBySamples, filter_average, filter_lfc, filter_ms2_masses1, filter_ms2_masses2, filter_ms2_masses3, filter_ms2_ppm, filter_ms1_masses, filter_ms1_ppm, includeIgnoredPrecursors)
  
  if(resultObj$error){
    filterGlobal <<- NULL
    state_filters$globalMS2filterValid <<- FALSE
  } else {
    filterGlobal <<- resultObj$filter
    state_filters$globalMS2filterValid <<- TRUE
  }
  updateGlobalMS2filterInformation()
}
obsApplyHcaFilters <- observeEvent(input$applyHcaFilters, {
  session$sendCustomMessage("disableButton", "applyHcaFilters")
  applyHcaFilters <- as.numeric(input$applyHcaFilters)
  
  print(paste("Observe applyHcaFilters", applyHcaFilters))
  
  #################################################
  ## check if button was hit
  #if(applyHcaFilters == applyHcaFiltersButtonValue)
  #  return()
  #applyHcaFiltersButtonValue <<- applyHcaFilters
  
  #################################################
  ## get inputs
  groupOne        <- input$hcaFilterGroupOne
  groupTwo        <- input$hcaFilterGroupTwo
  filter_average  <- input$hcaFilter_average
  filter_lfc      <- input$hcaFilter_lfc
  includeIgnoredPrecursors  <- input$hcaFilterIncludeIgnoredPrecursors
  
  applyHcaFilters(groupOne, groupTwo, filter_average, filter_lfc, includeIgnoredPrecursors)
  session$sendCustomMessage("enableButton", "applyHcaFilters")
})
obsClearHcaFilters <- observeEvent(input$clearHcaFilters, {
  session$sendCustomMessage("disableButton", "clearHcaFilters")
  clearHcaFilters <- as.numeric(input$clearHcaFilters)
  
  print(paste("Observe clearHcaFilters", clearHcaFilters))
  
  #################################################
  ## check if button was hit
  #if(clearHcaFilters == clearHcaFiltersButtonValue)
  #  return()
  #clearHcaFiltersButtonValue <<- clearHcaFilters
  
  #################################################
  ## get inputs
  groupOne        <- input$hcaFilterGroupOne
  groupTwo        <- input$hcaFilterGroupTwo
  filter_average  <- ""
  filter_lfc      <- ""
  includeIgnoredPrecursors  <- TRUE
  
  applyHcaFilters(groupOne, groupTwo, filter_average, filter_lfc, includeIgnoredPrecursors)
  session$sendCustomMessage("enableButton", "clearHcaFilters")
})
applyHcaFilters <- function(groupOne, groupTwo, filter_average, filter_lfc, includeIgnoredPrecursors){
  filter_ms2_masses1  <- filterGlobal$filter_ms2_masses1Original   
  filter_ms2_masses2  <- filterGlobal$filter_ms2_masses2Original   
  filter_ms2_masses3  <- filterGlobal$filter_ms2_masses3Original   
  filter_ms2_ppm      <- filterGlobal$filter_ms2_ppmOriginal
  
  filter_ms1_masses <- NULL
  filter_ms1_ppm  <- NULL
  groupSet        <- c(groupOne, groupTwo)
  sampleSet       <- dataList$groupSampleDataFrame[, "Sample"][!dataList$groupSampleDataFrame[, "Exclude"]]
  filterBySamples <- TRUE
  #################################################
  ## do filtering and update
  resultObj <- doPerformFiltering(groupSet, sampleSet, filterBySamples, filter_average, filter_lfc, filter_ms2_masses1, filter_ms2_masses2, filter_ms2_masses3, filter_ms2_ppm, filter_ms1_masses, filter_ms1_ppm, includeIgnoredPrecursors)
  
  if(resultObj$error){
    shinyjs::disable("drawHCAplots")
    #disableActionButton(session, "drawHCAplots")
    filterHca <<- NULL
    updateHcaFilterInformation()
    state_filters$hcaFilterValid <<- FALSE
    return()
  }
  
  #################################################
  ## check filter validity
  filterHca <<- resultObj$filter
  updateHcaFilterInformation()
  
  numberOfPrecursorsFiltered <- filterHca$numberOfPrecursorsFiltered
  checkHcaFilterValidity(numberOfPrecursorsFiltered)
}
obsApplyPcaFilters <- observeEvent(input$applyPcaFilters, {
  session$sendCustomMessage("disableButton", "applyPcaFilters")
  applyPcaFilters <- as.numeric(input$applyPcaFilters)
  
  print(paste("Observe applyPcaFilters", applyPcaFilters))
  
  #################################################
  ## check if button was hit
  #if(applyPcaFilters == applyPcaFiltersButtonValue)
  #  return()
  #applyPcaFiltersButtonValue <<- applyPcaFilters
  
  #################################################
  ## get inputs
  groupSet        <- input$pcaGroups
  sampleSet       <- input$pcaSamples
  filterBySamples <- input$filterByPCAgroupSamples
  filter_average  <- input$pcaFilter_average
  filter_lfc      <- input$pcaFilter_lfc
  includeIgnoredPrecursors  <- input$pcaFilterIncludeIgnoredPrecursors
  
  if(filterBySamples){
    ## update grouXXXps and samples mutually
    
    ## grouXXXps which are covered by at least one sample
    groupsFromSamples <- unlist(lapply(X = dataList$grouXXXps, FUN = function(x){
      samplesOfGroups <- dataList$dataColumnsNameFunctionFromGroupName(group = x, sampleNamesToExclude = dataList$excludedSamples(dataList$groupSampleDataFrame))
      if(any(samplesOfGroups %in% sampleSet))
        return(x)
      else
        return(NULL)
    }))
    
    ## samples which ae covered by a group
    samplesFromGroups <- dataList$dataColumnsNameFunctionFromGroupNames(grouXXXps = groupSet, sampleNamesToExclude = dataList$excludedSamples(dataList$groupSampleDataFrame))
    groupSet  <- intersect(groupSet, groupsFromSamples)
    sampleSet <- intersect(sampleSet, samplesFromGroups)
  } else {
    sampleSet <- dataList$groupSampleDataFrame[, "Sample"][!dataList$groupSampleDataFrame[, "Exclude"]]
  }
  
  if(length(groupSet) != 2)
    filter_lfc <- NULL
  
  applyPcaFilters(groupSet, sampleSet, filterBySamples, filter_average, filter_lfc, includeIgnoredPrecursors)
  session$sendCustomMessage("enableButton", "applyPcaFilters")
})
obsClearPcaFilters <- observeEvent(input$clearPcaFilters, {
  session$sendCustomMessage("disableButton", "clearPcaFilters")
  clearPcaFilters <- as.numeric(input$clearPcaFilters)
  
  print(paste("Observe clearPcaFilters", clearPcaFilters))
  
  #################################################
  ## check if button was hit
  #if(clearPcaFilters == clearPcaFiltersButtonValue)
  #  return()
  #clearPcaFiltersButtonValue <<- clearPcaFilters
  
  #################################################
  ## get inputs
  groupSet        <- dataList$grouXXXps
  sampleSet       <- dataList$groupSampleDataFrame[, "Sample"][!dataList$groupSampleDataFrame[, "Exclude"]]
  filterByPCAgroupSamples <- TRUE
  filter_average  <- ""
  filter_lfc      <- ""
  includeIgnoredPrecursors  <- TRUE
  
  if(length(groupSet) != 2)
    filter_lfc <- NULL
  
  applyPcaFilters(groupSet, sampleSet, filterByPCAgroupSamples, filter_average, filter_lfc, includeIgnoredPrecursors)
  session$sendCustomMessage("enableButton", "clearPcaFilters")
})

applyPcaFilters_default <- function(){
  if(!is.null(filterPca)){
    applyPcaFilters(
      groupSet = filterPca$groupSetOriginal, 
      sampleSet = filterPca$sampleSetOriginal, 
      filterBySamples = filterPca$filterBySamplesOriginal, 
      filter_average = filterPca$filter_averageOriginal, 
      filter_lfc = filterPca$filter_lfcOriginal, 
      includeIgnoredPrecursors = filterPca$includeIgnoredPrecursorsOriginal
    )
  } else {
    stop("Tried to apply pca filtering without filterPca obj")
  }
}
applyPcaFilters <- function(groupSet, sampleSet, filterBySamples, filter_average, filter_lfc, includeIgnoredPrecursors){
  filter_ms2_masses1  <- filterGlobal$filter_ms2_masses1Original   
  filter_ms2_masses2  <- filterGlobal$filter_ms2_masses2Original   
  filter_ms2_masses3  <- filterGlobal$filter_ms2_masses3Original   
  filter_ms2_ppm      <- filterGlobal$filter_ms2_ppmOriginal
  
  filter_ms1_masses <- NULL
  filter_ms1_ppm  <- NULL
  
  #################################################
  ## do filtering and update
  resultObj <- doPerformFiltering(groupSet, sampleSet, filterBySamples, filter_average, filter_lfc, filter_ms2_masses1, filter_ms2_masses2, filter_ms2_masses3, filter_ms2_ppm, filter_ms1_masses, filter_ms1_ppm, includeIgnoredPrecursors)
  
  if(resultObj$error){
    shinyjs::disable("drawPCAplots")
    #disableActionButton(session, "drawPCAplots")
    filterPca <<- NULL
    updatePcaFilterInformation()
    state_filters$pcaFilterValid <<- FALSE
    return()
  }
  
  filterPca <<- resultObj$filter
  updatePcaFilterInformation()
  
  numberOfPrecursorsFiltered <- filterPca$numberOfPrecursorsFiltered
  checkPcaFilterValidity(numberOfPrecursorsFiltered)
}

suspendOnExitFunctions <- c(suspendOnExitFunctions, function(){
  print("Suspending filters observers")
  obsApplyHcaFilters$suspend()
  obsClearHcaFilters$suspend()
  obsApplyPcaFilters$suspend()
  obsClearPcaFilters$suspend()
})

output$globalMS2filterValid <- reactive({
  print(paste("reactive update globalMS2filterValid", state_filters$globalMS2filterValid))
  return(state_filters$globalMS2filterValid)
})
output$hcaFilterValid <- reactive({
  print(paste("reactive update hcaFilterValid", state_filters$hcaFilterValid))
  return(state_filters$hcaFilterValid)
})
output$pcaFilterValid <- reactive({
  print(paste("reactive update pcaFilterValid", state_filters$pcaFilterValid))
  return(state_filters$pcaFilterValid)
})
output$searchFilterValid <- reactive({
  print(paste("reactive update searchFilterValid", state_filters$searchFilterValid))
  return(state_filters$searchFilterValid)
})
output$filterSearchActive <- reactive({
  print(paste("reactive update filterSearchActive", state_filters$filterSearchActive))
  return(state_filters$filterSearchActive)
})

outputOptions(output, 'globalMS2filterValid',    suspendWhenHidden=FALSE)
outputOptions(output, 'hcaFilterValid',          suspendWhenHidden=FALSE)
outputOptions(output, 'pcaFilterValid',          suspendWhenHidden=FALSE)
outputOptions(output, 'searchFilterValid',       suspendWhenHidden=FALSE)
outputOptions(output, 'filterSearchActive',      suspendWhenHidden=FALSE)

================
File: inst/MetFamily/app_files/server_functionsSelections.R
================
## selections
selectionAnalysisName <- "Selection by HCA/PCA"
selectionFragmentName <- "Selection by fragment"
selectionSearchName   <- "Selection by search"
precursorSelectionTabSelection  <- "Selection"
precursorSelectionTabAnnotation <- "Annotation"
precursorSelectionTabTable      <- "Table"
precursorSelectionTabSpectrum   <- "Fragments"
selectionAnalysisHcaName <- "Analysis_HCA"
selectionAnalysisPcaName <- "Analysis_PCA"
selectionFragmentHcaName <- "Fragment_HCA"
selectionFragmentPcaName <- "Fragment_PCA"
selectionSearchHcaName   <- "Search_HCA"
selectionSearchPcaName   <- "Search_PCA"

changeSelectionCurrentSelection <- selectionAnalysisName
precursorSelectionTabCurrentTab <- precursorSelectionTabSelection

## selection MS2
selectionFragmentSelectedFragmentIndex <- NULL
selectionFragmentTreeNodeSet <- NULL
selectionFragmentPcaLoadingSet <- NULL
## selection analysis
selectionAnalysisTreeNodeSet <- NULL
selectionAnalysisPcaLoadingSet <- NULL
## selection search
selectionSearchTreeNodeSet <- NULL
selectionSearchPcaLoadingSet <- NULL

## table data
ms1FeatureTableInputFieldIdCounter <- 0
selectedPrecursorSet <- NULL

selectedTable <- NULL
selectedTable_id <- NULL
table <- reactiveValues(
  df_Fragment_HCA = NULL,
  df_Fragment_PCA = NULL,
  df_Search_HCA = NULL,
  df_Search_PCA = NULL,
  df_Analysis_HCA = NULL,
  df_Analysis_PCA = NULL
)
listForTable_Fragment_HCA = NULL
listForTable_Fragment_PCA = NULL
listForTable_Analysis_HCA = NULL
listForTable_Analysis_PCA = NULL
listForTable_Search_HCA = NULL
listForTable_Search_PCA = NULL

table_Fragment_HCA_id = NULL
table_Fragment_PCA_id = NULL
table_Analysis_HCA_id = NULL
table_Analysis_PCA_id = NULL
table_Search_HCA_id = NULL
table_Search_PCA_id = NULL


state_selections <- reactiveValues(
  ## precursor set selections
  precursorSetSelected = FALSE,
  selectedSelection = NULL
)
resetWorkspaceFunctions <- c(resetWorkspaceFunctions, function(){
  print("Reset selection state")
  state_selections$precursorSetSelected <<- FALSE
  state_selections$selectedSelection <<- NULL
  
  ## selection
  selectedPrecursorSet <<- NULL
  selectedTable <<- NULL
  
  selectionFragmentSelectedFragmentIndex <- NULL
  
  selectionFragmentTreeNodeSet <- NULL
  selectionAnalysisTreeNodeSet <- NULL
  selectionSearchTreeNodeSet <- NULL
  
  selectionFragmentPcaLoadingSet <- NULL
  selectionAnalysisPcaLoadingSet <- NULL
  selectionSearchPcaLoadingSet <- NULL
  
  selectionByFragmentReset()
  selectionByAnalysisReset()
  selectionBySearchReset()
})


selectionByFragmentReset <- function(){
  selectionFragmentSelectedFragmentIndex <<- NULL
  
  if(!is.null(selectionFragmentTreeNodeSet)){ ## HCA
    selectionFragmentSelectedFragmentIndex <<- NULL
    selectionFragmentTreeNodeSet <<- NULL
    listForTable_Fragment_HCA <<- NULL
    table_Fragment_HCA_id <<- NULL
    table$df_Fragment_HCA <<- NULL
    #output$dt_Fragment_HCA <- DT::renderDataTable(NULL)
    if(!is.null(state_selections$selectedSelection))
      if(state_selections$selectedSelection == selectionFragmentHcaName)
        updateSelectedPrecursorSet()
  }
  if(!is.null(selectionFragmentPcaLoadingSet)){ ## PCA
    selectionFragmentPcaLoadingSet <<- NULL
    listForTable_Fragment_PCA <<- NULL
    table_Fragment_PCA_id <<- NULL
    table$df_Fragment_PCA <<- NULL
    #output$dt_Fragment_PCA <- DT::renderDataTable(NULL)
    if(!is.null(state_selections$selectedSelection))
      if(state_selections$selectedSelection == selectionFragmentPcaName)
        updateSelectedPrecursorSet()
  }
}
selectionByFragment <- function(minimumIndex){
  selectionFragmentSelectedFragmentIndex <<- minimumIndex
  
  fragmentMass  <- ms2PlotValues$fragmentListClicked$fragmentMasses[[minimumIndex]]
  fragmentIndex <- which(dataList$fragmentMasses == fragmentMass)
  precursorSet  <- which(dataList$featureMatrix[, fragmentIndex] != 0)
  
  if(state$showHCAplotPanel)
    selectionByFragmentInitHca(precursorSet)
  if(state$showPCAplotPanel)
    selectionByFragmentInitPca(precursorSet)
  
  if(input$changeSelection != selectionFragmentName){
    updateRadioButtons(session = session, inputId = "changeSelection", label = NULL, choices = c(selectionAnalysisName, selectionFragmentName, selectionSearchName), inline = TRUE, selected = selectionFragmentName)
    updateSelectedSelection()
  }
}
selectionByFragmentInitHca <- function(precursorSet){
  ## HCA - fetch subroots of subtrees comprising the selected fragment
  selectionFragmentTreeNodeSet <<- getSetOfSubTreesFromRootForPrecursorSet(dataList = dataList, precursorSet = precursorSet, filter = filterHca$filter, clusterDataList = clusterDataList)
  precursorSetHca <- intersect(x = precursorSet, y = filterHca$filter)
  
  if(length(precursorSetHca) > 0){
    listForTable_Fragment_HCA <<- getTableFromPrecursorSet(dataList = dataList, precursorSet = precursorSetHca)
    table$df_Fragment_HCA <<- createMS1FeatureTable(listForTable_Fragment_HCA, selectionFragmentHcaName)
    table_Fragment_HCA_id <<- ms1FeatureTableInputFieldIdCounter
    #output$dt_Fragment_HCA <- DT::renderDataTable(table$df_Fragment_HCA)
    if(state_selections$selectedSelection == selectionFragmentHcaName)
      updateSelectedPrecursorSet()
  } else {
    listForTable_Fragment_HCA <<- NULL
    table_Fragment_HCA_id <<- NULL
    table$df_Fragment_HCA <<- NULL
    #output$dt_Fragment_HCA <- DT::renderDataTable(table$df_Fragment_HCA)
    if(state_selections$selectedSelection == selectionFragmentHcaName)
      updateSelectedPrecursorSet()
  }
}
selectionByFragmentInitPca <- function(precursorSet){
  ## PCA
  #selectionFragmentPcaLoadingSet <<- which(dataList$featureMatrix[filterPca$filter, fragmentIndex] != 0)
  selectionFragmentPcaLoadingSet <<- which(filterPca$filter %in% precursorSet)
  precursorSetPca <- intersect(x = precursorSet, y = filterPca$filter)
  
  if(length(precursorSetPca) > 0){
    listForTable_Fragment_PCA <<- getTableFromPrecursorSet(dataList = dataList, precursorSet = precursorSetPca)
    table$df_Fragment_PCA <<- createMS1FeatureTable(listForTable_Fragment_PCA, selectionFragmentPcaName)
    table_Fragment_PCA_id <<- ms1FeatureTableInputFieldIdCounter
    #output$dt_Fragment_PCA <- DT::renderDataTable(table$df_Fragment_PCA)
    if(state_selections$selectedSelection == selectionFragmentPcaName)
      updateSelectedPrecursorSet()
  } else {
    listForTable_Fragment_PCA <<- NULL
    table_Fragment_PCA_id <<- NULL
    table$df_Fragment_PCA <<- NULL
    #output$dt_Fragment_PCA <- DT::renderDataTable(table$df_Fragment_PCA)
    if(state_selections$selectedSelection == selectionFragmentPcaName)
      updateSelectedPrecursorSet()
  }
}

selectionByAnalysisReset <- function(){
  if(!is.null(selectionAnalysisTreeNodeSet)){ ## HCA
    selectionAnalysisTreeNodeSet <<- NULL
    listForTable_Analysis_HCA <<- NULL
    table_Analysis_HCA_id <<- NULL
    table$df_Analysis_HCA <<- NULL
    #output$dt_Analysis_HCA <- DT::renderDataTable(NULL)
    if(!is.null(state_selections$selectedSelection))
      if(state_selections$selectedSelection == selectionAnalysisHcaName)
        updateSelectedPrecursorSet()
  }
  if(!is.null(selectionAnalysisPcaLoadingSet)){ ## PCA
    selectionAnalysisPcaLoadingSet <<- NULL
    listForTable_Analysis_PCA <<- NULL
    table_Analysis_PCA_id <<- NULL
    table$df_Analysis_PCA <<- NULL
    #output$dt_Analysis_PCA <- DT::renderDataTable(NULL)
    if(state_selections$selectedSelection == selectionAnalysisPcaName)
      updateSelectedPrecursorSet()
  }
}
selectionByAnalysisInitHca <- function(precursorSet){
  if(any(precursorSet %in% filterHca$filter)){
    #selectionAnalysisTreeNode <<- -match(x = precursorIndex, table = filterHca$filter)
    selectionAnalysisTreeNodeSet <<- getSetOfSubTreesFromRootForPrecursorSet(dataList = dataList, precursorSet = precursorSet, filter = filterHca$filter, clusterDataList = clusterDataList)
    listForTable_Analysis_HCA <<- getTableFromPrecursorSet(dataList = dataList, precursorSet = precursorSet)
    table$df_Analysis_HCA <<- createMS1FeatureTable(listForTable_Analysis_HCA, selectionAnalysisHcaName)
    table_Analysis_HCA_id <<- ms1FeatureTableInputFieldIdCounter
    #output$dt_Analysis_HCA <- DT::renderDataTable(table$df_Analysis_HCA)
    if(state_selections$selectedSelection == selectionAnalysisHcaName)
      updateSelectedPrecursorSet()
  } else {
    selectionAnalysisTreeNodeSet <<- NULL
    listForTable_Analysis_HCA <<- NULL
    table_Analysis_HCA_id <<- NULL
    table$df_Analysis_HCA <<- NULL
    #output$dt_Analysis_HCA <- DT::renderDataTable(NULL)
    if(state_selections$selectedSelection == selectionAnalysisHcaName)
      updateSelectedPrecursorSet()
  }
}
selectionByHca <- function(minimumLabel){
  selectionAnalysisTreeNodeSet <<- minimumLabel
  precursorSet <- getPrecursorSetFromTreeSelection(clusterDataList = clusterDataList, clusterLabel = minimumLabel)
  selectionByHca2(precursorSet)
}
selectionByHca2 <- function(precursorSet){
  listForTable_Analysis_HCA <<- getTableFromPrecursorSet(dataList = dataList, precursorSet = precursorSet)
  table$df_Analysis_HCA <<- createMS1FeatureTable(listForTable_Analysis_HCA, selectionAnalysisHcaName)
  #output$dt_Analysis_HCA <- DT::renderDataTable(table$df_Analysis_HCA)
  if(state_selections$selectedSelection == selectionAnalysisHcaName)
    updateSelectedPrecursorSet()
  
  ## pca selection
  if(state$showPCAplotPanel)
    selectionByAnalysisInitPca(precursorSet)
  
  if(input$changeSelection != selectionAnalysisName){
    updateRadioButtons(session = session, inputId = "changeSelection", label = NULL, choices = c(selectionAnalysisName, selectionFragmentName, selectionSearchName), inline = TRUE, selected = selectionAnalysisName)
    updateSelectedSelection()
  }
}
selectionByAnalysisInitPca <- function(precursorSet){
  precursorSetPca <- intersect(x = precursorSet, y = filterPca$filter)
  
  if(length(precursorSetPca) > 0){
    selectionAnalysisPcaLoadingSet <<- which(filterPca$filter %in% precursorSetPca)
    
    listForTable_Analysis_PCA <<- getTableFromPrecursorSet(dataList = dataList, precursorSet = precursorSetPca)
    table$df_Analysis_PCA <<- createMS1FeatureTable(listForTable_Analysis_PCA, selectionAnalysisPcaName)
    table_Analysis_PCA_id <<- ms1FeatureTableInputFieldIdCounter
    #output$dt_Analysis_PCA <- DT::renderDataTable(table$df_Analysis_PCA)
    if(state_selections$selectedSelection == selectionAnalysisPcaName)
      updateSelectedPrecursorSet()
  } else {
    selectionAnalysisPcaLoadingSet <<- NULL
    listForTable_Analysis_PCA <<- NULL
    table_Analysis_PCA_id <<- NULL
    table$df_Analysis_PCA <<- NULL
    #output$dt_Analysis_PCA <- DT::renderDataTable(NULL)
    if(state_selections$selectedSelection == selectionAnalysisPcaName)
      updateSelectedPrecursorSet()
  }
}
selectionByPca <- function(minimumIndex){
  selectionAnalysisPcaLoadingSet <<- minimumIndex
  precursorIndex <- filterPca$filter[[minimumIndex]]
  selectionByPca2(precursorIndex)
}
selectionByPca2 <- function(precursorSet){
  listForTable_Analysis_PCA <<- getTableFromPrecursorSet(dataList = dataList, precursorSet = precursorSet)
  table$df_Analysis_PCA <<- createMS1FeatureTable(listForTable_Analysis_PCA, selectionAnalysisPcaName)
  #output$dt_Analysis_PCA <- DT::renderDataTable(table$df_Analysis_PCA)
  if(state_selections$selectedSelection == selectionAnalysisPcaName)
    updateSelectedPrecursorSet()
  
  if(state$showHCAplotPanel)
    selectionByAnalysisInitHca(precursorSet)
  
  if(input$changeSelection != selectionAnalysisName){
    updateRadioButtons(session = session, inputId = "changeSelection", label = NULL, choices = c(selectionAnalysisName, selectionFragmentName, selectionSearchName), inline = TRUE, selected = selectionAnalysisName)
    updateSelectedSelection()
  }
}

selectionBySearchReset <- function(){
  if(!is.null(selectionSearchTreeNodeSet)){ ## HCA
    selectionSearchTreeNodeSet <<- NULL
    listForTable_Search_HCA <<- NULL
    table_Search_HCA_id <<- NULL
    table$df_Search_HCA <<- NULL
    if(!is.null(state_selections$selectedSelection))
      if(state_selections$selectedSelection == selectionSearchHcaName)
        updateSelectedPrecursorSet()
  }
  if(!is.null(selectionSearchPcaLoadingSet)){ ## HCA
    selectionSearchPcaLoadingSet <<- NULL
    listForTable_Search_PCA <<- NULL
    table_Search_PCA_id <<- NULL
    table$df_Search_PCA <<- NULL
    if(!is.null(state_selections$selectedSelection))
      if(state_selections$selectedSelection == selectionSearchHcaName)
        updateSelectedPrecursorSet()
  }
}
selectionBySearch <- function(precursorSet){
  if(state$showHCAplotPanel)
    selectionBySearchInitHca(precursorSet)
  if(state$showPCAplotPanel)
    selectionBySearchInitPca(precursorSet)
  
  if(input$changeSelection != selectionSearchName){
    updateRadioButtons(session = session, inputId = "changeSelection", label = NULL, choices = c(selectionAnalysisName, selectionFragmentName, selectionSearchName), inline = TRUE, selected = selectionSearchName)
    updateSelectedSelection()
  }
}
selectionBySearchInitHca <- function(precursorSet){
  precursorSetHca <- intersect(x = precursorSet, y = filterHca$filter)
  
  if(length(precursorSetHca) > 0){
    selectionSearchTreeNodeSet <<- getSetOfSubTreesFromRootForPrecursorSet(dataList = dataList, precursorSet = precursorSet, filter = filterHca$filter, clusterDataList = clusterDataList)
    listForTable_Search_HCA <<- getTableFromPrecursorSet(dataList = dataList, precursorSet = precursorSetHca)
    table$df_Search_HCA <<- createMS1FeatureTable(listForTable_Search_HCA, selectionSearchHcaName)
    table_Search_HCA_id <<- ms1FeatureTableInputFieldIdCounter
    #output$dt_Search_HCA <- DT::renderDataTable(table$df_Search_HCA)
    if(state_selections$selectedSelection == selectionSearchHcaName)
      updateSelectedPrecursorSet()
  } else {
    selectionSearchTreeNodeSet <<- NULL
    listForTable_Search_HCA <<- NULL
    table_Search_HCA_id <<- NULL
    table$df_Search_HCA <<- NULL
    #output$dt_Search_HCA <- DT::renderDataTable(NULL)
    if(state_selections$selectedSelection == selectionSearchHcaName)
      updateSelectedPrecursorSet()
  }
}
selectionBySearchInitPca <- function(precursorSet){
  precursorSetPca <- intersect(x = precursorSet, y = filterPca$filter)
  if(length(precursorSetPca) > 0){
    selectionSearchPcaLoadingSet <<- which(filterPca$filter %in% precursorSetPca)
    listForTable_Search_PCA <<- getTableFromPrecursorSet(dataList = dataList, precursorSet = precursorSetPca)
    table$df_Search_PCA <<- createMS1FeatureTable(listForTable_Search_PCA, selectionSearchPcaName)
    table_Search_PCA_id <<- ms1FeatureTableInputFieldIdCounter
    #output$dt_Search_PCA <- DT::renderDataTable(table$df_Search_PCA)
    if(state_selections$selectedSelection == selectionSearchPcaName)
      updateSelectedPrecursorSet()
  } else {
    selectionSearchPcaLoadingSet <<- NULL
    listForTable_Search_PCA <<- NULL
    table_Search_PCA_id <<- NULL
    table$df_Search_PCA <<- NULL
    #output$dt_Search_PCA <- DT::renderDataTable(NULL)
    if(state_selections$selectedSelection == selectionSearchPcaName)
      updateSelectedPrecursorSet()
  }
}

createMS1FeatureTable <- function(list, type){
  if(is.null(list$precursorSet))
    return(NULL)
  
  ## get (possibly truncated) data
  if(length(list$precursorSet) > maximumNumberOfTableEntries){
    precursorSet          <- list$precursorSet         [1:maximumNumberOfTableEntries]
    ms1abundanceDataFrame <- list$ms1abundanceDataFrame[1:maximumNumberOfTableEntries, , drop=FALSE]
    annotationDataFrame   <- list$annotationDataFrame  [1:maximumNumberOfTableEntries, , drop=FALSE]
    ms2fragmentDataFrame  <- list$ms2fragmentDataFrame [1:maximumNumberOfTableEntries, , drop=FALSE]
  } else {
    precursorSet          <- list$precursorSet
    ms1abundanceDataFrame <- list$ms1abundanceDataFrame
    annotationDataFrame   <- list$annotationDataFrame
    ms2fragmentDataFrame  <- list$ms2fragmentDataFrame
  }
  
  ## checkboxes
  ms1FeatureTableInputFieldIdCounter <<- ms1FeatureTableInputFieldIdCounter + 1
  isArtifact <- dataList$annoArrayIsArtifact[precursorSet]
  #iconUp   <- icon(name = "chevron-up",   lib = "font-awesome")
  #iconDown <- icon(name = "chevron-down", lib = "font-awesome")
  checkboxes <- createCheckboxInputFields(       FUN = checkboxInput, id = paste(type, artifactName,   sep = "_"), values = isArtifact, tableCounter = ms1FeatureTableInputFieldIdCounter)
  #buttonUp   <- createActionButtonInputFields(   FUN = actionButton,  id = paste(type, "MoveUp",   sep = "_"), itemCount=length(isArtifact), icon   = iconUp, tableCounter = ms1FeatureTableInputFieldIdCounter)
  #buttonDown <- createActionButtonInputFields(   FUN = actionButton,  id = paste(type, "MoveDown", sep = "_"), itemCount=length(isArtifact), icon   = iconDown, tableCounter = ms1FeatureTableInputFieldIdCounter)
  #buttonUpDown <- createActionButtonInputFields2(FUN = actionButton,  id = paste(type, "Move", sep = "_"), itemCount=length(isArtifact), iconUp = iconUp, iconDown = iconDown, tableCounter = ms1FeatureTableInputFieldIdCounter)
  dataFrameIgnore <- data.frame(check.names = F,
                                Ignore = checkboxes
                                #"Move \u2191\u2193" = buttonUpDown
                                #"Change order" = buttonUpDown
  )
  
  ## assemble
  dataFrame <<- cbind(
    ms1abundanceDataFrame,
    dataFrameIgnore,
    annotationDataFrame,
    ms2fragmentDataFrame
  )
  
  return(dataFrame)
}
setMS1FeatureTable <- function(){
  output$ms1FeatureTable <- DT::renderDataTable(
    expr = selectedTable,
    server = FALSE, escape = FALSE, selection = "none",
    options = list(
      preDrawCallback = JS('function() { Shiny.unbindAll(this.api().table().node()); }'),
      drawCallback    = JS('function() { Shiny.bindAll(  this.api().table().node()); }')
    )
  )
}

updateMS1FeatureTableGui <- function(precursorSet){
  print("updateMS1FeatureTableGui")
  ## table update with new annotations
  if(all(length(precursorSet) > 0, !is.null(selectionFragmentTreeNodeSet), precursorSet %in% listForTable_Fragment_HCA$precursorSet)){ ## HCA
    table$df_Fragment_HCA <<- createMS1FeatureTable(listForTable_Fragment_HCA, selectionFragmentHcaName)
    #output$dt_Fragment_HCA <- DT::renderDataTable(table$df_Fragment_HCA)
    table_Fragment_HCA_id <<- ms1FeatureTableInputFieldIdCounter
  }
  if(all(length(precursorSet) > 0, !is.null(selectionFragmentPcaLoadingSet), precursorSet %in% listForTable_Fragment_PCA$precursorSet)){ ## PCA
    table$df_Fragment_PCA <<- createMS1FeatureTable(listForTable_Fragment_PCA, selectionFragmentPcaName)
    #output$dt_Fragment_PCA <- DT::renderDataTable(table$df_Fragment_PCA)
    table_Fragment_PCA_id <<- ms1FeatureTableInputFieldIdCounter
  }
  
  if(all(length(precursorSet) > 0, !is.null(selectionAnalysisTreeNodeSet), precursorSet %in% listForTable_Analysis_HCA$precursorSet)){ ## HCA
    table$df_Analysis_HCA <<- createMS1FeatureTable(listForTable_Analysis_HCA, selectionAnalysisHcaName)
    #output$dt_Analysis_HCA <- DT::renderDataTable(table$df_Analysis_HCA)
    table_Analysis_HCA_id <<- ms1FeatureTableInputFieldIdCounter
  }
  if(all(length(precursorSet) > 0, !is.null(selectionAnalysisPcaLoadingSet), precursorSet %in% listForTable_Analysis_PCA$precursorSet)){ ## PCA
    table$df_Analysis_PCA <<- createMS1FeatureTable(listForTable_Analysis_PCA, selectionAnalysisPcaName)
    #output$dt_Analysis_PCA <- DT::renderDataTable(table$df_Analysis_PCA)
    table_Analysis_PCA_id <<- ms1FeatureTableInputFieldIdCounter
  }
  
  if(all(length(precursorSet) > 0, !is.null(selectionSearchTreeNodeSet), precursorSet %in% listForTable_Search_HCA$precursorSet)){ ## HCA
    table$df_Search_HCA <<- createMS1FeatureTable(listForTable_Search_HCA, selectionSearchHcaName)
    #output$dt_Search_HCA <- DT::renderDataTable(table$df_Search_HCA)
    table_Search_HCA_id <<- ms1FeatureTableInputFieldIdCounter
  }
  if(all(length(precursorSet) > 0, !is.null(selectionSearchPcaLoadingSet), precursorSet %in% listForTable_Search_PCA$precursorSet)){ ## PCA
    table$df_Search_PCA <<- createMS1FeatureTable(listForTable_Search_PCA, selectionSearchPcaName)
    #output$dt_Search_PCA <- DT::renderDataTable(table$df_Search_PCA)
    table_Search_PCA_id <<- ms1FeatureTableInputFieldIdCounter
  }
  ## update
  if(!is.null(state_selections$selectedSelection))
    updateTableAssignment()
}
updateTableAssignment <- function(){
  print(paste("updateTableAssignment '", state_selections$selectedSelection, "'", sep = ""))
  switch(state_selections$selectedSelection, 
         "Analysis_HCA"={ 
           #selectionAnalysisHcaName={ 
           selectedTable_id <<- table_Analysis_HCA_id
           selectedTable <<- table$df_Analysis_HCA
         },"Analysis_PCA"={  
           #},selectionAnalysisPcaName={  
           selectedTable_id <<- table_Analysis_PCA_id
           selectedTable <<- table$df_Analysis_PCA
         },"Fragment_HCA"={  
           #},selectionFragmentHcaName={  
           selectedTable_id <<- table_Fragment_HCA_id
           selectedTable <<- table$df_Fragment_HCA
           state_selections$precursorSetSelected <<- !is.null(listForTable_Fragment_HCA)
         },"Fragment_PCA"={  
           #},selectionFragmentPcaName={  
           selectedTable_id <<- table_Fragment_PCA_id
           selectedTable <<- table$df_Fragment_PCA
         },"Search_HCA"  ={  
           #},selectionSearchHcaName  ={  
           selectedTable_id <<- table_Search_HCA_id
           selectedTable <<- table$df_Search_HCA
         },"Search_PCA"  ={  
           #},selectionSearchPcaName  ={  
           selectedTable_id <<- table_Search_PCA_id
           selectedTable <<- table$df_Search_PCA
         },{
           print(paste("### unknown state_selections$selectedSelection: '", state_selections$selectedSelection, "'", sep = ""))
         }
  )
  setMS1FeatureTable()
}
updateSelectedSelection <- function(){
  selection <- input$changeSelection
  
  if(state$analysisType == "Annotation")
    return()
  
  if(selection == selectionAnalysisName & state$analysisType == "HCA")
    selectedSelection <- selectionAnalysisHcaName
  if(selection == selectionAnalysisName & state$analysisType == "PCA")
    selectedSelection <- selectionAnalysisPcaName
  if(selection == selectionFragmentName & state$analysisType == "HCA")
    selectedSelection <- selectionFragmentHcaName
  if(selection == selectionFragmentName & state$analysisType == "PCA")
    selectedSelection <- selectionFragmentPcaName
  if(selection == selectionSearchName & state$analysisType == "HCA")
    selectedSelection <- selectionSearchHcaName
  if(selection == selectionSearchName & state$analysisType == "PCA")
    selectedSelection <- selectionSearchPcaName
  
  state_selections$selectedSelection <<- selectedSelection
  updateSelectedPrecursorSet()
}
updateSelectedPrecursorSet <- function(){
  print(paste("updateSelectionAssignment '", state_selections$selectedSelection, "'", sep = ""))
  switch(state_selections$selectedSelection, 
         "Analysis_HCA"={ 
           state_selections$precursorSetSelected <<- !is.null(listForTable_Analysis_HCA)
           if(!is.null(listForTable_Analysis_HCA)) selectedPrecursorSet <<- listForTable_Analysis_HCA$precursorSet
           else                                    selectedPrecursorSet <<- NULL
         },"Analysis_PCA"={  
           state_selections$precursorSetSelected <<- !is.null(listForTable_Analysis_PCA)
           if(!is.null(listForTable_Analysis_PCA)) selectedPrecursorSet <<- listForTable_Analysis_PCA$precursorSet
           else                                    selectedPrecursorSet <<- NULL
         },"Fragment_HCA"={  
           state_selections$precursorSetSelected <<- !is.null(listForTable_Fragment_HCA)
           if(!is.null(listForTable_Fragment_HCA)) selectedPrecursorSet <<- listForTable_Fragment_HCA$precursorSet
           else                                    selectedPrecursorSet <<- NULL
         },"Fragment_PCA"={  
           state_selections$precursorSetSelected <<- !is.null(listForTable_Fragment_PCA)
           if(!is.null(listForTable_Fragment_PCA)) selectedPrecursorSet <<- listForTable_Fragment_PCA$precursorSet
           else                                    selectedPrecursorSet <<- NULL
         },"Search_HCA"  ={  
           state_selections$precursorSetSelected <<- !is.null(listForTable_Search_HCA)
           if(!is.null(listForTable_Search_HCA)) selectedPrecursorSet <<- listForTable_Search_HCA$precursorSet
           else                                    selectedPrecursorSet <<- NULL
         },"Search_PCA"  ={  
           state_selections$precursorSetSelected <<- !is.null(listForTable_Search_PCA)
           if(!is.null(listForTable_Search_PCA)) selectedPrecursorSet <<- listForTable_Search_PCA$precursorSet
           else                                    selectedPrecursorSet <<- NULL
         },{
           print(paste("### unknown state_selections$selectedSelection: '", state_selections$selectedSelection, "'", sep = ""))
         }
  )
  precursorSelectionChanged()
}
precursorSelectionChanged <- function(){
  selectionPresent <- !is.null(selectedPrecursorSet)
  
  ####################
  ## anno, table
  updateAnnoGui(selectedPrecursorSet)
  updateMS1FeatureTableGui(selectedPrecursorSet)
  
  ####################
  ## MetFrag link
  if(length(selectedPrecursorSet) == 1){
    metFragLinkList <- getMetFragLink(dataList, selectedPrecursorSet)
    
    if(is.null(metFragLinkList$error)){
      output$metFragLink <- renderText({
        print(paste("update output$metFragLink II", metFragLinkList$landingPageUrl))
        paste("<a href=", gsub(pattern = " ", replacement = "%20", x = metFragLinkList$landingPageUrl)[[1]], " target=\"_blank\">Send to MetFrag!</a>", sep = "")
      })
    } else {
      output$metFragLink <- renderText({
        print(paste("update output$metFragLink II", metFragLinkList$error))
        paste(metFragLinkList$error, sep = "")
      })
    }
  }
  
  ####################
  ## fragment spectrum
  switch(as.character(length(selectedPrecursorSet)), 
         "0"={
           selectedSpectrumHere <- ""
         },
         "1"={
           precursorIndex <- selectedPrecursorSet
           features <- dataList$featureIndeces[[precursorIndex]]
           fragmentsX <- dataList$fragmentMasses[features]
           fragmentsY <- as.numeric(dataList$featureMatrix[precursorIndex, features])
           fragmentsY[fragmentsY > 1] <- 1
           selectedSpectrumHere <- paste(fragmentsX, fragmentsY, sep = "\t", collapse = "\n")
         },
         {
           ## set of spectra
           featureMatrixHere <- dataList$featureMatrix[selectedPrecursorSet, ]
           fragmentFrequency <- apply(X = featureMatrixHere, MARGIN = 2, FUN = function(column){sum(column>0)}) / length(selectedPrecursorSet)
           fragmentIntensities <- apply(X = featureMatrixHere, MARGIN = 2, FUN = function(column){mean(column[column>0])})
           fragmentsToFilter <- fragmentFrequency < minimumProportionToShowFragment
           rm(fragmentFrequency)
           fragmentIntensities <- fragmentIntensities[!fragmentsToFilter]
           fragmentMasses <- dataList$fragmentMasses[!fragmentsToFilter]
           selectedSpectrumHere <- paste(fragmentMasses, fragmentIntensities, sep = "\t", collapse = "\n")
         }
  )
  updateTextInput    (session = session, inputId = "selectedSpectrum",    value = selectedSpectrumHere)
  
  ####################
  ## selection info
  selection <- state_selections$selectedSelection
  selectionInfo <- ""
  if(selectionPresent){
    switch(as.character(length(selectedPrecursorSet)), 
           "0"={ selectionInfo <- paste("The set of selected MS\u00B9 features is empty", sep = "")         },
           "1"={ selectionInfo <- paste(length(selectedPrecursorSet), " MS\u00B9 feature selected", sep = "")  },
           {     selectionInfo <- paste(length(selectedPrecursorSet), " MS\u00B9 features selected", sep = "") }
    )
  } else {
    if(selection == selectionAnalysisHcaName)
      selectionInfo <- paste("Please select a cluster or MS\u00B9 feature in the HCA plot", sep = "")
    if(selection == selectionAnalysisPcaName)
      selectionInfo <- paste("Please select a loading in the PCA plot", sep = "")
    if(selection == selectionFragmentHcaName | selection == selectionFragmentPcaName)
      selectionInfo <- paste("Please select a fragment in the Fragment plot above", sep = "")
    if(selection == selectionSearchHcaName | selection == selectionSearchPcaName)
      selectionInfo <- paste("Please select a set of MS\u00B9 features in the 'Search' tab of the sidebar panel", sep = "")
  }
  
  output$selectionInfo <- renderText({
    print(paste("update output$selectionInfo '", selectionInfo, "'", sep = ""))
    selectionInfo
  })
}
updatePlotsWithAnnotations <- function(){
  ## plots
  if(state$showHCAplotPanel){
    drawDendrogramPlot(consoleInfo = "updatePlotsWithAnnotations")
    #drawAnnotationLegendHCA(consoleInfo = "updatePlotsWithAnnotations")
  }
  if(state$showPCAplotPanel){
    drawPcaLoadingsPlot(consoleInfo = "updatePlotsWithAnnotations")
    #drawAnnotationLegendPCA(consoleInfo = "updatePlotsWithAnnotations")
  }
}

obsChangeSelection <- observeEvent(input$changeSelection, {
  selection <- input$changeSelection
  print(paste("Observe changeSelection", selection, "for", state$analysisType, ""))
  
  changeSelectionCurrentSelection <<- selection
  
  updateSelectedSelection()
})
obsPrecursorSelectionTabs <- observeEvent(input$precursorSelectionTabs, {
  selectedTab <- input$precursorSelectionTabs
  print(paste("Observe selectedTab", selectedTab))
  
  precursorSelectionTabCurrentTab <<- selectedTab
})
obsClearSelection <- observeEvent(input$clearSelection, {
  clearSelection  <- as.numeric(input$clearSelection)
  selection       <- input$changeSelection
  
  print(paste("Observe clearSelection", clearSelection))
  
  #################################################
  ## check if button was hit
  #if(clearSelection == clearSelectionButtonValue)
  #  return()
  #clearSelectionButtonValue <<- clearSelection
  
  switch(selection, 
         "Selection by HCA/PCA"={
           #selectionAnalysisName={
           selectionByAnalysisReset()
         },"Selection by fragment"={
           #},selectionFragmentName={
           selectionByFragmentReset()
         },"Selection by search"={
           #},selectionSearchName={
           selectionBySearchReset()
         },{
           print(paste("### unknown selection '", selection, "'", sep = ""))
         }
  )
  
  #################################################
  ## update plots
  if(state$showHCAplotPanel)  drawDendrogramPlot( consoleInfo = "clear selection", withHeatmap = TRUE)
  if(state$showPCAplotPanel)  drawPcaPlots(       consoleInfo = "clear selection")
})

output$precursorSetSelected <- reactive({
  print(paste("reactive update precursorSetSelected", state_selections$precursorSetSelected))
  return(state_selections$precursorSetSelected)
})
output$selectedSelection <- reactive({
  print(paste("reactive update selectedSelection", state_selections$selectedSelection))
  return(state_selections$selectedSelection)
})

outputOptions(output, 'precursorSetSelected',    suspendWhenHidden=FALSE)
outputOptions(output, 'selectedSelection',       suspendWhenHidden=FALSE)

suspendOnExitFunctions <- c(suspendOnExitFunctions, function(){
  print("Suspending selections observers")
  obsChangeSelection$suspend()
  obsPrecursorSelectionTabs$suspend()
  obsClearSelection$suspend()
})

================
File: inst/MetFamily/app_files/server_functionsSerialization.R
================
#https://stat.ethz.ch/R-manual/R-devel/library/utils/html/zip.html
serialization <- function(){
  #######################################
  ## enlist
  paramsList <- list(
    ## global MS2 filter
    globalFilter_ms2_masses1          = input$globalFilter_ms2_masses1,
    globalFilter_ms2_masses2          = input$globalFilter_ms2_masses2,
    globalFilter_ms2_masses3          = input$globalFilter_ms2_masses3,
    globalFilter_ms2_ppm              = input$globalFilter_ms2_ppm,
    #input$applyGlobalMS2filters
    ## HCA
    hcaFilterGroupOne                 = input$hcaFilterGroupOne,
    hcaFilterGroupTwo                 = input$hcaFilterGroupTwo,
    hcaFilter_average                 = input$hcaFilter_average,
    hcaFilter_lfc                     = input$hcaFilter_lfc,
    hcaFilterIncludeIgnoredPrecursors = input$hcaFilterIncludeIgnoredPrecursors,
    #input$applyHcaFilters
    hcaDistanceFunction               = input$hcaDistanceFunction,
    #hcaClusterMethod                  = input$hcaClusterMethod,
    hcaClusterMethod                  = "ward.D",
    #input$drawHCAplots
    ## PCA
    pcaGroups                         = input$pcaGroups,
    pcaSamples                        = input$pcaSamples,
    pcaFilter_average                 = input$pcaFilter_average,
    pcaFilter_lfc                     = input$pcaFilter_lfc,
    pcaFilterIncludeIgnoredPrecursors = input$pcaFilterIncludeIgnoredPrecursors,
    #input$applyPcaFilters
    pcaScaling                        = input$pcaScaling,
    pcaLogTransform                   = input$pcaLogTransform,
    pcaDimensionOne                   = input$pcaDimensionOne,
    pcaDimensionTwo                   = input$pcaDimensionTwo,
    #input$drawPCAplots
    ## plot properties
    showPlotControls                  = input$showPlotControls,
    showClusterLabels                 = input$showClusterLabels,
    heatmapContent                    = input$heatmapContent,
    heatmapOrdering                   = input$heatmapOrdering,
    hcaPrecursorLabels                = input$hcaPrecursorLabels,
    showScoresLabels                  = input$showScoresLabels,
    loadingsLabels                    = input$loadingsLabels,
    showLoadingsFeatures              = input$showLoadingsFeatures,
    #showLoadingsFeaturesAnnotated     = input$showLoadingsFeaturesAnnotated,
    #showLoadingsFeaturesUnannotated   = input$showLoadingsFeaturesUnannotated,
    #showLoadingsFeaturesSelected      = input$showLoadingsFeaturesSelected,
    #showLoadingsFeaturesUnselected    = input$showLoadingsFeaturesUnselected,
    showLoadingsAbundance             = input$showLoadingsAbundance,
    #showLoadingsLabels                = "Show labels"    %in% input$pcaLoadingsProperties,
    #showLoadingsAbundance             = "Show abundance" %in% input$pcaLoadingsProperties,
    ## search
    searchMS1orMS2                    = input$searchMS1orMS2,
    searchMS1mass                     = input$searchMS1mass,
    searchMS1massPpm                  = input$searchMS1massPpm,
    search_ms2_masses1                = input$search_ms2_masses1,
    search_ms2_masses2                = input$search_ms2_masses2,
    search_ms2_masses3                = input$search_ms2_masses3,
    searchMS2massPpm                  = input$searchMS2massPpm,
    searchIncludeIgnoredPrecursors    = input$searchIncludeIgnoredPrecursors
  )
  
  #######################################
  ## serialize parameter list
  
  ## built matrix with param names and param values
  tempMatrix    <- matrix(data = c(names(unlist(paramsList)),paste("'", unlist(paramsList), "'", sep = "")), ncol = 2)
  ## quotation of strings
  #textEntries <- is.na(as.numeric(tempMatrix[, 2]))
  #tempMatrix[textEntries, 2] <- paste("'", tempMatrix[textEntries, 2], "'", sep = "")
  ## param name = param value
  paramStrings  <- apply(tempMatrix, MARGIN = 1, FUN = function(x) {paste(x, collapse = "=")})
  ## collapse
  serialization <- paste(paramStrings, collapse = ";")
  return(serialization)
}
## https://github.com/daattali/advanced-shiny/blob/master/update-input/app.R
deserialization <- function(serialization){
  #######################################
  ## deserialize parameters
  
  #paramStrings <- strsplit(x = strsplit(x = serialization, split = ";")[[1]], split = "=")
  #for(i in 1:length(paramStrings))
  #  paramStrings[[i]] <- paste(paramStrings[[i]][[1]], paste("'", paramStrings[[i]][[2]], "'", sep = ""), sep = "=")
  #paramString <- paste(paramStrings, collapse = ",")
  paramString <- paste(strsplit(x = serialization, split = ";")[[1]], collapse = ",")
  parseText <- paste("paramsList <- list(", paramString, ")", sep = "")
  
  #parseText <- paste("paramsList <- list(", paste(paramStrings, collapse = ","), ")", sep = "")
  eval(parse(text = parseText))
  
  #######################################
  ## update parameter fields
  
  #updateTextInput(session = session, inputId = "globalFilter_ms2_masses1", value = "")
  #updateRadioButtons(session = session, inputId = "hcaFilterGroupOne", choices = dataList$grouXXXps, selected = selectedOne)
  #updateCheckboxInput(session = session, inputId = "hcaFilterIncludeIgnoredPrecursors", value = FALSE)
  #updateSelectInput(session = session, inputId = "presentAnnotationValue", choices = c("[init]"), selected = lalala)
  #updateCheckboxGroupInput(session = session, inputId = "pcaGroups",   choices = dataList$grouXXXps, selected = dataList$grouXXXps)
  
  ## global MS2 filter
  updateTextInput(         session = session, inputId = "globalFilter_ms2_masses1",          value = paramsList$globalFilter_ms2_masses1)
  updateTextInput(         session = session, inputId = "globalFilter_ms2_masses2",          value = paramsList$globalFilter_ms2_masses2)
  updateTextInput(         session = session, inputId = "globalFilter_ms2_masses3",          value = paramsList$globalFilter_ms2_masses3)
  updateTextInput(         session = session, inputId = "globalFilter_ms2_ppm",              value = paramsList$globalFilter_ms2_ppm)
  #input$applyGlobalMS2filters
  ## HCA
  updateRadioButtons(      session = session, inputId = "hcaFilterGroupOne",                 selected = paramsList$hcaFilterGroupOne)
  updateRadioButtons(      session = session, inputId = "hcaFilterGroupTwo",                 selected = paramsList$hcaFilterGroupTwo)
  updateTextInput(         session = session, inputId = "hcaFilter_average",                 value = paramsList$hcaFilter_average)
  updateTextInput(         session = session, inputId = "hcaFilter_lfc",                     value = paramsList$hcaFilter_lfc)
  updateCheckboxInput(     session = session, inputId = "hcaFilterIncludeIgnoredPrecursors", value = as.logical(paramsList$hcaFilterIncludeIgnoredPrecursors))
  #input$applyHcaFilters
  updateSelectInput(       session = session, inputId = "hcaDistanceFunction",               selected = paramsList$hcaDistanceFunction)
  #updateSelectInput(       session = session, inputId = "hcaClusterMethod",                  selected = paramsList$hcaClusterMethod)
  #input$drawHCAplots
  ## PCA
  updateCheckboxGroupInput(session = session, inputId = "pcaGroups",                         selected = paramsList$pcaGroups)
  updateCheckboxGroupInput(session = session, inputId = "pcaSamples",                        selected = paramsList$pcaSamples)
  updateTextInput(         session = session, inputId = "pcaFilter_average",                 value = paramsList$pcaFilter_average)
  updateTextInput(         session = session, inputId = "pcaFilter_lfc",                     value = paramsList$pcaFilter_lfc)
  updateSelectInput(       session = session, inputId = "pcaFilterIncludeIgnoredPrecursors", selected = paramsList$pcaFilterIncludeIgnoredPrecursors)
  #input$applyPcaFilters
  updateSelectInput(       session = session, inputId = "pcaScaling",                        selected = paramsList$pcaScaling)
  updateCheckboxInput(     session = session, inputId = "pcaLogTransform",                   value = as.logical(paramsList$pcaLogTransform))
  updateSelectInput(       session = session, inputId = "pcaDimensionOne",                   selected = paramsList$pcaDimensionOne)
  updateSelectInput(       session = session, inputId = "pcaDimensionTwo",                   selected = paramsList$pcaDimensionTwo)
  #input$drawPCAplots
  ## plot properties
  updateCheckboxInput(     session = session, inputId = "showPlotControls",                  value = as.logical(paramsList$showPlotControls))
  updateCheckboxInput(     session = session, inputId = "showClusterLabels",                 value = as.logical(paramsList$showClusterLabels))
  updateRadioButtons(      session = session, inputId = "heatmapContent",                    selected = paramsList$heatmapContent)
  updateRadioButtons(      session = session, inputId = "heatmapOrdering",                   selected = paramsList$heatmapOrdering)
  updateRadioButtons(      session = session, inputId = "hcaPrecursorLabels",                selected = paramsList$hcaPrecursorLabels)
  updateCheckboxInput(     session = session, inputId = "showScoresLabels",                  value = as.logical(paramsList$showScoresLabels))
  #updateCheckboxGroupInput(session = session, inputId = "pcaLoadingsProperties",             selected = c(ifelse(as.logical(paramsList$showLoadingsLabels), "Show labels", NULL), ifelse(as.logical(paramsList$showLoadingsAbundance), "Show abundance", NULL)))
  updateRadioButtons(      session = session, inputId = "loadingsLabels",                    selected = paramsList$loadingsLabels)
  updateCheckboxGroupInput(session = session, inputId = "showLoadingsFeatures",              selected = paramsList$showLoadingsFeatures)
  #updateCheckboxInput(     session = session, inputId = "showLoadingsFeaturesAnnotated",     value = as.logical(paramsList$showLoadingsFeaturesAnnotated))
  #updateCheckboxInput(     session = session, inputId = "showLoadingsFeaturesUnannotated",   value = as.logical(paramsList$showLoadingsFeaturesUnannotated))
  #updateCheckboxInput(     session = session, inputId = "showLoadingsFeaturesSelected",      value = as.logical(paramsList$showLoadingsFeaturesSelected))
  #updateCheckboxInput(     session = session, inputId = "showLoadingsFeaturesUnselected",    value = as.logical(paramsList$showLoadingsFeaturesUnselected))
  updateCheckboxInput(     session = session, inputId = "showLoadingsAbundance",             value = as.logical(paramsList$showLoadingsAbundance))
  ## search
  updateRadioButtons(      session = session, inputId = "searchMS1orMS2",                    selected = paramsList$searchMS1orMS2)
  updateTextInput(         session = session, inputId = "searchMS1mass",                     value = paramsList$searchMS1mass)
  updateTextInput(         session = session, inputId = "searchMS1massPpm",                  value = paramsList$searchMS1massPpm)
  updateTextInput(         session = session, inputId = "search_ms2_masses1",                value = paramsList$search_ms2_masses1)
  updateTextInput(         session = session, inputId = "search_ms2_masses2",                value = paramsList$search_ms2_masses2)
  updateTextInput(         session = session, inputId = "search_ms2_masses3",                value = paramsList$search_ms2_masses3)
  updateTextInput(         session = session, inputId = "searchMS2massPpm",                  value = paramsList$searchMS2massPpm)
  updateCheckboxInput(     session = session, inputId = "searchIncludeIgnoredPrecursors",    value = as.logical(paramsList$searchIncludeIgnoredPrecursors))
  #input$applySearch
  
  #######################################
  ## update GUI according to parameters
  
  ###################
  ## global MS2 filter
  filter_ms2_masses1  <- paramsList$globalFilter_ms2_masses1
  filter_ms2_masses2  <- paramsList$globalFilter_ms2_masses2
  filter_ms2_masses3  <- paramsList$globalFilter_ms2_masses3
  filter_ms2_ppm      <- paramsList$globalFilter_ms2_ppm
  
  groupSet        <- dataList$grouXXXps
  sampleSet       <- dataList$groupSampleDataFrame[, "Sample"][!dataList$groupSampleDataFrame[, "Exclude"]]
  filterBySamples <- TRUE
  filter_average  <- NULL
  filter_lfc      <- NULL
  includeIgnoredPrecursors  <- TRUE
  filter_ms1_masses <- NULL
  filter_ms1_ppm <- NULL
  
  resultObj <- doPerformFiltering(
    groupSet, sampleSet, filterBySamples, filter_average, filter_lfc, 
    filter_ms2_masses1, filter_ms2_masses2, filter_ms2_masses3, filter_ms2_ppm, 
    filter_ms1_masses, filter_ms1_ppm, 
    includeIgnoredPrecursors
  )
  filterGlobal <<- resultObj$filter
  state_filters$globalMS2filterValid <<- TRUE
  updateGlobalMS2filterInformation()
  
  ###################
  ## HCA filter
  filter_ms2_masses1  <- filterGlobal$filter_ms2_masses1Original   
  filter_ms2_masses2  <- filterGlobal$filter_ms2_masses2Original   
  filter_ms2_masses3  <- filterGlobal$filter_ms2_masses3Original   
  filter_ms2_ppm      <- filterGlobal$filter_ms2_ppmOriginal
  
  groupOne        <- paramsList$hcaFilterGroupOne
  groupTwo        <- paramsList$hcaFilterGroupTwo
  filter_average  <- paramsList$hcaFilter_average
  filter_lfc      <- paramsList$hcaFilter_lfc
  includeIgnoredPrecursors  <- paramsList$hcaFilterIncludeIgnoredPrecursors
  filter_ms1_masses <- NULL
  filter_ms1_ppm  <- NULL
  groupSet        <- c(groupOne, groupTwo)
  sampleSet       <- dataList$groupSampleDataFrame[, "Sample"][!dataList$groupSampleDataFrame[, "Exclude"]]
  filterBySamples <- TRUE
  resultObj <- doPerformFiltering(
    groupSet, sampleSet, filterBySamples, filter_average, filter_lfc, 
    filter_ms2_masses1, filter_ms2_masses2, filter_ms2_masses3, filter_ms2_ppm, 
    filter_ms1_masses, filter_ms1_ppm, includeIgnoredPrecursors
  )
  filterHca <<- resultObj$filter
  updateHcaFilterInformation()
  
  numberOfPrecursorsFiltered <- filterHca$numberOfPrecursorsFiltered
  checkHcaFilterValidity(numberOfPrecursorsFiltered)
  
  ###################
  ## draw HCA
  # TODO?
  
  ###################
  ## PCA filter
  filter_ms2_masses1  <- filterGlobal$filter_ms2_masses1Original   
  filter_ms2_masses2  <- filterGlobal$filter_ms2_masses2Original   
  filter_ms2_masses3  <- filterGlobal$filter_ms2_masses3Original   
  filter_ms2_ppm      <- filterGlobal$filter_ms2_ppmOriginal
  
  groupSet        <- paramsList$pcaGroups
  sampleSet       <- paramsList$pcaSamples
  filterBySamples <- paramsList$filterByPCAgroupSamples
  filter_average  <- paramsList$pcaFilter_average
  filter_lfc      <- paramsList$pcaFilter_lfc
  includeIgnoredPrecursors  <- paramsList$pcaFilterIncludeIgnoredPrecursors
  filter_ms1_masses <- NULL
  filter_ms1_ppm  <- NULL
  
  if(length(groupSet) != 2)
    filter_lfc <- NULL
  
  resultObj <- doPerformFiltering(
    groupSet, sampleSet, filterBySamples, filter_average, filter_lfc, 
    filter_ms2_masses1, filter_ms2_masses2, filter_ms2_masses3, filter_ms2_ppm, 
    filter_ms1_masses, filter_ms1_ppm, includeIgnoredPrecursors
  )
  filterPca <<- resultObj$filter
  updatePcaFilterInformation()
  
  numberOfPrecursorsFiltered <- filterPca$numberOfPrecursorsFiltered
  checkPcaFilterValidity(numberOfPrecursorsFiltered)
  
  ###################
  ## draw PCA
  # TODO
  
  ###################
  ## search
  searchMode <- paramsListsearchMS1orMS2
  if(searchMode == 'MS1 feature m/z'){
    #################################################
    ## get inputs
    filter_ms1_masses <- paramsListsearchMS1mass
    filter_ms1_ppm  <- paramsListsearchMS1massPpm
    
    if(nchar(trimws(filter_ms1_masses)) == 0)
      return()
    
    filter_ms2_masses1  <- NULL
    filter_ms2_masses2  <- NULL
    filter_ms2_masses3  <- NULL
    filter_ms2_ppm      <- NULL
  }
  if(searchMode == 'Fragment m/z'){
    #################################################
    ## get inputs
    filter_ms2_masses1 <- paramsListsearch_ms2_masses1
    filter_ms2_masses2 <- paramsListsearch_ms2_masses2
    filter_ms2_masses3 <- paramsListsearch_ms2_masses3
    filter_ms2_ppm     <- paramsListsearchMS2massPpm
    
    filter_ms1_masses <- NULL
    filter_ms1_ppm <- NULL
  }
  
  filter_lfc      <- NULL
  filter_average  <- NULL
  groupSet        <- dataList$grouXXXps
  sampleSet       <- dataList$includedSamples(dataList$groupSampleDataFrame)
  #sampleSet       <- dataList$dataColumnsNameFunctionFromGroupNames(grouXXXps = groupSet, sampleNamesToExclude = dataList$excludedSamples(dataList$groupSampleDataFrame))
  filterBySamples <- TRUE
  includeIgnoredPrecursors  <- paramsListsearchIncludeIgnoredPrecursors
  
  #################################################
  ## do filtering
  resultObj <- doPerformFiltering(
    groupSet, sampleSet, filterBySamples, filter_average, filter_lfc, 
    filter_ms2_masses1, filter_ms2_masses2, filter_ms2_masses3, filter_ms2_ppm, 
    filter_ms1_masses, filter_ms1_ppm, includeIgnoredPrecursors
  )
  processSearchFilterResult(resultObj)
}

================
File: inst/MetFamily/app_files/server_functionsTableGui.R
================
## create and set table for all six types
createCheckboxInputFields <- function(FUN, id, values, tableCounter) {
  ## running id
  id <- paste(id, tableCounter, sep = "_")
  
  ## create a character vector of shiny inputs
  inputs <- character(length(values))
  for (i in 1:length(values)){
    itemId    <- paste(id, "_", i, sep = "")
    inputs[[i]] <- as.character(FUN(inputId = itemId, label = NULL, value = values[[i]]))
  }
  return(inputs)
}
createCheckboxInputFields2 <- function(FUN, id, values, tableCounter, triggerSampleExclusionClick) {
  ## running id
  id <- paste(id, tableCounter, sep = "_")
  
  ## create a character vector of shiny inputs
  inputs <- character(length(values))
  for (i in 1:length(values)){
    itemId    <- paste(id, "_", i, sep = "")
    inputs[[i]] <- as.character(FUN(inputId = itemId, label = NULL, value = values[[i]]))
    
    ## trigger event on button-click
    if(triggerSampleExclusionClick)
      lapply(c(itemId), function(i){
        observeEvent(input[[i]], {
          sampleExcludeClicked()
        })
      })
  }
  return(inputs)
}
createActionButtonInputFields <- function(FUN, id, itemCount, label = NULL, icon = NULL, tableCounter, callFunction) {
  ## running id
  id <- paste(id, tableCounter, sep = "_")
  
  ## create a character vector of shiny inputs
  inputs <- character(length = itemCount)
  for (i in seq_along(inputs)){
    itemId    <- paste(id, "_", i, sep = "")
    inputs[[i]] <- as.character(FUN(inputId = itemId, label = label, icon = icon))
    
    ## trigger event on button-click
    #lapply(itemId, function(itemId){
    #  observeEvent(input[[itemId]], {
    #    print("huhu")
    #    callFunction(itemId)
    #  })
    #})
    
    #observeEvent(input[[itemId]], {
    #  print("huhu")
    #  print(itemId)
    #  callFunction(itemId)
    #})
  }
  
  itemIds <- paste(id, "_", seq_along(inputs), sep = "")
  lapply(itemIds, function(itemId){
    observeEvent(input[[itemId]], {
      print("hoho")
      callFunction(itemId)
    })
  })
  
  return(inputs)
}
createActionButtonInputFields2 <- function(FUN, id, itemCount, iconUp, iconDown, tableCounter) {
  ## running id
  id1 <- paste(id, "Up",   tableCounter, sep = "_")
  id2 <- paste(id, "Down", tableCounter, sep = "_")
  
  ## create a character vector of shiny inputs
  inputs <- character(length = itemCount)
  for (i in seq_along(inputs)){
    itemId1    <- paste(id1, "_", i, sep = "")
    itemId2    <- paste(id2, "_", i, sep = "")
    
    inputs[[i]] <- as.character(
      fluidRow(
        column(width = 6,
               div(style="float:right",
                   bsTooltip(id = itemId1, title = "Move sample up", placement = "bottom", trigger = "hover"),
                   FUN(inputId = itemId1, label = NULL, icon = iconUp)
               )
        ),##column
        column(width = 6,
               div(style="float:left",
                   bsTooltip(id = itemId2, title = "Move sample down", placement = "bottom", trigger = "hover"),
                   FUN(inputId = itemId2, label = NULL, icon = iconDown)
               )
        )##column
      )##row
    )
    
    ## trigger event on button-click
    lapply(c(itemId1, itemId2), function(i){
      observeEvent(input[[i]], {
        sampleMoveClicked(i)
      })
    })
  }
  return(inputs)
}

## for classifier
createPlotOutput <- function(dataList, id, frequentFragments, characteristicFragments, precursorIndeces, tableCounter, mappingSpectraToClassDf) {
  
  if(FALSE){
    dataList_ <<- dataList
    id_ <<- id
    frequentFragments_ <<- frequentFragments
    characteristicFragments_ <<- characteristicFragments
    precursorIndeces_ <<- precursorIndeces
    tableCounter_ <<- tableCounter
  }
  if(FALSE){
    dataList <<- dataList_
    id <<- id_
    frequentFragments <<- frequentFragments_
    characteristicFragments <<- characteristicFragments_
    precursorIndeces <<- precursorIndeces_
    tableCounter <<- tableCounter_
  }
  
  ## running id
  id <- paste(id, tableCounter, sep = "_")
  
  xInterval <- c(dataList$minimumMass, dataList$maximumMass)
  
  ## class statistics for class plot
  returnObj <- preprocessClassPlot(frequentFragments, characteristicFragments)
  masses_class    <- returnObj$masses_class
  frequency_class <- returnObj$frequency_class
  colors_class    <- returnObj$colors_class
  
  ## create a character vector of shiny inputs
  inputs_i <- character(length(precursorIndeces))
  numberOfMatchingMasses_i <- integer(length(precursorIndeces))
  for (i in seq_along(precursorIndeces)){
    itemId    <- paste(id, "_", i, sep = "")
    assign(x = eval(itemId), value = itemId)
    
    precursorIndex <- precursorIndeces[[i]]
    
    ## match spectrum masses for spectrum plot
    returnObj <- preprocessSpectrumVsClassPlot(dataList, precursorIndex, masses_class, mappingSpectraToClassDf, "Intensity")
    masses_spec <- returnObj$masses_spec
    intensity_spec <- returnObj$intensity_spec
    colors_spec <- returnObj$colors_spec
    numberOfMatchingMasses_i[[i]] <- returnObj$numberOfMatchingMasses
    
    plotAsString <- paste(
      "output$", itemId, " <- renderPlot({",
      #"  print(paste('### SvC ###', ", i, "));",
      #"  plot_ly(x=1:10,y=1:10);",
      #"  plot(1:10);",
      "  calcPlotSpectrumVsClass_small(",
      "masses_spec",     "=", numericVectorToStringForEval(masses_spec    ), ", ",
      "intensity_spec",  "=", numericVectorToStringForEval(intensity_spec ), ", ",
      "colors_spec",     "=", colorVectorToStringForEval(  colors_spec    ), ", ",
      "masses_class",    "=", numericVectorToStringForEval(masses_class   ), ", ",
      "frequency_class", "=", numericVectorToStringForEval(frequency_class), ", ",
      "colors_class",    "=", colorVectorToStringForEval(  colors_class   ), ", ",
      "xInterval",       "=", numericVectorToStringForEval(xInterval      ),
      ");",
      "})",
      sep = ""
    )
    
    ## draw plot
    eval(parse(text=plotAsString), envir = environment())
    
    inputs_i[[i]] <- as.character(
      plotOutput(height = 50, 
                 outputId = itemId
      )
      #plotlyOutput(height = 400, 
      #             outputId = itemId
      #)
    )
  }
  
  returnObj <- list(
    numberOfMatchingMasses_i = numberOfMatchingMasses_i,
    inputs_i = inputs_i
  )
  
  return(returnObj)
}
getNumberOfHits <- function(dataList, frequentFragments, characteristicFragments, precursorIndeces, mappingSpectraToClassDf, properties_class) {
  if(TRUE){
    dataList_ <<- dataList
    frequentFragments_ <<- frequentFragments
    characteristicFragments_ <<- characteristicFragments
    precursorIndeces_ <<- precursorIndeces
    mappingSpectraToClassDf_ <<- mappingSpectraToClassDf
    properties_class_ <<- properties_class
  }
  if(FALSE){
    dataList <- dataList_
    frequentFragments <- frequentFragments_
    characteristicFragments <- characteristicFragments_
    precursorIndeces <- precursorIndeces_
    mappingSpectraToClassDf <- mappingSpectraToClassDf_
    properties_class <- properties_class_
  }
  
  ## class statistics for class plot
  frequentMasses       <- as.numeric(names(frequentFragments)) 
  characteristicMasses <- as.numeric(names(characteristicFragments))
  masses_class <- unique(c(frequentMasses, characteristicMasses))
  
  if(FALSE){
    is_equal_vec <- function(x, y_array, tol = .Machine$double.eps ^ 0.5) {
      abs(x - y_array) < tol
    }
    is_equal_mat <- function(x_array, y_array, tol = .Machine$double.eps ^ 0.5) {
      sapply(X = x_array, FUN = is_equal_vec, y_array)
    }
  }
  
  ## create a character vector of shiny inputs
  tolerance <- .Machine$double.eps ^ 0.5 ## default in function all.equal
  
  
  #mappingSpectraToClassDf <- data.frame(
  #  "SpectraMasses"      = fragmentMasses           [mappedFragmentIndeces_source],
  #  "ClassMasses"        = fragmentMasses_classifier[mappedFragmentIndeces_target],
  #  "SpectraMassIndeces" = mappedFragmentIndeces_source,
  #  "ClassMassIndeces"   = mappedFragmentIndeces_target#,
  ##  "fragmentMasses"            = fragmentMasses,
  ##  "fragmentMasses_classifier" = fragmentMasses_classifier
  #)
  
  ## sum(match(x = masses_spec, table = dataList$fragmentMasses) %in% mappingSpectraToClassDf$SpectraMassIndeces)
  
  if(FALSE){
  numberOfMatchingMasses_i <- sapply(X = precursorIndeces, FUN = function(precursorIndex){
    masses_spec <- getMS2spectrumInfoForPrecursor(dataList = dataList, precursorIndex = precursorIndex)$fragmentMasses
    matchingMassRowIndeces <- which(
      apply(X = outer(X = mappingSpectraToClassDf$SpectraMasses, Y = masses_spec , FUN = "-"), MARGIN = 1, FUN = function(x){any(abs(x) <= tolerance)}) &
      apply(X = outer(X = mappingSpectraToClassDf$ClassMasses  , Y = masses_class, FUN = "-"), MARGIN = 1, FUN = function(x){any(abs(x) <= tolerance)})
    )
    return(length(matchingMassRowIndeces))
  })
  }
  
  spectraMasses <- as.character(mappingSpectraToClassDf$SpectraMasses)
  tmpResult <- as.character(mappingSpectraToClassDf$ClassMasses  ) %in% as.character(masses_class)
  
  numberOfMatchingMasses_i <- sapply(X = precursorIndeces, FUN = function(precursorIndex){
    masses_spec <- getMS2spectrumInfoForPrecursor(dataList = dataList, precursorIndex = precursorIndex)$fragmentMasses
    
    matchingMassRowIndeces <- which(
      spectraMasses %in% as.character(masses_spec) &
      tmpResult
      
      
      #match(x = masses_spec,  table = dataList$fragmentMasses) &
      #match(x = masses_class, table = properties_class[[1]]$fragmentMasses)
      
      #apply(X = outer(X = mappingSpectraToClassDf$SpectraMasses, Y = masses_spec , FUN = "-"), MARGIN = 1, FUN = function(x){any(abs(x) <= tolerance)}) &
      #apply(X = outer(X = mappingSpectraToClassDf$ClassMasses  , Y = masses_class, FUN = "-"), MARGIN = 1, FUN = function(x){any(abs(x) <= tolerance)})
    )
    return(length(matchingMassRowIndeces))
  })
  
  if(FALSE){
  numberOfMatchingMasses_i <- integer(length(precursorIndeces))
  for (i in seq_along(precursorIndeces)){
    #precursorIndex <- precursorIndeces[[i]]
    masses_spec <- getMS2spectrumInfoForPrecursor(dataList = dataList, precursorIndex = precursorIndeces[[i]])
    
    #if(length(precursorIndeces) == 1){
    #  resultObj   <- getMS2spectrumInfoForPrecursor(dataList = dataList, precursorIndex = precursorIndeces)
    #  masses_spec <- resultObj$fragmentMasses
    #} else {
    #  returnObj   <- getSpectrumStatistics(dataList = dataList, precursorSet = precursorIndeces)
    #  masses_spec <- returnObj$fragmentMasses
    #}
    
    tolerance <- .Machine$double.eps ^ 0.5 ## default in function all.equal
    
    #matchingMassRowIndeces <- 1
    matchingMassRowIndeces <- which(
      apply(X = outer(X = mappingSpectraToClassDf$SpectraMasses, Y = masses_spec , FUN = "-"), MARGIN = 1, FUN = function(x){any(abs(x) <= tolerance)}) &
      apply(X = outer(X = mappingSpectraToClassDf$ClassMasses  , Y = masses_class, FUN = "-"), MARGIN = 1, FUN = function(x){any(abs(x) <= tolerance)})
    )
    numberOfMatchingMasses_i[[i]] <- length(matchingMassRowIndeces)
  }
  }
  
  return(numberOfMatchingMasses_i)
}
getInputValues <- function(id, counter, len) {
  id <- paste(id, "_", counter, sep = "")
  
  ## obtain the values of inputs
  res <- unlist(lapply(1:len, function(i) {
    itemId <- paste(id, "_", i, sep = "")
    value  <- input[[itemId]]
    if (is.null(value))
      return(NA)
    else
      return(value)
  }))
  
  return(res)
}

================
File: inst/MetFamily/app_files/server_guiAnnotation.R
================
resetWorkspaceFunctions <- c(resetWorkspaceFunctions, function(){
  print("Reset annotation state")
  ## anno
  #updateColourInput(session = session, inputId = "newAnnotationColor", allowedCols = colorPalette())
  updateTextInput(session = session, inputId = "newAnnotationValue", value = "")
  updateTextInput(session = session, inputId = "newAnnotationValue2", value = "")
  updateSelectInput(session = session, inputId = "presentAnnotationValue", choices = c("[init]"))
  updateSelectInput(session = session, inputId = "previousAnnotationValue", choices = c("Artifact"))
})

checkAnnotationValue <- function(annotationValue){
  ## no ', '
  ## no '='
  ## not empty
  ## not only whitespaces (space, tab, newline, carriage return, vertical tab, form feed)
  return(!grepl(x = annotationValue, pattern = "(, )|(=)|(^$)|(^[ \t\n\r\v\f]+$)"))
}
checkAnnotationValueWithModalErrorDialog <- function(annotationValue){
  if(!checkAnnotationValue(annotationValue = annotationValue)){
    msg <- paste(
      "The annotation name is not valid.", "<br>",
      "<br>",
      "The annotation name i) must not contain ', ', ii) must not contain '=', iii) must not by empty, and iv) must contain characters other than whitespaces.",
      "<br>",
      "Please make sure that the above rules apply and try again.",
      sep = ""
    )
    showErrorDialog(msg)
    return(FALSE)
  }
  return(TRUE)
}
addAnnotation <- function(precursorSet, annotationValue, annotationColor){
  ## validate
  if(!checkAnnotationValueWithModalErrorDialog(annotationValue = annotationValue))
    return()
  
  if(is.na(match(x = annotationValue, table = dataList$annoPresentAnnotationsList))){
    ## new annotation
    annoIdx <- length(dataList$annoPresentAnnotationsList) + 1
    dataList$annoPresentAnnotationsList[[annoIdx]] <<- annotationValue
    dataList$annoPresentColorsList[[annoIdx]] <<- annotationColor
  }
  ## add
  for(precursor in precursorSet){
    if(annotationValue == artifactName)
      ## is artifact!
      dataList$annoArrayIsArtifact[[precursor]] <<- TRUE
    else{
      if(is.na(match(x = annotationValue, table = dataList$annoArrayOfLists[[precursor]])))
        ## new anno
        dataList$annoArrayOfLists[[precursor]] <<- c(dataList$annoArrayOfLists[[precursor]], annotationValue)
    }
  }
  
  ## update gui
  #print("addAnnotation updateAnnoGui")
  checkForDoublyNamedAnnotations(annotationValue)
  updateAnnotationDependentGui(precursorSet)
  
  ##################################################################
  ## feedback
  msg <- paste(
    length(precursorSet), " MS\u00B9 features have been annotated as '", annotationValue, "'.",
    sep = ""
  )
  showInfoDialog(msg)
}
removeAnnotation <- function(precursorSet, annotationValue){
  ## remove
  for(precursor in precursorSet){
    if(annotationValue == artifactName)
      dataList$annoArrayIsArtifact[[precursor]] <<- FALSE
    else{
      idx <- match(x = annotationValue, table = dataList$annoArrayOfLists[[precursor]])
      dataList$annoArrayOfLists[[precursor]] <<- dataList$annoArrayOfLists[[precursor]][-idx]
    }
  }
  
  ## remove anno completely?
  annoThere <- lapply(X = dataList$annoArrayOfLists, FUN = function(x){ match(x = annotationValue, table = x) })
  if(annotationValue != artifactName & all(is.na(annoThere))){
    idx <- match(x = annotationValue, table = dataList$annoPresentAnnotationsList)
    dataList$annoPresentAnnotationsList <<- dataList$annoPresentAnnotationsList[-idx]
    dataList$annoPresentColorsList      <<- dataList$annoPresentColorsList[-idx]
  }
  
  ## update gui
  #print("removeAnnotation updateAnnoGui")
  updateAnnotationDependentGui(precursorSet)
}
renameAnnotation <- function(annotationValueOld, annotationColorOld, annotationValueNew, annotationColorNew){
  ## update summary
  annotationIdx   <- which(dataList$annoPresentAnnotationsList == annotationValueOld)
  dataList$annoPresentAnnotationsList[[annotationIdx]] <<- annotationValueNew
  dataList$annoPresentColorsList     [[annotationIdx]] <<- annotationColorNew
  
  ## update feature ano
  precursorList <- list()
  for(featureIdx in seq_len(dataList$numberOfPrecursors)){
    if(annotationValueOld %in% dataList$annoArrayOfLists[[featureIdx]]){
      precursorList[[length(precursorList) + 1]] <- featureIdx
      dataList$annoArrayOfLists[[featureIdx]][[which(dataList$annoArrayOfLists[[featureIdx]] == annotationValueOld)]] <<- annotationValueNew
    }
  }
  
  checkForDoublyNamedAnnotations(annotationValueNew)
  updateAnnotationDependentGui(unlist(precursorList))
}
checkForDoublyNamedAnnotations <- function(annotationName){
  annotationIndeces   <- which(dataList$annoPresentAnnotationsList == annotationName)
  if(length(annotationIndeces) > 1){
    dataList$annoPresentAnnotationsList <<- dataList$annoPresentAnnotationsList[-annotationIndeces[-1]]
    dataList$annoPresentColorsList      <<- dataList$annoPresentColorsList[-annotationIndeces[-1]]
  }
}
setArtifactState <- function(precursorSet, isArtifact){
  ## add
  dataList$annoArrayIsArtifact[precursorSet] <<- isArtifact
  
  ## update gui
  updateAnnotationDependentGui(precursorSet)
}
setAnnotationPrimary <- function(precursorSet, annotationValue){
  ## remove
  for(precursor in precursorSet){
    idx <- match(x = annotationValue, table = dataList$annoArrayOfLists[[precursor]])
    dataList$annoArrayOfLists[[precursor]] <<- c(dataList$annoArrayOfLists[[precursor]][[idx]], dataList$annoArrayOfLists[[precursor]][-idx])
  }
  
  ## update gui
  #print("setAnnotation primary updateAnnoGui")
  updateAnnotationDependentGui(precursorSet)
}
updateAnnotationDependentGui <- function(precursorSet){
  updateAnnoGui(precursorSet)
  updateMS1FeatureTableGui(precursorSet)
  updatePlotsWithAnnotations()
  updateAnnotationOverview()
}
commonAnnotations <- function(precursorSet){
  if(is.null(precursorSet))
    return(NULL)
  if(all(unlist(dataList$annoArrayIsArtifact[precursorSet])))
    return(artifactName)
  
  ## at least one non-artifact precursor present
  intersection <- unlist(dataList$annoPresentAnnotationsList)
  for(precursor in precursorSet)
    if(!dataList$annoArrayIsArtifact[[precursor]])
      intersection <- intersect(x = intersection, y = unlist(dataList$annoArrayOfLists[[precursor]]))
  return(intersection)
}
## table update
commonAnnotation <- character()
updateAnnoGui <- function(precursorSet){
  if(length(precursorSet) == 0)
    return()
  
  ## annotation
  commonAnnos <- commonAnnotations(precursorSet)
  
  if(length(commonAnnos) > 0){
    commonAnnotation <<- commonAnnos
    updateSelectInput(session = session, inputId = "presentAnnotationValue", choices = commonAnnos)
    shinyjs::enable(id="presentAnnotationValue")
  } else {
    commonAnnotation <<- character()
    updateSelectInput(session = session, inputId = "presentAnnotationValue", choices = c("[none]"))
    shinyjs::disable(id="presentAnnotationValue")
  }
  
  updateSelectInput(session = session, inputId = "previousAnnotationValue", choices = dataList$annoPresentAnnotationsList)
  updateTabsetPanel(session = session, inputId = "precursorSelectionTabs", selected = precursorSelectionTabCurrentTab)
  
  if(length(commonAnnos) > 0){
    shinyjs::enable("removePresentAnnotation")
    shinyjs::enable("setPresentAnnotationPrimary")
  } else {
    shinyjs::disable("removePresentAnnotation")
    shinyjs::disable("setPresentAnnotationPrimary")
  }
}

## listen to annotation events
obsSetPresentAnnoPrimary <- observeEvent(input$setPresentAnnotationPrimary, {
  session$sendCustomMessage("disableButton", "setPresentAnnotationPrimary")
  value     <- input$presentAnnotationValue
  
  drawPlots <- as.numeric(input$setPresentAnnotationPrimary)
  #if(drawPlots == setPresentAnnotationPrimaryValue)
  #  return()
  #setPresentAnnotationPrimaryValue <<- drawPlots
  print(paste("Observe setPresentAnnotationPrimary", drawPlots))
  
  setAnnotationPrimary(precursorSet = selectedPrecursorSet, annotationValue = value)
  
  session$sendCustomMessage("enableButton", "setPresentAnnotationPrimary")
})
obsRemovePresentAnno <- observeEvent(input$removePresentAnnotation, {
  #session$sendCustomMessage("disableButton", "removePresentAnnotation")
  #session$sendCustomMessage(type="jsCode", list(code= paste("$('#","removePresentAnnotation","').prop('disabled',true)",sep="")))
  shinyjs::disable(id="removePresentAnnotation")
  
  value     <- input$presentAnnotationValue
  
  removePresentAnnotationValue <- as.numeric(input$removePresentAnnotation)
  ## XXX why?
  #if(drawPlots == removePresentAnnotationValue)
  #  return()
  #removePresentAnnotationValue <<- drawPlots
  print(paste("Observe removePresentAnnotation", removePresentAnnotationValue))
  
  removeAnnotation(precursorSet = selectedPrecursorSet, annotationValue = value)
  #session$sendCustomMessage("enableButton", "removePresentAnnotation")
  #session$sendCustomMessage(type="jsCode", list(code= paste("$('#","removePresentAnnotation","').prop('enabled',true)",sep="")))
  
  #if(length(commonAnnotation) > 0)
  #  shinyjs::enable(id="removePresentAnnotation")
})#, priority = -1)
obsToggleAddNewAnnoButton <- observeEvent(input$newAnnotationValue, {
  value <- input$newAnnotationValue
  
  print(paste("Observe newAnnotationValue", nchar(value)))
  
  if(nchar(value) > 0)
    shinyjs::enable("submitNewAnnotation")
  #enableActionButton(session, "submitNewAnnotation")
  else
    shinyjs::disable("submitNewAnnotation")
  #disableActionButton(session, "submitNewAnnotation")
})
obsAddNewAnno <- observeEvent(input$submitNewAnnotation, {
  session$sendCustomMessage("disableButton", "submitNewAnnotation")
  value <- input$newAnnotationValue
  color <- input$newAnnotationColor
  
  submitNewAnnotation <- as.numeric(input$submitNewAnnotation)
  print(paste("Observe submitNewAnnotation", submitNewAnnotation))
  
  #if(submitNewAnnotation == submitNewAnnotationValue)
  #  return()
  #submitNewAnnotationValue <<- submitNewAnnotation
  
  addAnnotation(precursorSet = selectedPrecursorSet, annotationValue = value, annotationColor = color)
  session$sendCustomMessage("enableButton", "submitNewAnnotation")
})
obsAddPresentAnno <- observeEvent(input$submitPreviousAnnotation, {
  session$sendCustomMessage("disableButton", "submitPreviousAnnotation")
  value <- input$previousAnnotationValue
  
  submitPreviousAnnotation <- as.numeric(input$submitPreviousAnnotation)
  #if(submitPreviousAnnotation == submitPreviousAnnotationValue)
  #  return()
  #submitPreviousAnnotationValue <<- submitPreviousAnnotation
  print(paste("Observe submitPreviousAnnotation", submitPreviousAnnotation))
  
  color <- dataList$annoPresentColorsList[[match(x = value, table = dataList$annoPresentAnnotationsList)]]
  addAnnotation(precursorSet = selectedPrecursorSet, annotationValue = value, annotationColor = color)
  session$sendCustomMessage("enableButton", "submitPreviousAnnotation")
})
obsIgnoreValueChanged <- observeEvent(input$updateArtifactsFromCheckboxes, {
  session$sendCustomMessage("disableButton", "updateArtifactsFromCheckboxes")
  updateArtifactsFromCheckboxes <- as.numeric(input$updateArtifactsFromCheckboxes)
  
  #################################################
  ## check if button was hit
  #if(updateArtifactsFromCheckboxes == updateArtifactsFromCheckboxesButtonValue)
  #  return()
  #updateArtifactsFromCheckboxesButtonValue <<- updateArtifactsFromCheckboxes
  
  ## get and process values
  vals <- getInputValues(id = paste(state_selections$selectedSelection, artifactName, sep = "_"), counter = selectedTable_id, len = nrow(selectedTable))
  
  if(all(is.na(vals)))
    return()
  
  nas <- is.na(vals)
  vals[nas] <- dataList$annoArrayIsArtifact[selectedPrecursorSet][nas]
  vals <- as.logical(vals)
  
  setArtifactState(selectedPrecursorSet, vals)
  session$sendCustomMessage("enableButton", "updateArtifactsFromCheckboxes")
})

suspendOnExitFunctions <- c(suspendOnExitFunctions, function(){
  print("Suspending tabPca observers")
  obsSetPresentAnnoPrimary$suspend()
  obsRemovePresentAnno$suspend()
  obsToggleAddNewAnnoButton$suspend()
  obsAddNewAnno$suspend()
  obsAddPresentAnno$suspend()
  obsIgnoreValueChanged$suspend()
})

================
File: inst/MetFamily/app_files/server_guiDialogs.R
================
showErrorDialog <- function(msg){
  showDialog("An error occurred", msg)
}
showInfoDialog <- function(msg){
  showDialog("Information", msg)
}
showDialog <- function(title, msg){
  print("Show dialog")
  #output$infoPopupDialog <- renderUI({
  #  bsModal(id = "modalInfoPopupDialog", title = "Information", trigger = "", size = "large", HTML(msg))
  #})
  #toggleModal(session = session, modalId = "modalInfoPopupDialog", toggle = "open")
  showModal(session = session, ui = modalDialog(title = title, HTML(msg)))
}
showUiDialog <- function(modalDialog){
  print("Show ui dialog")
  showModal(session = session, ui = modalDialog)
}

================
File: inst/MetFamily/app_files/server_guiMs2plot.R
================
##############################################
## MS2 peaks

## resultObj$fragmentMasses <- fragmentsX
## resultObj$fragmentAbundances <- fragmentsY
## resultObj$fragmentColor <- fragmentsColor
## resultObj$fragmentDiscriminativity <- fragmentDiscriminativity
## ?? resultObj$clusterDiscriminativity <- clusterDiscriminativity
## ? resultObj$infoText <- infoText
## ? resultObj$metFragLinkList <- NULL
## ? resultObj$precursorSet <- precursorSet
## ? resultObj$numberOfPrecursors <- numberOfPrecursors
ms2PlotValues <- reactiveValues(
  fragmentListClicked = NULL,
  fragmentListHovered = NULL
)
ms2PlotRange         <- reactiveValues(xMin = NULL, xMax = NULL, xInterval = NULL, xIntervalSize = NULL)

resetWorkspaceFunctions <- c(resetWorkspaceFunctions, function(){
  print("Reset ms2plot state")
  ## MS2 plot range
  resetMS2PlotRange()
  ## fragments
  ms2PlotValues$fragmentListHovered <<- NULL
  ms2PlotValues$fragmentListClicked <<- NULL
})


drawMS2Plot <- function(consoleInfo = NULL){
  output$plotMS2 <- renderPlot({
    print(paste("### MS2 ###", consoleInfo))
    drawMS2PlotImpl()
  })
}
drawMS2Legend <- function(consoleInfo = NULL){
  output$plotMS2Legend <- renderPlot({
    print(paste("### leg ###", consoleInfo))
    drawMS2LegendImpl()
  })
}
drawFragmentDiscriminativityLegend <- function(consoleInfo = NULL){
  output$plotFragmentDiscriminativityLegend <- renderPlot({
    print(paste("### leg ###", consoleInfo))
    drawFragmentDiscriminativityLegendImpl()
  })
}

resetMS2PlotRange <- function(){
  ms2PlotRange$xMin <<- dataList$minimumMass
  ms2PlotRange$xMax <<- dataList$maximumMass
  ms2PlotRange$xInterval <<- c(dataList$minimumMass, dataList$maximumMass)
  ms2PlotRange$xIntervalSize <<- dataList$maximumMass - dataList$minimumMass
}

if(FALSE){
obsMS2hover <- observeEvent(input$plotMS2_hover, {
  hoverX <- input$plotMS2_hover$x
  hoverY <- input$plotMS2_hover$y
  plotWidth  <- session$clientData$output_plotMS2_width
  plotHeight  <- session$clientData$output_plotMS2_height
  
  if(is.null(hoverX) | is.null(hoverY))
    return()
  if(any(is.null(ms2PlotValues$fragmentListClicked), length(ms2PlotValues$fragmentListClicked$fragmentMasses) == 0))
    return()
  
  ################################################
  ## decide whether the click is close enough to trigger event
  
  minimumIndex <- getSelectedPOI_XY(
    mouseX = hoverX, mouseY = hoverY, poiCoordinatesX = ms2PlotValues$fragmentListClicked$fragmentMasses, poiCoordinatesY = ms2PlotValues$fragmentListClicked$fragmentAbundances, 
    plotWidth = plotWidth, plotHeight = plotHeight, plotRangeX = ms2PlotRange$xIntervalSize, plotRangeY = 1
  )
  print(paste("Observe MS2 hover", minimumIndex))
  if(is.null(minimumIndex)){
    ## nothing in selection range
    #output$information <- renderText({
    #  print(paste("update output$information"))
    #  paste("", sep = "")
    #})
  } else {
    ## point selected
    fragmentIndex <- which(dataList$fragmentMasses == ms2PlotValues$fragmentListClicked$fragmentMasses[[minimumIndex]])
    
    if(state$plotHcaShown)
      numberOfPrecursors <- sum(dataList$featureMatrix[filterHca$filter, fragmentIndex] != 0)
    if(state$plotPcaShown)
      numberOfPrecursors <- sum(dataList$featureMatrix[filterPca$filter, fragmentIndex] != 0)
    
    output$information <- renderText({
      print(paste("update output$information"))
      paste(
        "Fragment with m/z = ", ms2PlotValues$fragmentListClicked$fragmentMasses[[minimumIndex]], 
        " and (average) abundance = ", format(x = ms2PlotValues$fragmentListClicked$fragmentAbundances[[minimumIndex]], digits = 1, nsmall = 4), 
        " is present in ", numberOfPrecursors, " MS/MS spectra",
        "\nand has a cluster-discriminating power of ", format(x = ms2PlotValues$fragmentListClicked$fragmentDiscriminativity[[minimumIndex]]*100, digits = 3, nsmall = 2), "%.", 
        sep = ""
      )
    })
  }
  output$tip <- renderText({
    print(paste("update output$tip"))
    paste(
      "Hover or click a fragment node (only 'Fragments from selection') to view information about this fragment.", 
      "Brush horizontally and double-click to zoom in.", 
      "Double-click to zoom out.", 
      sep = "\n"
    )
  })
})
}
output$plotMS2_hover_info <- renderUI({
  hover <- input$plotMS2_hover
  hoverX <- hover$x
  hoverY <- hover$y
  plotWidth  <- session$clientData$output_plotMS2_width
  plotHeight <- session$clientData$output_plotMS2_height
  
  if(is.null(hoverX) | is.null(hoverY))
    return()
  if(any(is.null(ms2PlotValues$fragmentListClicked), length(ms2PlotValues$fragmentListClicked$fragmentMasses) == 0))
    return()
  
  output$tip <- renderText({
    print(paste("update output$tip"))
    paste(
      "Hover or click a fragment node (only 'Fragments from selection') to view information about this fragment.", 
      "Brush horizontally and double-click to zoom in.", 
      "Double-click to zoom out.", 
      sep = "\n"
    )
  })
  ################################################
  ## decide whether the click is close enough to trigger event
  
  minimumIndex <- getSelectedPOI_XY(
    mouseX = hoverX, mouseY = hoverY, poiCoordinatesX = ms2PlotValues$fragmentListClicked$fragmentMasses, poiCoordinatesY = ms2PlotValues$fragmentListClicked$fragmentAbundances, 
    plotWidth = plotWidth, plotHeight = plotHeight, plotRangeX = ms2PlotRange$xIntervalSize, plotRangeY = 1
  )
  print(paste("Observe MS2 hover", minimumIndex))
  if(is.null(minimumIndex)){
    ## nothing in selection range
    #output$information <- renderText({
    #  print(paste("update output$information"))
    #  paste("", sep = "")
    #})
    return()
  }
  
  ## point selected
  fragmentIndex <- which(dataList$fragmentMasses == ms2PlotValues$fragmentListClicked$fragmentMasses[[minimumIndex]])
  
  if(state$plotHcaShown){
    numberOfPrecursors <- sum(dataList$featureMatrix[filterHca$filter, fragmentIndex] != 0)
    currentlyShownAnalysisype <- "HCA"
  }
  if(state$plotPcaShown){
    numberOfPrecursors <- sum(dataList$featureMatrix[filterPca$filter, fragmentIndex] != 0)
    currentlyShownAnalysisype <- "PCA"
  }
  
  #output$information <- renderText({
  #  print(paste("update output$information"))
  #  paste(
  #    "Fragment with m/z = ", ms2PlotValues$fragmentListClicked$fragmentMasses[[minimumIndex]], 
  #    " and (average) abundance = ", format(x = ms2PlotValues$fragmentListClicked$fragmentAbundances[[minimumIndex]], digits = 1, nsmall = 4), 
  #    " is present in ", numberOfPrecursors, " MS/MS spectra",
  #    "\nand has a cluster-discriminating power of ", format(x = ms2PlotValues$fragmentListClicked$fragmentDiscriminativity[[minimumIndex]]*100, digits = 3, nsmall = 2), "%.", 
  #    sep = ""
  #  )
  #})
  
  fragmentMz <- ms2PlotValues$fragmentListClicked$fragmentMasses[[minimumIndex]]
  fragmentMzS <- format(x = fragmentMz, nsmall = 4)
  intensityS <- format(x = ms2PlotValues$fragmentListClicked$fragmentAbundances[[minimumIndex]], digits = 1, nsmall = 4)
  cdpS <- format(x = ms2PlotValues$fragmentListClicked$fragmentDiscriminativity[[minimumIndex]]*100, digits = 3, nsmall = 2)
  
  info <- paste(
    "<b>", ifelse(test = fragmentMz < 0, yes = "Neutral loss", no = "Fragment"), ": ", "</b>", fragmentMzS, "<br>",
    "<b>Average intensity: ", "</b>", intensityS, "<br>",
    "<b>MS/MS spectra: ", "</b>", numberOfPrecursors, " (in ", currentlyShownAnalysisype, ")", "<br>",
    "<b>Cluster-discriminating power: ", "</b>", cdpS, "%", 
    sep = ""
  )
  
  panelWidth <- as.integer(plotWidth*0.6)
  showPlotTooltip(hover, info, panelWidth)
})

obsMS2click <- observeEvent(input$plotMS2_click, {
  clickX <- input$plotMS2_click$x
  clickY <- input$plotMS2_click$y
  
  brush  <- input$plotMS2_brush
  
  plotWidth  <- session$clientData$output_plotMS2_width
  plotHeight <- session$clientData$output_plotMS2_height
  
  if(is.null(clickX) | is.null(clickY))
    return()
  if(!is.null(brush))
    ## ongoing brushing
    return()
  if(any(is.null(ms2PlotValues$fragmentListClicked), length(ms2PlotValues$fragmentListClicked$fragmentMasses) == 0))
    return()
  
  #################################################
  ## decide whether the click is close enough to trigger event
  minimumIndex <- getSelectedPOI_XY(
    mouseX = clickX, mouseY = clickY, poiCoordinatesX = ms2PlotValues$fragmentListClicked$fragmentMasses, poiCoordinatesY = ms2PlotValues$fragmentListClicked$fragmentAbundances,
    plotWidth = plotWidth, plotHeight = plotHeight, plotRangeX = ms2PlotRange$xIntervalSize, plotRangeY = 1
  )
  print(paste("Observe MS2 click", minimumIndex))
  
  if(is.null(minimumIndex)){
    ##########################################
    ## reset click
    selectionByFragmentReset()
  } else {
    ##########################################
    ## peak click
    selectionByFragment(minimumIndex)
  }
  
  ## HCA
  if(state$showHCAplotPanel)
    drawDendrogramPlot(consoleInfo = "MS2 click output$plotDendrogram", withHeatmap = TRUE)
  ## PCA
  if(state$showPCAplotPanel)
    drawPcaLoadingsPlot(consoleInfo = "MS2 click output$plotPcaLoadings")
  
  ## update node selection
  drawMS2Plot(consoleInfo = "MS2 click output$plotMS2")
})
obsMS2dblClick <- observeEvent(input$plotMS2_dblclick, {
  brush <- input$plotMS2_brush
  
  if(all(any(is.null(ms2PlotValues$fragmentListClicked), length(ms2PlotValues$fragmentListClicked$fragmentMasses) == 0), any(is.null(ms2PlotValues$fragmentListHovered), length(ms2PlotValues$fragmentListHovered$fragmentMasses) == 0)))
    return()
  
  print(paste("observe MS2 dblclick", is.null(brush)))
  
  if (!is.null(brush)) {
    ## set range
    ms2PlotRange$xMin <<- brush$xmin
    ms2PlotRange$xMax <<- brush$xmax
    ms2PlotRange$xInterval <<- c(brush$xmin, brush$xmax)
    ms2PlotRange$xIntervalSize <<- brush$xmax - brush$xmin
  } else {
    ## reset range
    resetMS2PlotRange()
  }
})


suspendOnExitFunctions <- c(suspendOnExitFunctions, function(){
  print("Suspending ms2Plot observers")
  obsMS2click$suspend()
  obsMS2dblClick$suspend()
})

================
File: inst/MetFamily/app_files/server_guiPlotControls.R
================
#TODO need this?
obsShowPlotControls <- observeEvent(input$showPlotControls, {
  showPlotControls <- input$showPlotControls
  print(paste("Observe showPlotControls", showPlotControls))
  state$showPlotControls <<- showPlotControls
})
obsShowClusterLabels <- observeEvent(input$showClusterLabels, {
  showClusterLabels <- input$showClusterLabels
  print(paste("Observe showClusterLabels", showClusterLabels))
  state_tabHca$showClusterLabels <<- showClusterLabels
  #drawDendrogramPlot(consoleInfo = "showClusterLabels")
})
obsHeatmapContent <- observeEvent(input$heatmapContent, {
  heatmapContent <- input$heatmapContent
  
  if(is.null(dataList))
    return()
  
  print(paste("Observe heatmapContent", heatmapContent))
  state_tabHca$heatmapContent <<- heatmapContent
})
obsHeatmapOrdering <- observeEvent(input$heatmapOrdering, {
  if(is.null(dataList))
    return()
  
  heatmapOrdering <- input$heatmapOrdering
  print(paste("Observe heatmapOrdering", heatmapOrdering))
  state_tabHca$heatmapOrdering <<- heatmapOrdering
})
obsHcaPrecursorLabels <- observeEvent(input$hcaPrecursorLabels, {
  hcaPrecursorLabels <- input$hcaPrecursorLabels
  print(paste("Observe hcaPrecursorLabels", hcaPrecursorLabels))
  state_tabHca$hcaPrecursorLabels <<- hcaPrecursorLabels
})
obsShowScoresLabels <- observeEvent(input$showScoresLabels, {
  showScoresLabels <- input$showScoresLabels
  print(paste("Observe showScoresLabels", showScoresLabels))
  state_tabPca$showScoresLabels <<- showScoresLabels
})
obsLoadingsLabels <- observeEvent(input$loadingsLabels, {
  loadingsLabels <- input$loadingsLabels
  print(paste("Observe loadingsLabels", loadingsLabels))
  state_tabPca$loadingsLabels <<- loadingsLabels
})
obsShowLoadingsFeatures <- observeEvent(input$showLoadingsFeatures, {
  showLoadingsFeatures <- input$showLoadingsFeatures
  print(paste("Observe showLoadingsFeatures", paste(showLoadingsFeatures, collapse = ";")))
  
  {
    state_tabPca$showLoadingsFeaturesAnnotated   <<- "Annotated"     %in% showLoadingsFeatures
    state_tabPca$showLoadingsFeaturesUnannotated <<- "Not Annotated" %in% showLoadingsFeatures
    state_tabPca$showLoadingsFeaturesSelected    <<- "Selected"      %in% showLoadingsFeatures
    state_tabPca$showLoadingsFeaturesUnselected  <<- "Not Selected"  %in% showLoadingsFeatures
  }
})
obsShowLoadingsAbundance <- observeEvent(input$showLoadingsAbundance, {
  showLoadingsAbundance <- input$showLoadingsAbundance
  print(paste("Observe showLoadingsAbundance", showLoadingsAbundance))
  state_tabPca$showLoadingsAbundance <<- showLoadingsAbundance
})

suspendOnExitFunctions <- c(suspendOnExitFunctions, function(){
  print("Suspending plotControls observers")
  obsShowPlotControls$suspend()
  obsShowClusterLabels$suspend()
  obsHeatmapContent$suspend()
  obsHeatmapOrdering$suspend()
  obsHcaPrecursorLabels$suspend()
  observeGroupSet$suspend()
  obsShowScoresLabels$suspend()
  obsLoadingsLabels$suspend()
  obsShowLoadingsFeatures$suspend()
  obsShowLoadingsAbundance$suspend()
})

================
File: inst/MetFamily/app_files/server_guiPlots.R
================
resetWorkspaceFunctions <- c(resetWorkspaceFunctions, function(){
  print("Reset plot state")
  ## reset plots
  doClearPlots()
})

## POI selection
getSelectedPOI_X <- function(mouseX, poiCoordinatesX, plotWidth, plotRangeX){
  if(any(is.na(c(poiCoordinatesX))))
    return(NULL)
  
  factorX <- plotWidth  / plotRangeX
  
  mouseX <- mouseX * factorX
  poiCoordinatesX <- poiCoordinatesX * factorX
  
  distances <- abs(poiCoordinatesX - mouseX)
  distanceThreshold <- factorX * plotRangeX / 35
  
  minimumIndex <- which.min(distances)
  minimumDistance <- distances[[minimumIndex]]
  
  if(minimumDistance > distanceThreshold){
    return(NULL)
  } else {
    return(minimumIndex)
  }
}
getSelectedPOI_XY <- function(mouseX, mouseY, poiCoordinatesX, poiCoordinatesY, plotWidth, plotHeight, plotRangeX, plotRangeY){
  ## see also nearPoints(...): http://shiny.rstudio.com/gallery/plot-interaction-selecting-points.html
  if(any(is.na(c(poiCoordinatesX, poiCoordinatesY))))
    return(NULL)
  
  factorX <- plotWidth  / plotRangeX
  factorY <- plotHeight / plotRangeY
  
  mouseX <- mouseX * factorX
  mouseY <- mouseY * factorY
  poiCoordinatesX <- poiCoordinatesX * factorX
  poiCoordinatesY <- poiCoordinatesY * factorY
  
  distancesX <- poiCoordinatesX - mouseX
  distancesY <- poiCoordinatesY - mouseY
  distances <- sqrt(distancesX * distancesX + distancesY * distancesY)
  distanceThreshold <- factorX * plotRangeX / 35
  
  minimumIndex <- which.min(distances)
  if(any(length(minimumIndex)==0, is.na(minimumIndex)))
    return(NULL)
  
  minimumDistance <- distances[[minimumIndex]]
  if(minimumDistance > distanceThreshold){
    return(NULL)
  } else {
    return(minimumIndex)
  }
}


drawDendrogramPlotImpl <- function(){
  resultObj <- calcPlotDendrogram(
    dataList = dataList, 
    filter = filterHca$filter, 
    clusterDataList = clusterDataList, 
    annoPresentAnnotationsList = dataList$annoPresentAnnotationsList, 
    annoPresentColorsList = dataList$annoPresentColorsList, 
    distanceMeasure = currentDistanceMatrixObj$distanceMeasure, 
    selectionFragmentTreeNodeSet = selectionFragmentTreeNodeSet,
    selectionAnalysisTreeNodeSet = selectionAnalysisTreeNodeSet,
    selectionSearchTreeNodeSet = selectionSearchTreeNodeSet,
    showClusterLabels = state_tabHca$showClusterLabels, 
    hcaPrecursorLabels = state_tabHca$hcaPrecursorLabels, 
    xInterval = dendrogramPlotRange$xInterval
  )
  
  dendrogramUserCoordinateRange <- par("usr")
  dendrogramUserCoordinateRangeY <<- dendrogramUserCoordinateRange[[4]] - dendrogramUserCoordinateRange[[3]]
  
  state_tabHca$annotationsHca <<- resultObj
  state_tabHca$annotationLegendHeightHca <<- annoLegendEntryHeight * (length(state_tabHca$annotationsHca$setOfAnnotations) + 1)
}
drawHeatmapPlotImpl <- function(consoleInfo = NULL){
  #calcPlotHeatmap(dataList = dataList, filterObj = filterHca, clusterDataList = clusterDataList, xInterval = dendrogramPlotRange$xInterval)
  if(!is.null(consoleInfo)) print(paste("### hea ###", consoleInfo))
  
  ## selections and selection colors
  selectedTreeNodeSet <- NULL
  frameColor <- NULL
  
  selectedSelection <- state_selections$selectedSelection
  if(!is.null(selectedSelection)){
    analysisSelection <- function(){
      selectedTreeNodeSet <<- selectionAnalysisTreeNodeSet
      frameColor <<- "blue"
    }
    fragmentSelection <- function(){
      selectedTreeNodeSet <<- selectionFragmentTreeNodeSet
      frameColor <<- "green"
    }
    searchSelection <- function(){
      selectedTreeNodeSet <<- selectionSearchTreeNodeSet
      frameColor <<- "red"
    }
    switch(selectedSelection,
           "Analysis_HCA"=analysisSelection(),
           "Analysis_PCA"=analysisSelection(),
           "Fragment_HCA"=fragmentSelection(),
           "Fragment_PCA"=fragmentSelection(),
           "Search_HCA"  =searchSelection(),
           "Search_PCA"  =searchSelection(),
           {## unknown state
             stop(paste("Unknown selectedSelection value", selectedSelection))
           }
    )## end switch
  }
  
  if(hcaHeatMapNew){
    #####################################################################################
    ## new heatmap functionality
    returnObj <- calcPlotHeatmap(
      dataList = dataList, 
      filterObj = filterHca, 
      clusterDataList = clusterDataList, 
      selectedTreeNodeSet = selectedTreeNodeSet, 
      frameColor = frameColor,
      heatmapContent = state_tabHca$heatmapContent,
      heatmapOrdering = state_tabHca$heatmapOrdering,
      xInterval = dendrogramPlotRange$xInterval
    )
    columnsOfInterest <- returnObj$columnsOfInterest
    columnsOfInterestForHeatmap <<- columnsOfInterest
    
    ## heigth per row
    heatmapHeightPerRow <- -1
    if(length(columnsOfInterest) <= maximumheatmapHeightRowCount){
      heatmapHeightPerRow <- maximumheatmapHeightPerRow
    } else if(length(columnsOfInterest) >= minimumheatmapHeightRowCount){
      heatmapHeightPerRow <- minimumheatmapHeightPerRow
    } else {
      heatmapHeightPerRow <- 
        minimumheatmapHeightPerRow + 
        (length(columnsOfInterest)    - maximumheatmapHeightRowCount) / 
        (minimumheatmapHeightRowCount - maximumheatmapHeightRowCount) * 
        (maximumheatmapHeightPerRow - minimumheatmapHeightPerRow)
    }
    
    state_tabHca$heatmapHeight <<- heatmapHeightPerRow * length(columnsOfInterest)
  } else {
    #####################################################################################
    ## old heatmap functionality
    columnsOfInterest <- calcPlotHeatmapOld(
      dataList = dataList, 
      filterObj = filterHca, 
      clusterDataList = clusterDataList, 
      xInterval = dendrogramPlotRange$xInterval
    )
    columnsOfInterestForHeatmap <<- columnsOfInterest
    state_tabHca$heatmapHeight <<- heatmapHeightPerRow * 3
  }
}
drawHeatmapLegendImpl <- function(){
  calcPlotHeatmapLegend(dataList = dataList)
}
drawDendrogramLegendImpl <- function(){
  calcPlotDendrogramLegend()
}
drawAnnotationLegendHCAimpl <- function(){
  calcPlotAnnoLegend(state_tabHca$annotationsHca$setOfAnnotations, state_tabHca$annotationsHca$setOfColors)
}
drawAnnotationLegendForImageHCAimpl <- function(){
  calcPlotAnnoLegendForImage(state_tabHca$annotationsHca$setOfAnnotations, state_tabHca$annotationsHca$setOfColors)
}

drawPcaScoresPlotImpl <- function(){
  #resultObj <- calcPlotPCAscores(
  resultObj <- calcPlotPCAscores(
    pcaObj = pcaDataList$pcaObj, 
    dataList = dataList, 
    filterObj = filterPca, 
    pcaDimensionOne = pcaDataList$dimensionOne, 
    pcaDimensionTwo = pcaDataList$dimensionTwo, 
    showScoresLabels = state_tabPca$showScoresLabels, 
    xInterval = pcaScoresPlotRange$xInterval, 
    yInterval = pcaScoresPlotRange$yInterval
  )
}
#### I am adding this new 
drawPcaScoresPlotImpl1 <- function(){
  #resultObj <- calcPlotPCAscores(
  resultObj <- calcPlotPCAscores1(
    pcaObj = pcaDataList$pcaObj, 
    dataList = dataList, 
    filterObj = filterPca, 
    pcaDimensionOne = pcaDataList$dimensionOne, 
    pcaDimensionTwo = pcaDataList$dimensionTwo, 
    showScoresLabels = state_tabPca$showScoresLabels, 
    xInterval = pcaScoresPlotRange$xInterval, 
    yInterval = pcaScoresPlotRange$yInterval
  )
}
####################

drawPcaLoadingsPlotImpl <- function(){
  resultObj <- calcPlotPCAloadings(
    pcaObj = pcaDataList$pcaObj, 
    dataList = dataList, 
    filter = filterPca$filter, 
    pcaDimensionOne = pcaDataList$dimensionOne, 
    pcaDimensionTwo = pcaDataList$dimensionTwo, 
    selectionFragmentPcaLoadingSet = selectionFragmentPcaLoadingSet,
    selectionAnalysisPcaLoadingSet = selectionAnalysisPcaLoadingSet,
    selectionSearchPcaLoadingSet   = selectionSearchPcaLoadingSet,
    xInterval = pcaLoadingsPlotRange$xInterval, 
    yInterval = pcaLoadingsPlotRange$yInterval,
    loadingsLabels = state_tabPca$loadingsLabels, 
    showLoadingsAbundance = state_tabPca$showLoadingsAbundance, 
    showLoadingsFeaturesAnnotated   = state_tabPca$showLoadingsFeaturesAnnotated,
    showLoadingsFeaturesUnannotated = state_tabPca$showLoadingsFeaturesUnannotated,
    showLoadingsFeaturesSelected    = state_tabPca$showLoadingsFeaturesSelected,
    showLoadingsFeaturesUnselected  = state_tabPca$showLoadingsFeaturesUnselected
  )
  
  state_tabPca$annotationsPca <<- resultObj
  state_tabPca$annotationLegendHeightPca <<- annoLegendEntryHeight * (length(state_tabPca$annotationsPca$setOfAnnotations) + 1)
}

### I am adding this new 
drawPcaLoadingsPlotImpl1 <- function(){
  resultObj <- calcPlotPCAloadings1(
    pcaObj = pcaDataList$pcaObj, 
    dataList = dataList, 
    filter = filterPca$filter, 
    pcaDimensionOne = pcaDataList$dimensionOne, 
    pcaDimensionTwo = pcaDataList$dimensionTwo, 
    selectionFragmentPcaLoadingSet = selectionFragmentPcaLoadingSet,
    selectionAnalysisPcaLoadingSet = selectionAnalysisPcaLoadingSet,
    selectionSearchPcaLoadingSet   = selectionSearchPcaLoadingSet,
    xInterval = pcaLoadingsPlotRange$xInterval, 
    yInterval = pcaLoadingsPlotRange$yInterval,
    loadingsLabels = state_tabPca$loadingsLabels, 
    showLoadingsAbundance = state_tabPca$showLoadingsAbundance, 
    showLoadingsFeaturesAnnotated   = state_tabPca$showLoadingsFeaturesAnnotated,
    showLoadingsFeaturesUnannotated = state_tabPca$showLoadingsFeaturesUnannotated,
    showLoadingsFeaturesSelected    = state_tabPca$showLoadingsFeaturesSelected,
    showLoadingsFeaturesUnselected  = state_tabPca$showLoadingsFeaturesUnselected
  )
  
  state_tabPca$annotationsPca <<- resultObj
  state_tabPca$annotationLegendHeightPca <<- annoLegendEntryHeight * (length(state_tabPca$annotationsPca$setOfAnnotations) + 1)
}
######################

drawAnnotationLegendPCAimpl <- function(){
  calcPlotAnnoLegend(state_tabPca$annotationsPca$setOfAnnotations, state_tabPca$annotationsPca$setOfColors)
}
drawAnnotationLegendForImagePCAimpl <- function(){
  calcPlotAnnoLegendForImage(state_tabPca$annotationsPca$setOfAnnotations, state_tabPca$annotationsPca$setOfColors)
}
drawScoresGroupsLegendImpl <- function(){
  calcPlotScoresGroupsLegend(scoresGroups$grouXXXps, scoresGroups$colors)
}

drawMS2PlotImpl <- function(){
  calcPlotMS2(
    dataList = dataList, 
    fragmentsX = ms2PlotValues$fragmentListClicked$fragmentMasses, 
    fragmentsY = ms2PlotValues$fragmentListClicked$fragmentAbundances, 
    fragmentsColor = ms2PlotValues$fragmentListClicked$fragmentColor, 
    fragmentsDiscriminativity = ms2PlotValues$fragmentListClicked$fragmentDiscriminativity, 
    fragmentsX_02 = ms2PlotValues$fragmentListHovered$fragmentMasses, 
    fragmentsY_02 = ms2PlotValues$fragmentListHovered$fragmentAbundances, 
    fragmentsColor_02 = ms2PlotValues$fragmentListHovered$fragmentColor, 
    xInterval = ms2PlotRange$xInterval, 
    selectedFragmentIndex = selectionFragmentSelectedFragmentIndex,
    dendrogramFragmentStatistics = dendrogramFragmentStatistics
  )
}

####### This is one I comment 

drawMS2LegendImpl <- function(){
  calcPlotMS2Legend(dataList = dataList)
}


drawFragmentDiscriminativityLegendImpl <- function(){
  calcPlotDiscriminativityLegend()
}

doClearPlots <- function(){
  output$plotDendrogram <- renderPlot({
    print(paste("reset output$plotDendrogram"))
    NULL
  })
  output$plotHeatmap <- renderPlot({
    print(paste("reset output$plotHeatmap"))
    NULL
  })
  output$plotHeatmapLegend <- renderPlot({
    print(paste("reset output$plotHeatmapLegend"))
    NULL
  })
  output$plotMS2 <- renderPlot({
    print(paste("reset output$plotMS2"))
    NULL
  })
  output$plotPcaScores <- renderPlot({
    print(paste("reset output$plotPcaScores"))
    NULL
  })
  output$plotPcaLoadings <- renderPlot({
    print(paste("reset output$plotPcaLoadings"))
    NULL
  })
  output$plotAnnoLegendHCA <- renderPlot({
    print(paste("reset output$plotAnnoLegendHCA"))
    NULL
  })
  output$plotAnnoLegendPCA <- renderPlot({
    print(paste("reset output$plotAnnoLegendPCA"))
    NULL
  })
  output$plotMS2Legend <- renderPlot({
    print(paste("reset output$plotMS2Legend"))
    NULL
  })
  output$plotFragmentDiscriminativityLegend <- renderPlot({
    print(paste("reset output$plotFragmentDiscriminativityLegend"))
    NULL
  })
}

## taken from https://gitlab.com/snippets/16220
## or https://github.com/OHDSI/StudyProtocols/blob/master/LargeScalePopEst/extras/ShinyApp/server.R
## or https://stackoverflow.com/questions/48044543/custom-tooltip-in-ggplot-using-geom-polygoncoord-map
showPlotTooltip <- function(hover, info, panelWidth){
  # calculate point position INSIDE the image as percent of total dimensions
  # from left (horizontal) and from top (vertical)
  left_pct <- (hover$x - hover$domain$left) / (hover$domain$right - hover$domain$left)
  top_pct <- (hover$domain$top - hover$y) / (hover$domain$top - hover$domain$bottom)
  
  # calculate distance from left and bottom side of the picture in pixels
  left_px <- hover$range$left + left_pct * (hover$range$right  - hover$range$left)
  top_px  <- hover$range$top  + top_pct  * (hover$range$bottom - hover$range$top)
  
  # create style property fot tooltip
  # background color is set so tooltip is a bit transparent
  # z-index is set so we are sure are tooltip will be on top
  #style <- paste0("position:absolute; z-index:100; background-color: rgba(245, 245, 245, 0.85); ",
  style <- paste0("position:absolute; z-index:100; background-color: rgba(245, 245, 245, 0.85); ",
                  "left:", left_px + 7, "px; top:", top_px + 7, "px; width:", panelWidth, "px;")
  
  # actual tooltip created as wellPanel
  wellPanel(
    style = style,
    p(HTML(info))
  )
}

================
File: inst/MetFamily/app_files/server_guiTabAnnotation.R
================
## metabolite families
allAnnotationNames <- NULL

fragmentMassesForFamily <- NULL
fragmentPlot2Range    <- reactiveValues(xMin = NULL, xMax = NULL, xInterval = NULL, xIntervalSize = NULL)

state_tabAnnotation <- reactiveValues(
  metaboliteFamilySelected = FALSE
  #classifierLoaded = FALSE,
  #classifierClassSelected = FALSE,
  #classifierClassMS1featureSelected = FALSE,
  #putativeAnnotationsTableFromAnalysisRowSelected = FALSE
)
resetWorkspaceFunctions <- c(resetWorkspaceFunctions, function(){
  print("Reset tabAnnotation state")
  state_tabAnnotation$metaboliteFamilySelected <<- FALSE
  #state$classifierLoaded <<- FALSE
  #state$classifierClassSelected <<- FALSE
  #state$classifierClassMS1featureSelected <<- FALSE
  
  ## metabolite families
  allAnnotationNames <<- NULL
  
  ## set state
  updateAnnotationOverview()
})

updateAnnotationOverview <- function(){
  allAnnotationNames  <- unlist(dataList$annoPresentAnnotationsList)
  allAnnotationColors <- unlist(dataList$annoPresentColorsList)
  annoCounts          <- sapply(X = allAnnotationNames, FUN = function(x){sum(unlist(lapply(X = dataList$annoArrayOfLists, FUN = function(y){any(y==x)})))})
  
  these <- annoCounts > 0
  allAnnotationNames  <- allAnnotationNames[these]
  allAnnotationColors <- allAnnotationColors[these]
  annoCounts          <- annoCounts[these]
  
  allAnnotationNames <<- allAnnotationNames
  
  metaboliteFamiliesDf <- data.frame(
    "Family" = allAnnotationNames,
    "Color"  = allAnnotationColors,
    "Count"  = annoCounts
  )
  
  dataTable <- datatable(
    data = metaboliteFamiliesDf, 
    escape = FALSE, rownames = FALSE,
    selection = list(mode = "single"),#, selected = selected), 
    options = list(
      #scrollY = "600px",
      scrollY = "20vh",
      preDrawCallback = JS('function() { Shiny.unbindAll(this.api().table().node()); }'),
      drawCallback    = JS('function() { Shiny.bindAll(  this.api().table().node()); }'),
      #rowCallback = JS(
      #  "function(nRow, aData, iDisplayIndex, iDisplayIndexFull) {",
      #  "var full_text = classes[[nRow]]",
      #  "$('td:eq(1)', nRow).attr('title', full_text);",
      #  "}"),
      iDisplayLength=nrow(metaboliteFamiliesDf),       # initial number of records
      #aLengthMenu = c(5,10),    # records/page options
      #bLengthChange =0,        # show/hide records per page dropdown
      #bFilter = 0,              # global search box on/off
      #bInfo = 0,                # information on/off (how many records filtered, etc)
      #bAutoWidth = 0,           # automatic column width calculation, disable if passing column width via aoColumnDefs
      #aoColumnDefs = list(list(sWidth="300px", aTargets=c(list(0),list(1))))    # custom column size
      ordering = F,              # row ordering
      sDom  = 't'
      #sDom  = '<"top">rt<"bottom">ip'
    ))
  
  output$familySelectionTable <- DT::renderDataTable(
    expr = formatStyle(table = dataTable, columns = "Color", target = "cell", backgroundColor = styleEqual(levels = allAnnotationColors, values = allAnnotationColors)),
    server = FALSE
  )
  
  output$familyCount2 <- renderText({
    print(paste("init output$familyCount2"))
    paste("Available metabolite families:", nrow(metaboliteFamiliesDf))
  })
}
obsFamilySelectionTable_rows_selected <- observeEvent(eventExpr = input$familySelectionTable_rows_selected, handlerExpr = {
  print(paste("Observe familySelectionTable_rows_selected", input$familySelectionTable_rows_selected))
  
  state_tabAnnotation$metaboliteFamilySelected <<- !is.null(input$familySelectionTable_rows_selected)
  
  if(is.null(input$familySelectionTable_rows_selected))
    return()
  
  annotation <- allAnnotationNames[[input$familySelectionTable_rows_selected]]
  precursorSet <- which(unlist(lapply(X = dataList$annoArrayOfLists, FUN = function(y){any(y==annotation)})))
  numberOfPrecursors <- length(precursorSet)
  
  ###################################################
  ## family info
  output$featureCountForFamily <- renderText({
    print(paste("init output$featureCountForFamily"))
    paste(numberOfPrecursors, " MS\u00B9 features for metabolite family '", annotation, "'", sep = "")
  })
  
  ###################################################
  ## consensus spectrum (vs class spectrum)
  plotMetaboliteFamilyVersusClass(precursorSet)
  
  ###################################################
  ## ms1 feature table
  ms1FeatureTable <- getTableFromPrecursorSet(dataList = dataList, precursorSet = precursorSet)
  ms1FeatureDf <- createMS1FeatureTable2(ms1FeatureTable)
  
  output$ms1FeatureTableForAnnotation <- DT::renderDataTable(
    expr = ms1FeatureDf,
    server = FALSE, escape = FALSE, selection = "none",
    options = list(
      preDrawCallback = JS('function() { Shiny.unbindAll(this.api().table().node()); }'),
      drawCallback    = JS('function() { Shiny.bindAll(  this.api().table().node()); }')
    )
  )
}, ignoreNULL = FALSE)
plotMetaboliteFamilyVersusClass <- function(precursorSet){
  selectedClassifierClass <- isolate(input$metaboliteFamilyComparisonClass)
  
  addClassifierConsensusSpectrum <- FALSE
  if(exists("state_tabClassifier"))
    addClassifierConsensusSpectrum <- state_tabClassifier$classifierLoaded & selectedClassifierClass != selectionNone
  if(exists("state_tabClassifier")){
    returnObj <- metaboliteFamilyVersusClass(
      dataList = dataList, 
      precursorSet = precursorSet, 
      classToSpectra_class = classToSpectra_class, 
      properties_class = properties_class,
      classifierClass = selectedClassifierClass, 
      addClassifierConsensusSpectrum = addClassifierConsensusSpectrum, 
      mappingSpectraToClassDf = mappingSpectraToClassDf
    )
  } else {
    returnObj <- metaboliteFamilyVersusClass(
      dataList = dataList, 
      precursorSet = precursorSet, 
      classToSpectra_class = NULL, 
      properties_class = NULL,
      classifierClass = NULL, 
      addClassifierConsensusSpectrum = addClassifierConsensusSpectrum, 
      mappingSpectraToClassDf = NULL
    )
  }
  
  masses_spec     <- returnObj$masses_spec
  frequency_spec  <- returnObj$intensity_spec
  colors_spec     <- returnObj$colors_spec
  masses_class    <- returnObj$masses_class
  frequency_class <- returnObj$frequency_class
  colors_class    <- returnObj$colors_class
  
  fragmentMassesForFamily <<- unique(c(masses_spec, masses_class))
  
  min <- min(fragmentMassesForFamily)
  max <- max(fragmentMassesForFamily)
  fragmentPlot2Range$xMin <<- min
  fragmentPlot2Range$xMax <<- max
  fragmentPlot2Range$xInterval <<- c(min, max)
  fragmentPlot2Range$xIntervalSize <<- max - min
  
  output$fragmentPlot2 <- renderPlot({
    print(paste("### MS2 ### family init"))
    #plotFragments2(masses = masses_spec, numberOfFragments = frequency_spec, numberOfPrecursors = numberOfPrecursors, xInterval = fragmentPlot2Range$xInterval)
    #plotFragments2(dataList = dataList, xInterval = fragmentPlotRange$xInterval)
    #}, bg = "transparent")
    calcPlotSpectrumVsClass_big(
      masses_spec     = masses_spec, 
      intensity_spec  = frequency_spec, 
      colors_spec     = colors_spec, 
      masses_class    = masses_class, 
      frequency_class = frequency_class, 
      colors_class    = colors_class, 
      singleSpec      = FALSE,
      xInterval       = fragmentPlot2Range$xInterval
    )
  })
}

createMS1FeatureTable2 <- function(list){
  if(is.null(list$precursorSet))
    return(NULL)
  
  ## get (possibly truncated) data
  if(length(list$precursorSet) > maximumNumberOfTableEntries){
    precursorSet          <- list$precursorSet         [1:maximumNumberOfTableEntries]
    ms1abundanceDataFrame <- list$ms1abundanceDataFrame[1:maximumNumberOfTableEntries, , drop=FALSE]
    annotationDataFrame   <- list$annotationDataFrame  [1:maximumNumberOfTableEntries, , drop=FALSE]
    ms2fragmentDataFrame  <- list$ms2fragmentDataFrame [1:maximumNumberOfTableEntries, , drop=FALSE]
  } else {
    precursorSet          <- list$precursorSet
    ms1abundanceDataFrame <- list$ms1abundanceDataFrame
    annotationDataFrame   <- list$annotationDataFrame
    ms2fragmentDataFrame  <- list$ms2fragmentDataFrame
  }
  
  ## assemble
  dataFrame <<- cbind(
    #ms1abundanceDataFrame,
    annotationDataFrame
    #ms2fragmentDataFrame
  )
  
  return(dataFrame)
}

obsFragmentPlot2dblClick <- observeEvent(input$fragmentPlot2_dblclick, {
  brush <- isolate(input$fragmentPlot2_brush)
  print(paste("observe fragmentPlot2 dblclick"))#, paste(brush, collapse = "; ")))
  
  if (!is.null(brush)) {
    ## set range
    min <- brush$xmin
    max <- brush$xmax
  } else {
    ## reset range
    min <- min(fragmentMassesForFamily)
    max <- max(fragmentMassesForFamily)
  }
  
  fragmentPlot2Range$xMin <<- min
  fragmentPlot2Range$xMax <<- max
  fragmentPlot2Range$xInterval <<- c(min, max)
  fragmentPlot2Range$xIntervalSize <<- max - min
})
obsClassSelection <- observeEvent(input$metaboliteFamilyComparisonClass, {
  annotationIdx <- isolate(input$familySelectionTable_rows_selected)
  
  print(paste("Observe metaboliteFamilyComparisonClass", input$metaboliteFamilyComparisonClass, annotationIdx))
  if(is.null(annotationIdx))
    return()
  
  annotation <- allAnnotationNames[[annotationIdx]]
  precursorSet <- which(unlist(lapply(X = dataList$annoArrayOfLists, FUN = function(y){any(y==annotation)})))
  plotMetaboliteFamilyVersusClass(precursorSet)
})

obsSelectMetaboliteFamily <- observeEvent(input$selectMetaboliteFamily, {
  selectMetaboliteFamily <- as.numeric(input$selectMetaboliteFamily)
  print(paste("Observe selectMetaboliteFamily", selectMetaboliteFamily))
  
  ## TODO
  selectedAnnotationTableRowIdx <- isolate(input$familySelectionTable_rows_selected)
  annotationName  <- allAnnotationNames[[selectedAnnotationTableRowIdx]]
  
  annoThere <- lapply(X = dataList$annoArrayOfLists, FUN = function(x){ match(x = annotationName, table = x) })
  precursorSet <- which(!is.na(annoThere))
  
  #selectionBySearch(filterSearch$filter)
  
  #################################################
  ## update plots
  if(state$plotHcaShown){
    precursorSet <- intersect(precursorSet, filterHca$filter)
    selectionAnalysisTreeNodeSet <<- getSetOfSubTreesFromRootForPrecursorSet(dataList = dataList, precursorSet = precursorSet, filter = filterHca$filter, clusterDataList = clusterDataList)
    
    selectionByHca2(precursorSet)
    
    ## TODO remove plot call
    drawDendrogramPlot(consoleInfo = "annotation selection", withHeatmap = TRUE)
  }
  if(state$plotPcaShown){
    precursorSet <- intersect(precursorSet, filterPca$filter)
    selectionAnalysisPcaLoadingSet <<- which(filterPca$filter %in% precursorSet)
    selectionByPca2(precursorSet)
    
    ## TODO remove plot call
    drawPcaLoadingsPlot(consoleInfo = "PCA loadings click output$plotPcaLoadings")
  }
})
obsRenameMetaboliteFamily <- observeEvent(input$renameMetaboliteFamily, {
  renameMetaboliteFamily <- as.numeric(input$renameMetaboliteFamily)
  print(paste("Observe renameMetaboliteFamily", renameMetaboliteFamily))
  
  renameMetaboliteFamily()
})
obsRemoveMetaboliteFamily <- observeEvent(input$removeMetaboliteFamily, {
  removeMetaboliteFamily <- as.numeric(input$removeMetaboliteFamily)
  print(paste("Observe removeMetaboliteFamily", removeMetaboliteFamily))
  
  ## TODO
  selectedAnnotationTableRowIdx <- isolate(input$familySelectionTable_rows_selected)
  annotationName  <- allAnnotationNames[[selectedAnnotationTableRowIdx]]
  
  annoThere <- lapply(X = dataList$annoArrayOfLists, FUN = function(x){ match(x = annotationName, table = x) })
  precursorSet <- which(!is.na(annoThere))
  
  removeAnnotation(precursorSet = precursorSet, annotationValue = annotationName)
})

annotationDialogCounter2 <- 1
renameMetaboliteFamily <- function(){
  selectedAnnotationTableRowIdx <- isolate(input$familySelectionTable_rows_selected)
  annotationName  <- allAnnotationNames[[selectedAnnotationTableRowIdx]]
  annotationIdx   <- which(dataList$annoPresentAnnotationsList == annotationName)
  annotationColor <- dataList$annoPresentColorsList[[annotationIdx]]
  
  callbackFunction <- function(value, color){
    print(paste("Selected annotation properties:", value, color))
    removeModal(session = session)
    
    ## add
    renameAnnotation(annotationValueOld = annotationName, annotationColorOld = annotationColor, annotationValueNew = value, annotationColorNew = color)
    #selectRows(proxy = dataTableProxy(outputId = "familySelectionTable", session = session), selected = NULL)
  }
  
  openAnnotaionNameColorDialog(predefinedClassName = annotationName, predefinedClassColor = annotationColor, callbackFunction = callbackFunction, confirmButtonText = "Rename annotation")
}

annotationDialogCounter <- 1
openAnnotaionNameColorDialog <- function(predefinedClassName, predefinedClassColor = colorPalette()[[1]], callbackFunction, confirmButtonText = "Add new annotation"){
  
  itemIdValue  <- paste("newAnnotationValue3",  annotationDialogCounter, sep = "_")
  itemIdColor  <- paste("newAnnotationColor3",  annotationDialogCounter, sep = "_")
  itemIdButton <- paste("submitNewAnnotation3", annotationDialogCounter, sep = "_")
  
  modalDialog <- modalDialog(title = "Add new annotation", 
                             #HTML("huhu"),
                             h4("Please specifiy name and color of the new annotation"),
                             bsTooltip(id = itemIdValue, title = "The name of this annotation", placement = "bottom", trigger = "hover"),
                             textInput(inputId = itemIdValue, placeholder = 'Metabolite family name here', label = "Type new annotation", value = predefinedClassName),
                             bsTooltip(id = itemIdColor, title = "The color of this annotation", placement = "bottom", trigger = "hover"),
                             colourInput(inputId = itemIdColor, label = "Select annotation color", palette = "limited", showColour = "background", allowedCols = colorPalette(), value = predefinedClassColor),
                             bsTooltip(id = itemIdButton, title = "Adds this annotation to the set of selected MS\u00B9 features", placement = "bottom", trigger = "hover"),
                             actionButton(inputId = itemIdButton, label = confirmButtonText, class="btn-success")
  )
  
  lapply(c(itemIdButton), function(buttonId){
    observeEvent(input[[buttonId]], {
      value <- input[[itemIdValue]]
      color <- input[[itemIdColor]]
      
      callbackFunction(value, color)
    })
  })
  
  showUiDialog(modalDialog)
  
  annotationDialogCounter <<- annotationDialogCounter + 1
}


output$metaboliteFamilySelected <- reactive({
  print(paste("reactive update metaboliteFamilySelected", state_tabAnnotation$metaboliteFamilySelected))
  return(state_tabAnnotation$metaboliteFamilySelected)
})

outputOptions(output, 'metaboliteFamilySelected',suspendWhenHidden=FALSE)


suspendOnExitFunctions <- c(suspendOnExitFunctions, function(){
  print("Suspending tabAnnotation observers")
  obsFamilySelectionTable_rows_selected$suspend()
  obsFragmentPlot2dblClick$suspend()
  obsClassSelection$suspend()
  obsSelectMetaboliteFamily$suspend()
  obsRenameMetaboliteFamily$suspend()
  obsRemoveMetaboliteFamily$suspend()
})

================
File: inst/MetFamily/app_files/server_guiTabClassifier.R
================
## classifier annotation
availableClassifiersDf <- NULL
availableClassifiersDfProperties <- NULL
classToSpectra_class <- NULL
mappingSpectraToClassDf <- NULL
properties_class <- NULL
selectedClassPrecursorIndeces <- NULL
selectedClassRowIdx <- -1
selectedClassFeatureRowIdx <- -1

putativeAnnotationsResultTableClassInputFieldIdCounter <- 1

specVsClassRange     <- reactiveValues(xMin = NULL, xMax = NULL, xInterval = NULL, xIntervalSize = NULL)
ms1FeatureVsClassTableCounter <- 0

state_tabClassifier <- reactiveValues(
  classifierLoaded = FALSE,
  classifierClassSelected = FALSE,
  classifierClassMS1featureSelected = FALSE
)
resetWorkspaceFunctions <- c(resetWorkspaceFunctions, function(){
  print("Reset tabClassifier state")
  state_tabClassifier$classifierLoaded <<- FALSE
  state_tabClassifier$classifierClassSelected <<- FALSE
  state_tabClassifier$classifierClassMS1featureSelected <<- FALSE
  
  ## reset plot range
  specVsClassRange$xMin <<- NULL
  specVsClassRange$xMax <<- NULL
  
  ## classifier annotation
  classToSpectra_class <<- NULL
  mappingSpectraToClassDf <<- NULL
  properties_class <<- NULL
  selectedClassPrecursorIndeces <<- NULL
  selectedClassRowIdx <<- -1
  selectedClassFeatureRowIdx <<- -1
})

obsClassifierSelectionTable_rows_selected <- observeEvent(eventExpr = input$classifierSelectionTable_rows_selected, handlerExpr = {
  print(paste("Observe classifierSelectionTable_rows_selected", input$classifierSelectionTable_rows_selected))
  if(is.null(input$classifierSelectionTable_rows_selected)){
    session$sendCustomMessage("disableButton", "doAnnotation")
  } else {
    session$sendCustomMessage("enableButton", "doAnnotation")
  }
}, ignoreNULL = FALSE)
loadClassifier <- function(){
  #################################################
  ## do 999
  selectedRow <- isolate(expr = input$classifierSelectionTable_rows_selected)
  #if(is.null(selectedRow))
  #  selectedRow <- 1
  
  #selectedFile <- rownames(availableClassifiersDf)[[selectedRow]]
  #classifierProperties <- availableClassifiersDfProperties[selectedRow]
  filePath <- availableClassifiersDfProperties[selectedRow, "FilePath"]
  #method   <- availableClassifiersDfProperties[selectedRow, "algoName"]
  propertiesList <- as.list(availableClassifiersDfProperties[selectedRow,])
  
  withProgress(message = 'Calculating cluster...', value = 0, {
    resultObj <- doAnnotation(filePath, propertiesList, dataList$featureMatrix, dataList$importParameterSet, progress = TRUE)
  })
  
  classToSpectra_class    <<- resultObj$classToSpectra_class
  properties_class        <<- resultObj$properties_class
  mappingSpectraToClassDf <<- resultObj$mappingSpectraToClassDf
  state_tabClassifier$classifierLoaded <<- TRUE
  updateSelectInput(session = session, inputId = "metaboliteFamilyComparisonClass", choices = c(selectionNone, names(classToSpectra_class)), selected = selectionNone)
}
obsDoAnnotation <- observeEvent(input$doAnnotation, {
  session$sendCustomMessage("disableButton", "doAnnotation")
  doAnnotation <- as.numeric(input$doAnnotation)
  print(paste("Observe doAnnotation", doAnnotation))
  
  #################################################
  ## check if button was hit
  #if(doAnnotation == doAnnotationButtonValue)
  #  return()
  #doAnnotationButtonValue <<- doAnnotation
  
  loadClassifier()
  
  ## order by pValue
  bestPValues <- sapply(X = classToSpectra_class, FUN = head, n=1)
  
  if(FALSE){
    ## order by pValue
    order <- order(bestPValues, decreasing = F)
    classToSpectra_class <- classToSpectra_class[order]
    bestPValues          <- bestPValues[order]
    
    classToSpectra_class <<- classToSpectra_class
  }
  
  if(length(classToSpectra_class) == 0){
    output$noAnnotationsPopupDialog <- renderUI({
      bsModal(id = "noAnnotationsPopupDialog", title = "No annotations detected", trigger = "", size = "large",
              HTML("No MS\u00B9 feature could be annotated with one or more metabolite families.")
      )
    })
    toggleModal(session = session, modalId = "noAnnotationsPopupDialog", toggle = "open")
    
    return()
  }
  
  bestPValues <- format(bestPValues, digits=4)
  numPValues  <- sapply(X = classToSpectra_class, FUN = length)
  classes     <- names(classToSpectra_class)
  
  classesShort  <- classes
  
  chemOntClassNodeRegEx <- "[- ,/'0-9a-zA-Z]+"
  chemOntClassRegEx <- paste("^(", chemOntClassNodeRegEx, "; )*(", chemOntClassNodeRegEx, ")$", sep = "")
  
  ## shrink class names of the form "Organic compounds; Benzenoids; Benzene and substituted derivatives; Benzoic acids and derivatives; Halobenzoic acids and derivatives; 2-halobenzoic acids and derivatives"
  if(all(grepl(x = classes, pattern = chemOntClassRegEx))){
    maxLength <- 70
    tokenSeparator <- "; "
    abbreviator <- "."
    abbrevAbbrevs <- FALSE
    abbrevEndClass <- FALSE
    classesShort  <- sapply(X = seq_along(classes), FUN = function(x){
      len <- nchar(classes[[x]])
      if(len > maxLength){
        tokens   <- str_split(string = classes[[x]], pattern = tokenSeparator)[[1]]
        #abbrev   <- seq(from = 3+3+2, by = 3+3+2, length.out = length(tokens))
        abbrev   <- rep(3+3+2, times = length(tokens))
        noAbbrev <- nchar(tokens) + 2
        lengths  <- sapply(X = seq_len(length(tokens) - 1), FUN = function(y){
          sum(c(abbrev[1:y], noAbbrev[(y + 1):length(tokens)]))
        })
        if((lengths[[length(tokens) - 1]] > maxLength) & abbrevAbbrevs){
          if((3+3+3+1+2+nchar(tokens[[length(tokens)]]) > maxLength) & abbrevEndClass){
            classShort <- paste(c(
              paste(substr(x = c(tokens[[1]], tokens[[length(tokens) - 1]]), start = 1, stop = 3), abbreviator, sep = "", collapse = ".."), 
              paste("...", substr(x = tokens[[length(tokens)]], start = nchar(tokens[[length(tokens)]]) - (maxLength - (3+3+3+1+2+3) - 1), stop = nchar(tokens[[length(tokens)]])), sep = "")), 
              collapse = tokenSeparator)
          } else {
            classShort <- paste(c(
              paste(substr(x = c(tokens[[1]], tokens[[length(tokens) - 1]]), start = 1, stop = 3), abbreviator, sep = "", collapse = ".."), 
              tokens[[length(tokens)]]), 
              collapse = tokenSeparator)
          }
        } else {
          maxIdxToAbbrev <- ifelse(test = lengths[[length(tokens) - 1]] > maxLength, yes = length(tokens) - 1, no = min(which(lengths <= maxLength)))
          classShort <- paste(c(
            paste(substr(x = tokens[1:maxIdxToAbbrev], start = 1, stop = 3), abbreviator, sep = "", collapse = ""), 
            tokens[(maxIdxToAbbrev + 1):length(tokens)]), 
            collapse = tokenSeparator)
        }
      } else {
        classShort <- classes[[x]]
      }
      return(classShort)
    })
  }
  
  ## annotation column
  type <- "PutativeAnnotationsResultTableClass"
  annotateColumn <- createActionButtonInputFields(
    FUN = actionButton,  id = paste(type, "Annotate", sep = "_"), itemCount=length(classesShort), 
    label   = "Annotate", tableCounter = putativeAnnotationsResultTableClassInputFieldIdCounter, 
    callFunction = putativeAnnotationsResultTableClassAnnotateClicked
  )
  putativeAnnotationsResultTableClassInputFieldIdCounter <<- putativeAnnotationsResultTableClassInputFieldIdCounter + 1
  
  
  resultTable_classes <- data.frame(
    "Class"       = classesShort, 
    "Hits"        = numPValues,
    "Best pValue" = bestPValues,
    "Annotate"    = annotateColumn
    #row.names = rep("")
  )
  
  output$familyCount <- renderText({
    print(paste("init output$familyCount"))
    paste("Number of putative metabolite families: ", nrow(resultTable_classes),
          "\nNumber of putatively annotated features: ", length(unique(unlist(lapply(X = classToSpectra_class, FUN = names)))), " / ", dataList$numberOfPrecursors, 
          sep = "")
  })
  
  #selected <- ifelse(test = nrow(resultTable_classes) > 0, yes = 1, no = NULL)
  output$annotationResultTableClass <- DT::renderDataTable(
    expr = resultTable_classes,
    server = FALSE, escape = FALSE, rownames = FALSE,
    selection = list(mode = "single"),#, selected = selected), 
    options = list(
      #scrollY = "600px",
      scrollY = "30vh",
      preDrawCallback = JS('function() { Shiny.unbindAll(this.api().table().node()); }'),
      drawCallback    = JS('function() { Shiny.bindAll(  this.api().table().node()); }'),
      #rowCallback = JS(
      #  "function(nRow, aData, iDisplayIndex, iDisplayIndexFull) {",
      #  "var full_text = classes[[nRow]]",
      #  "$('td:eq(1)', nRow).attr('title', full_text);",
      #  "}"),
      iDisplayLength=nrow(resultTable_classes),       # initial number of records
      #aLengthMenu = c(5,10),    # records/page options
      #bLengthChange =0,        # show/hide records per page dropdown
      #bFilter = 0,              # global search box on/off
      #bInfo = 0,                # information on/off (how many records filtered, etc)
      #bAutoWidth = 0,           # automatic column width calculation, disable if passing column width via aoColumnDefs
      #aoColumnDefs = list(list(sWidth="300px", aTargets=c(list(0),list(1))))    # custom column size
      ordering = F,              # row ordering
      sDom  = 'ft'
      #sDom  = '<"top">rt<"bottom">ip'
    )
  )
  
  ## state
  state$showAnnotationplotPanel <<- TRUE
  state$plotAnnotationShown <<- TRUE
  updateChangePlotRadioButton()
  
  #if(nrow(resultTable_classes) > 0)
  #  classSelected(1)
  
  session$sendCustomMessage("enableButton", "doAnnotation")
})
putativeAnnotationsResultTableClassAnnotateClicked <- function(buttonId){
  ## PutativeAnnotationsResultTableClass_Annotate_0_1
  rowIdx    <- as.integer(strsplit(x = buttonId, split = "_")[[1]][[4]])
  
  
  #selectedRow <- isolate(input$annotationResultTableClass_rows_selected)
  #print("#####")
  #print(selectedRow)
  #print(rowIdx)
  #if(length(selectedRow) == 0)
  #  selectRows(proxy = dataTableProxy("annotationResultTableClass"), selected = rowIdx)
  #else
  #  selectRows(proxy = dataTableProxy("annotationResultTableClass"), selected = NULL)
  
  
  precursorSet <- as.integer(names(classToSpectra_class[[rowIdx]]))
  class <- names(classToSpectra_class)[[rowIdx]]
  
  subClass <- tail(x = strsplit(x = class, split = "; ")[[1]], n = 1)
  print(paste(length(precursorSet), "-->", class, "(", subClass, ")", "from row", rowIdx))
  
  callbackFunction <- function(value, color){
    print(paste(length(precursorSet), "-->", class, "from row", rowIdx, "-->", value, color))
    removeModal(session = session)
    
    ## add
    addAnnotation(precursorSet = precursorSet, annotationValue = value, annotationColor = color)
  }
  
  openAnnotaionNameColorDialog(predefinedClassName = subClass, callbackFunction = callbackFunction)
}

obsAnnotationResultTableClass_selection <- observeEvent(ignoreNULL = FALSE, eventExpr = input$annotationResultTableClass_rows_selected, handlerExpr = {
  selectedRowIdx <- input$annotationResultTableClass_rows_selected
  print(paste("Selected class row:", selectedRowIdx))
  if(is.null(selectedRowIdx) && !initialGuiUpdatePerformed) return()
  
  if(is.null(selectedRowIdx)){
    state_tabClassifier$classifierClassSelected <<- FALSE
    return()
  }
  
  selectedClassRowIdx <<- selectedRowIdx
  state_tabClassifier$classifierClassSelected <<- TRUE
  
  classSelected(selectedRowIdx)
})
classSelected <- function(selectedRowIdx){
  ms1FeatureVsClassTableCounter <<- ms1FeatureVsClassTableCounter + 1
  
  #"classifierName",          #: chr "library=MoNA-export-LC-MS_-_MSMS_-_Negative.msp_Class=ChemOnt_SubstanceClass_AltSC=TRUE_method=ColSums_smoothIntensities=FALSE"
  #"numberOfSpectra",         #: int 1355
  #"numberOfPositiveSpectra", #: int 20
  #"numberOfNegativeSpectra", #: int 1335
  #"class",                   #: chr "Organic compounds; Alkaloids and derivatives"
  #"fragmentMasses",          #: num [1:12207] -970 -969 -965 -965 -963 ...
  #"classOfClass",            #: chr "ChemOnt_SubstanceClass"
  #"frequentFragments",       #: Named num [1:29] 0.571 0.286 0.214 0.214 0.214 ...
  #"characteristicFragments", #: Named num [1:28] 0.539 0.275 0.203 0.203 0.143 ...
  #"AUC"                      #: num 0.912
  #"algoName"
  #"methodName"
  #"paramsString"
  
  classProperties         <- properties_class[[selectedRowIdx]]
  frequentFragments       <- classProperties$frequentFragments
  characteristicFragments <- classProperties$characteristicFragments
  
  class     <- names(classToSpectra_class)[[selectedRowIdx]]
  classToSpectra <- classToSpectra_class[[selectedRowIdx]]
  
  precursorIndecesAll <- as.integer(names(classToSpectra))
  pValuesAll <- format(unname(classToSpectra), digits=4)
  precursorIndeces <- precursorIndecesAll
  pValues <- pValuesAll
  
  maximumNumberOfDisplayedSpectrumHits <- 100
  if(length(precursorIndecesAll) > maximumNumberOfDisplayedSpectrumHits){
    precursorIndeces <- precursorIndeces[seq_len(maximumNumberOfDisplayedSpectrumHits)]
    pValues          <- pValues         [seq_len(maximumNumberOfDisplayedSpectrumHits)]
  }
  
  precursorLabels <- dataList$precursorLabels[precursorIndeces]
  selectedClassPrecursorIndeces <<- precursorIndeces
  
  
  output$classToSpectraCount <- renderText({
    print(paste("init output$classToSpectraCount"))
    paste("Number of putatively annotated features: ", ifelse(test = length(precursorIndecesAll) > maximumNumberOfDisplayedSpectrumHits, yes = paste(length(precursorIndeces), "/", length(precursorIndecesAll), sep = ""), no = length(precursorIndecesAll)),
          "\nEstimated true positive rate: ", format(classProperties$TPR_for_FPR_of_5Percent, digits=4), sep = "")
  })
  
  numberOfMatchingMasses_i <- getNumberOfHits(dataList, frequentFragments, characteristicFragments, precursorIndeces, mappingSpectraToClassDf, properties_class)
  
  returnObj <- createPlotOutput(
    dataList = dataList,
    id = "plotSpectrumVsClass", 
    frequentFragments = frequentFragments, 
    characteristicFragments = characteristicFragments, 
    precursorIndeces = precursorIndeces, 
    tableCounter = ms1FeatureVsClassTableCounter,
    mappingSpectraToClassDf = mappingSpectraToClassDf
  )
  
  numberOfMatchingMasses_i <- returnObj$numberOfMatchingMasses_i
  #inputs_i <- returnObj$inputs_i
  
  checkboxes   <- createCheckboxInputFields2(
    FUN = checkboxInput, 
    id = "MS1_feature_confirm", 
    values = rep(x = FALSE, times = length(precursorIndeces)), 
    tableCounter = ms1FeatureVsClassTableCounter,
    triggerSampleExclusionClick = FALSE
  )
  
  resultTable_features <- data.frame(check.names = FALSE,
                                     "Mz/RT"    = precursorLabels,
                                     "pValue"   = pValues,
                                     "Hits"     = numberOfMatchingMasses_i,
                                     "Confirm"  = checkboxes#,
                                     #"Spectrum" = inputs_i
  )
  selected <- ifelse(test = nrow(resultTable_features) > 0, yes = 1, no = NULL)
  output$annotationResultTableFeature <- DT::renderDataTable(
    expr = resultTable_features,
    server = FALSE, escape = FALSE, rownames = FALSE,
    selection = list(mode = "single"),#, selected = selected), 
    options = list(
      #scrollY = "600px",
      scrollY = "30vh",
      preDrawCallback = JS('function() { Shiny.unbindAll(this.api().table().node()); }'),
      drawCallback    = JS('function() { Shiny.bindAll(  this.api().table().node()); }'),
      #rowCallback = JS(
      #  "function(nRow, aData, iDisplayIndex, iDisplayIndexFull) {",
      #  "var full_text = classes[[nRow]]",
      #  "$('td:eq(1)', nRow).attr('title', full_text);",
      #  "}"),
      #selection = 'single',      # single row selection
      iDisplayLength=nrow(resultTable_features),       # initial number of records
      #aLengthMenu = c(5,10),    # records/page options
      #bLengthChange =0,        # show/hide records per page dropdown
      #bFilter = 0,              # global search box on/off
      #bInfo = 0,                # information on/off (how many records filtered, etc)
      #bAutoWidth = 0,           # automatic column width calculation, disable if passing column width via aoColumnDefs
      #aoColumnDefs = list(list(sWidth="300px", aTargets=c(list(0),list(1))))    # custom column size
      autoWidth = TRUE,
      #columnDefs = list(list(width = '45px', targets = c(0,1,2))),#, list(width = '20px', targets = c(1))),
      columnDefs = list(
        list(width = '45px', targets = c(0)), 
        list(width = '20px', targets = c(1,2)),
        list(width = '15px', targets = c(3))
      ),
      ordering = F,              # row ordering
      sDom  = 't'
      #sDom  = '<"top">rt<"bottom">ip'
    )
  )
  
  ## update default class name for annotation
  #class <- names(classToSpectra_class)[[selectedClassRowIdx]]
  subClass <- tail(x = strsplit(x = class, split = "; ")[[1]], n = 1)
  updateTextInput(session = session, inputId = "newAnnotationValue2", value = subClass)
}
obsAnnotationResultTableFeature_selection <- observeEvent(ignoreNULL = FALSE, eventExpr = input$annotationResultTableFeature_rows_selected, handlerExpr = {
  selectedRowIdx <- input$annotationResultTableFeature_rows_selected
  print(paste("Selected feature row:", selectedRowIdx))
  
  if(is.null(selectedRowIdx)){
    state_tabClassifier$classifierClassMS1featureSelected <<- FALSE
    return()
  }
  
  selectedClassFeatureRowIdx <<- selectedRowIdx
  state_tabClassifier$classifierClassMS1featureSelected <<- TRUE
  
  classMS1FeatureSelected(selectedRowIdx)
})
classMS1FeatureSelected <- function(selectedRowIdx){
  classProperties         <- properties_class[[selectedClassRowIdx]]
  frequentFragments       <- classProperties$frequentFragments
  characteristicFragments <- classProperties$characteristicFragments
  
  precursorIndex = selectedClassPrecursorIndeces[[selectedRowIdx]]
  
  resetMS2VsClassPlotRange()
  
  drawMS2vsClassPlot(
    consoleInfo = "Feature selected", 
    frequentFragments=frequentFragments, 
    characteristicFragments=characteristicFragments, 
    precursorIndex=precursorIndex,
    mappingSpectraToClassDf=mappingSpectraToClassDf
  )
}
drawMS2vsClassPlot <- function(consoleInfo = NULL, frequentFragments, characteristicFragments, precursorIndex, mappingSpectraToClassDf){
  output$plotMS2vsClass <- renderPlot({
    print(paste("### SvC ###", consoleInfo))
    drawMS2vsClassPlotImpl(
      dataList=dataList,
      frequentFragments=frequentFragments, 
      characteristicFragments=characteristicFragments, 
      precursorIndex=precursorIndex,
      mappingSpectraToClassDf=mappingSpectraToClassDf
    )
  })
}
drawMS2vsClassPlotImpl <- function(dataList, frequentFragments, characteristicFragments, precursorIndex, mappingSpectraToClassDf){
  ## class statistics for class plot
  returnObj <- preprocessClassPlot(frequentFragments, characteristicFragments)
  masses_class    <- returnObj$masses_class
  frequency_class <- returnObj$frequency_class
  colors_class    <- returnObj$colors_class
  
  ## match spectrum masses for spectrum plot
  returnObj <- preprocessSpectrumVsClassPlot(dataList, precursorIndex, masses_class, mappingSpectraToClassDf, "Intensity")
  masses_spec     <- returnObj$masses_spec
  intensity_spec  <- returnObj$intensity_spec
  colors_spec     <- returnObj$colors_spec
  #numberOfMatchingMasses <- returnObj$numberOfMatchingMasses
  
  #xInterval <- c(dataList$minimumMass, dataList$maximumMass)
  
  calcPlotSpectrumVsClass_big(
    masses_spec    = masses_spec, 
    intensity_spec = intensity_spec, 
    colors_spec    = colors_spec, 
    masses_class   = masses_class, 
    frequency_class= frequency_class, 
    colors_class   = colors_class, 
    singleSpec     = TRUE,
    xInterval      = specVsClassRange$xInterval
  )
}
## plot range resets
resetMS2VsClassPlotRange <- function(){
  specVsClassRange$xMin <<- dataList$minimumMass
  specVsClassRange$xMax <<- dataList$maximumMass
  specVsClassRange$xInterval <<- c(dataList$minimumMass, dataList$maximumMass)
  specVsClassRange$xIntervalSize <<- dataList$maximumMass - dataList$minimumMass
}

obsApplyConfirmedAnnotations <- observeEvent(input$confirmAnnotation, {
  confirmAnnotation <- as.numeric(input$confirmAnnotation)
  
  #################################################
  ## check if button was hit
  #if(confirmAnnotation == confirmAnnotationButtonValue)
  #  return()
  #confirmAnnotationButtonValue <<- confirmAnnotation
  
  value <- input$newAnnotationValue2
  color <- input$newAnnotationColor2
  
  ## fetch data
  confirm <- getInputValues(id = paste("MS1_feature_confirm", sep = "_"), counter = ms1FeatureVsClassTableCounter, len = length(selectedClassPrecursorIndeces))
  precursorIndeces <- selectedClassPrecursorIndeces[confirm]
  print(paste("Annotate: Class ", value, " to ", length(precursorIndeces), " precursors (", paste(precursorIndeces, collapse = ", "), ")", sep = ""))
  
  ## apply annotation and update
  addAnnotation(precursorSet = precursorIndeces, annotationValue = value, annotationColor = color)
  ## updates e.g. plots automatically
})
obsToggleConfirmAnnoButton <- observeEvent(input$newAnnotationValue2, {
  value <- input$newAnnotationValue2
  
  print(paste("Observe newAnnotationValue2", nchar(value)))
  
  if(nchar(value) > 0)
    shinyjs::enable("confirmAnnotation")
  else
    shinyjs::disable("confirmAnnotation")
})

obsMS2VsClassdblClick <- observeEvent(input$plotMS2vsClass_dblclick, {
  brush <- input$plotMS2vsClass_brush
  print(paste("observe MS2vsClass dblclick", is.null(brush)))
  
  if (!is.null(brush)) {
    ## set range
    specVsClassRange$xMin <<- brush$xmin
    specVsClassRange$xMax <<- brush$xmax
    specVsClassRange$xInterval <<- c(brush$xmin, brush$xmax)
    specVsClassRange$xIntervalSize <<- brush$xmax - brush$xmin
  } else {
    ## reset range
    resetMS2VsClassPlotRange()
  }
})

suspendOnExitFunctions <- c(suspendOnExitFunctions, function(){
  print("Suspending tabClassifier observers")
  obsClassifierSelectionTable_rows_selected$suspend()
  obsDoAnnotation$suspend()
  obsAnnotationResultTableClass_selection$suspend()
  obsAnnotationResultTableFeature_selection$suspend()
  obsApplyConfirmedAnnotations$suspend()
  obsToggleConfirmAnnoButton$suspend()
  obsMS2VsClassdblClick$suspend()
})

output$classifierLoaded <- reactive({
  print(paste("reactive update classifierLoaded", state_tabClassifier$classifierLoaded))
  return(state_tabClassifier$classifierLoaded)
})
output$classifierClassSelected <- reactive({
  print(paste("reactive update classifierClassSelected", state_tabClassifier$classifierClassSelected))
  return(state_tabClassifier$classifierClassSelected)
})
output$classifierClassMS1featureSelected <- reactive({
  print(paste("reactive update classifierClassMS1featureSelected", state_tabClassifier$classifierClassMS1featureSelected))
  return(state_tabClassifier$classifierClassMS1featureSelected)
})
outputOptions(output, 'classifierLoaded',        suspendWhenHidden=FALSE)
outputOptions(output, 'classifierClassSelected', suspendWhenHidden=FALSE)
outputOptions(output, 'classifierClassMS1featureSelected',  suspendWhenHidden=FALSE)

================
File: inst/MetFamily/app_files/server_guiTabExport.R
================
resetWorkspaceFunctions <- c(resetWorkspaceFunctions, function(){
  print("Reset tabProject state")
  ## gui input fields
  shinyjs::toggleState("minimumIntensityOfMaximalMS2peak2", FALSE)
  shinyjs::toggleState("minimumProportionOfMS2peaks2", FALSE)
  shinyjs::toggleState("mzDeviationAbsolute_grouping2", FALSE)
  shinyjs::toggleState("mzDeviationInPPM_grouping2", FALSE)
  shinyjs::toggleState("doPrecursorDeisotoping2", FALSE)
  shinyjs::toggleState("mzDeviationAbsolute_precursorDeisotoping2", FALSE)
  shinyjs::toggleState("mzDeviationInPPM_precursorDeisotoping2", FALSE)
  shinyjs::toggleState("maximumRtDifference2", FALSE)
  shinyjs::toggleState("doMs2PeakGroupDeisotoping2", FALSE)
  shinyjs::toggleState("mzDeviationAbsolute_ms2PeakGroupDeisotoping2", FALSE)
  shinyjs::toggleState("mzDeviationInPPM_ms2PeakGroupDeisotoping2", FALSE)
  shinyjs::toggleState("neutralLossesPrecursorToFragments2", FALSE)
  shinyjs::toggleState("neutralLossesFragmentsToFragments2", FALSE)
  
  ## project infos
  updateTextInput    (session = session, inputId = "projectName2",           value = dataList$importParameterSet$projectName)
  shinyjs::toggleState("projectName2", FALSE)
  updateTextInput    (session = session, inputId = "projectDescription2",    value = dataList$importParameterSet$projectDescription)
  
  updateTextInput    (session = session, inputId = "minimumIntensityOfMaximalMS2peak2",            value = dataList$importParameterSet$minimumIntensityOfMaximalMS2peak)
  updateTextInput    (session = session, inputId = "minimumProportionOfMS2peaks2",                 value = dataList$importParameterSet$minimumProportionOfMS2peaks)
  updateTextInput    (session = session, inputId = "mzDeviationAbsolute_grouping2",                value = dataList$importParameterSet$mzDeviationAbsolute_grouping)
  updateTextInput    (session = session, inputId = "mzDeviationInPPM_grouping2",                   value = dataList$importParameterSet$mzDeviationInPPM_grouping)
  updateCheckboxInput(session = session, inputId = "doPrecursorDeisotoping2",                      value = dataList$importParameterSet$doPrecursorDeisotoping)
  updateTextInput    (session = session, inputId = "mzDeviationAbsolute_precursorDeisotoping2",    value = dataList$importParameterSet$mzDeviationAbsolute_precursorDeisotoping)
  updateTextInput    (session = session, inputId = "mzDeviationInPPM_precursorDeisotoping2",       value = dataList$importParameterSet$mzDeviationInPPM_precursorDeisotoping)
  updateTextInput    (session = session, inputId = "maximumRtDifference2",                         value = dataList$importParameterSet$maximumRtDifference)
  updateCheckboxInput(session = session, inputId = "doMs2PeakGroupDeisotoping2",                   value = dataList$importParameterSet$doMs2PeakGroupDeisotoping)
  updateTextInput    (session = session, inputId = "mzDeviationAbsolute_ms2PeakGroupDeisotoping2", value = dataList$importParameterSet$mzDeviationAbsolute_ms2PeakGroupDeisotoping)
  updateTextInput    (session = session, inputId = "mzDeviationInPPM_ms2PeakGroupDeisotoping2",    value = dataList$importParameterSet$mzDeviationInPPM_ms2PeakGroupDeisotoping)
  #dataList$importParameterSet$proportionOfMatchingPeaks_ms2PeakGroupDeisotoping
  #dataList$importParameterSet$mzDeviationAbsolute_mapping
  #dataList$importParameterSet$minimumNumberOfMS2PeaksPerGroup
  updateCheckboxInput(session = session, inputId = "neutralLossesPrecursorToFragments2",           value = dataList$importParameterSet$neutralLossesPrecursorToFragments)
  updateCheckboxInput(session = session, inputId = "neutralLossesFragmentsToFragments2",           value = dataList$importParameterSet$neutralLossesFragmentsToFragments)
})

obsUpdateProjectDescription <- observeEvent(input$updateProjectDescription, {
  session$sendCustomMessage("disableButton", "updateProjectDescription")
  updateProjectDescription <- as.numeric(input$updateProjectDescription)
  
  print(paste("Observe updateProjectDescription", updateProjectDescription))
  
  #################################################
  ## check if button was hit
  #if(updateProjectDescription == updateProjectDescriptionButtonValue)
  #  return()
  #updateProjectDescriptionButtonValue <<- updateProjectDescription
  
  projectDescription <- input$projectDescription2
  projectDescription <- gsub(";", "_", gsub(",", "_", gsub("\t", "_", projectDescription)))
  dataList$importParameterSet$projectDescription <<- projectDescription
  session$sendCustomMessage("enableButton", "updateProjectDescription")
})

## export image buttons
obsShowHCAplotPanel <- observe({
  print(paste("observe state$showHCAplotPanel", state$showHCAplotPanel))
  
  if(state$showHCAplotPanel){
    shinyjs::enable("downloadHcaImage")
  } else {
    shinyjs::disable("downloadHcaImage")
  }
})
obsShowPCAplotPanel <- observe({
  print(paste("observe state$showPCAplotPanel", state$showPCAplotPanel))
  
  if(state$showPCAplotPanel){
    shinyjs::enable("downloadPcaImage")
  } else {
    shinyjs::disable("downloadPcaImage")
  }
})

suspendOnExitFunctions <- c(suspendOnExitFunctions, function(){
  print("Suspending tabExport observers")
  obsShowHCAplotPanel$suspend()
  obsShowPCAplotPanel$suspend()
})

================
File: inst/MetFamily/app_files/server_guiTabHca.R
================
## HCA constants
minimumNumberOfPrecursorsForHca <- 6
maximumNumberOfPrecursorsForHca <- 5000
minimumNumberOfPrecursorsForDendrogramStatistics <- 2

minimumheatmapHeightPerRow <- 11
maximumheatmapHeightPerRow <- 25
minimumheatmapHeightRowCount <- 10
maximumheatmapHeightRowCount <- 3

currentDistanceMatrixObj <- NULL
clusterDataList <- NULL
columnsOfInterestForHeatmap <- NULL

dendrogramUserCoordinateRangeY <- NULL
dendrogramPlotRange  <- reactiveValues(
  xMin = NULL, 
  xMax = NULL, 
  xInterval = NULL, 
  xIntervalSize = NULL
)

## plotly dendrogram
curveNumberToCurveName <- NULL

## classifier table for dendrogram node
putativeAnnotationsTableFromAnalysisInputFieldIdCounter <- 0
putativeAnnotationsTableFromAnalysisCurrentlyShown <- NULL

## statistics for dendrogram node or pca loadings brush
dendrogramFragmentStatistics <- FALSE

state_tabHca <- reactiveValues(
  ## plot dimensions
  #dendrogramHeatmapHeight = 1,#heatmapHeightPerRow * 3,
  heatmapHeight = 1,#heatmapHeightPerRow * 3,## plotly: remove
  ## plot controls
  showClusterLabels = TRUE,
  heatmapContent = "Log-fold-change",
  heatmapOrdering = "Specified order",
  hcaPrecursorLabels = "m/z / RT",
  ## plot annotations: $setOfAnnotations, $setOfColors
  annotationsHca = NULL,
  ## annotation legend height
  annotationLegendHeightHca = -1
)
resetWorkspaceFunctions <- c(resetWorkspaceFunctions, function(){
  print("Reset tabHca state")
  state_tabHca$heatmapHeight <<- 1#heatmapHeightPerRow * 3,## plotly: remove
  ## plot controls
  state_tabHca$showClusterLabels <<- TRUE
  state_tabHca$heatmapContent <<- "Log-fold-change"
  state_tabHca$heatmapOrdering <<- "Specified order"
  state_tabHca$hcaPrecursorLabels <<- "m/z / RT"
  ## plot annotations: $setOfAnnotations, $setOfColors
  state_tabHca$annotationsHca <<- NULL
  ## annotation legend height
  state_tabHca$annotationLegendHeightHca <<- -1
  
  ## reset variables
  clusterDataList <<- NULL
  columnsOfInterestForHeatmap <<- NULL
  dendrogramFragmentStatistics <<- FALSE
  
  ## reset plot range
  dendrogramPlotRangeY <<- NULL
  dendrogramPlotRange$xMin <<- NULL
  dendrogramPlotRange$xMax <<- NULL
  dendrogramPlotRange$xInterval <<- NULL
  dendrogramPlotRange$xIntervalSize <<- NULL
  
  ## plotly dendrogram
  curveNumberToCurveName <<- NULL
  
  ## classifier table for dendrogram node
  putativeAnnotationsTableFromAnalysisCurrentlyShown <<- NULL
})


drawDendrogramPlot <- function(consoleInfo = NULL, withHeatmap = FALSE){
  output$plotDendrogram <- renderPlot({
    #output$plotDendrogram <- renderPlotly({
    print(paste("### den ###", consoleInfo))
    drawDendrogramPlotImpl()
  })
  
  if(!withHeatmap)
    return()
  
  ## plotly: remove
  output$plotHeatmap <- renderPlot({
    print(paste("### hea ### update range output$plotHeatmap"))
    drawHeatmapPlotImpl()
  })
}
drawDendrogramPlotImpl_forPlotly <- function(){
  heatmapContent <- state_tabHca$heatmapContent
  
  ## heatmap
  numberOfGroups <- -1
  switch(heatmapContent,
         "Log-fold-change"={## log-fold-change
           numberOfGroups <- 3
         },
         "Abundance by group"={## groups
           numberOfGroups <- length(dataList$grouXXXps)
         },
         "Abundance by sample"={## samples
           numberOfGroups <- length(dataList$dataColumnsNameFunctionFromGroupNames(grouXXXps = grouXXXps, sampleNamesToExclude = dataList$excludedSamples(dataList$groupSampleDataFrame)))
         },
         {## unknown state
           stop(paste("Unknown heatmapContent value", heatmapContent))
         }
  )## end switch
  
  ## heigth per row
  heatmapHeightPerRow <- -1
  if(numberOfGroups <= maximumheatmapHeightRowCount){
    heatmapHeightPerRow <- maximumheatmapHeightPerRow
  } else if(numberOfGroups >= minimumheatmapHeightRowCount){
    heatmapHeightPerRow <- minimumheatmapHeightPerRow
  } else {
    heatmapHeightPerRow <- 
      minimumheatmapHeightPerRow + 
      (numberOfGroups    - maximumheatmapHeightRowCount) / 
      (minimumheatmapHeightRowCount - maximumheatmapHeightRowCount) * 
      (maximumheatmapHeightPerRow - minimumheatmapHeightPerRow)
  }
  heatmapHeight <- heatmapHeightPerRow * numberOfGroups
  dendrogramHeatmapHeight <- 500 + heatmapHeight
  heatmapProportion <- heatmapHeight / dendrogramHeatmapHeight
  #state_tabHca$dendrogramHeatmapHeight <<- dendrogramHeatmapHeight
  
  resultObj <- calcPlotDendrogram(
    dataList = dataList, 
    filterObj = filterHca,#filter, 
    clusterDataList = clusterDataList, 
    #annoPresentAnnotationsList = dataList$annoPresentAnnotationsList, 
    #annoPresentColorsList = dataList$annoPresentColorsList, 
    distanceMeasure = currentDistanceMatrixObj$distanceMeasure, 
    showClusterLabels = state_tabHca$showClusterLabels, 
    hcaPrecursorLabels = state_tabHca$hcaPrecursorLabels, 
    selectionFragmentTreeNodeSet = selectionFragmentTreeNodeSet,
    selectionAnalysisTreeNodeSet = selectionAnalysisTreeNodeSet,
    selectionSearchTreeNodeSet = selectionSearchTreeNodeSet,
    selectedSelection = state_selections$selectedSelection,
    heatmapContent = heatmapContent,
    heatmapOrdering = heatmapOrdering,
    heatmapProportion = heatmapProportion
    #xInterval = dendrogramPlotRange$xInterval
  )
  curveNumberToCurveName <<- resultObj$curveNumberToCurveName
  plotlyPlot             <- resultObj$plotlyPlot
  #columnsOfInterest      <- resultObj$columnsOfInterest
  
  dendrogramUserCoordinateRange <- par("usr")
  dendrogramUserCoordinateRangeY <<- dendrogramUserCoordinateRange[[4]] - dendrogramUserCoordinateRange[[3]]
  
  ## present annotations
  resultObjAnno <- getPrecursorColors(dataList = dataList, precursorSet = filterHca$filter)
  
  uniqueIndeces     <- which(!duplicated(resultObjAnno$setOfAnnotations))
  uniqueAnnotations <- resultObjAnno$setOfAnnotations[uniqueIndeces]
  uniqueColors      <- resultObjAnno$setOfColors[uniqueIndeces]
  
  state_tabHca$annotationsHca <<- list(
    setOfAnnotations = uniqueAnnotations,
    setOfColors      = uniqueColors
  )
  state_tabHca$annotationLegendHeightHca <<- annoLegendEntryHeight * (length(state_tabHca$annotationsHca$setOfAnnotations) + 1)
  
  return(plotlyPlot)
}
drawHeatmapLegend <- function(consoleInfo = NULL){
  output$plotHeatmapLegend <- renderPlot({
    print(paste("### leg ###", consoleInfo))
    drawHeatmapLegendImpl()
  })
}
drawAnnotationLegendHCA <- function(consoleInfo = NULL){
  output$plotAnnoLegendHCA <- renderPlot({
    print(paste("### leg ###", consoleInfo))
    drawAnnotationLegendHCAimpl()
    
  })
}
drawDendrogramLegend <- function(consoleInfo = NULL){
  output$calcPlotDendrogramLegend <- renderPlot({
    print(paste("### leg ###", consoleInfo))
    drawDendrogramLegendImpl()
  })
}

resetHcaPlotRange <- function(){
  dendrogramPlotRange$xMin <<- 1
  dendrogramPlotRange$xMax <<- filterHca$numberOfPrecursorsFiltered
  dendrogramPlotRange$xInterval <<- c(1, filterHca$numberOfPrecursorsFiltered)
  dendrogramPlotRange$xIntervalSize <<- filterHca$numberOfPrecursorsFiltered - 1
}

obsDrawHCA <- observeEvent(input$drawHCAplots, {
  session$sendCustomMessage("disableButton", "drawHCAplots")
  #################################################
  ## get input
  drawPlots <- as.numeric(input$drawHCAplots)
  
  print(paste("Observe draw HCA plots", drawPlots))
  
  ## check if button was hit
  #if(drawPlots == drawHCAButtonValue)
  #  return()
  #drawHCAButtonValue <<- drawPlots
  
  distanceMeasure <- input$hcaDistanceFunction
  #clusterMethod <- input$hcaClusterMethod
  clusterMethod <- "ward.D"
  print(paste("Observe draw HCA plots", "D", distanceMeasure, "M", clusterMethod))
  
  ##########################
  ## calc
  
  ## compute distance matrix
  withProgress(message = 'Calculating distances...', value = 0, {
    currentDistanceMatrixObj <<- calculateDistanceMatrix(dataList = dataList, filter = filterHca$filter, distanceMeasure = distanceMeasure, progress = TRUE)
  })
  ## compute cluster
  withProgress(message = 'Calculating cluster...', value = 0, {
    clusterDataList <<- calculateCluster(progress = TRUE, dataList = dataList, filterObj = filterHca, distanceMatrix = currentDistanceMatrixObj$distanceMatrix, method = clusterMethod, distanceMeasure = distanceMeasure)
  })
  
  ##########################
  ## hca selections
  if(!is.null(listForTable_Fragment_PCA)){ ## selection from fragment
    fragmentIndex <- which(dataList$fragmentMasses == ms2PlotValues$fragmentListClicked$fragmentMasses[[selectionFragmentSelectedFragmentIndex]])
    precursorSet  <- which(dataList$featureMatrix[, fragmentIndex] != 0)
    selectionByFragmentInitHca(precursorSet)
  } else {
    selectionByFragmentReset()
  }
  if(!is.null(listForTable_Analysis_PCA)){ ## selection from PCA
    precursorSet <- filterPca$filter[selectionAnalysisPcaLoadingSet]
    selectionByAnalysisInitHca(precursorSet)
  } else {
    selectionByAnalysisReset()
  }
  if(!is.null(filterSearch)){ ## selection from search
    selectionBySearchInitHca(filterSearch$filter)
  } else {
    selectionBySearchReset()
  }
  
  ##########################
  ## reset MS2 stuff
  if(!state$showPCAplotPanel){
    ms2PlotValues$fragmentListClicked <<- NULL
    ms2PlotValues$fragmentListHovered <<- NULL
    dendrogramFragmentStatistics <<- FALSE
  }
  
  ##########################
  ## draw
  resetHcaPlotRange()
  drawDendrogramPlot(consoleInfo = "init output$plotDendrogram", withHeatmap = TRUE)
  drawMS2Plot(consoleInfo = "init output$plotMS2")
  drawAnnotationLegendHCA(consoleInfo = "init output$plotAnnoLegend")
  
  if(!state$anyPlotDrawn){
    drawMS2Legend(consoleInfo = "init output$ms2LegendPlot")
    drawFragmentDiscriminativityLegend(consoleInfo = "init output$plotFragmentDiscriminativityLegend")
    drawHeatmapLegend(consoleInfo = "init output$plotHeatmapLegend")
    drawDendrogramLegend(consoleInfo = "init output$calcPlotDendrogramLegend")
    state$anyPlotDrawn <<- TRUE
  }
  
  ## state
  state$showHCAplotPanel <<- TRUE
  state$plotHcaShown <<- TRUE
  updateChangePlotRadioButton()
  
  ##########################
  ## update info and tip
  output$information <- renderText({
    print(paste("update output$information clear"))
    paste("", sep = "")
  })
  output$tip <- renderText({
    print(paste("update output$tip"))
    paste(
      "Hover or select a cluster node or leaf node to view information about the corresponding MS\u00B9 feature cluster or MS\u00B9 feature respectively.", 
      "Brush horizontally and double-click to zoom in.", 
      "Double-click to zoom out.", 
      sep = "\n"
    )
  })
  session$sendCustomMessage("enableButton", "drawHCAplots")
})
if(FALSE){
obsDendrogramHover <- observeEvent(input$plotDendrogram_hover, {
  hoverX <- input$plotDendrogram_hover$x
  hoverY <- input$plotDendrogram_hover$y
  
  plotWidth  <- session$clientData$output_plotDendrogram_width
  plotHeight <- session$clientData$output_plotDendrogram_height
  
  if(is.null(hoverX) | is.null(hoverY))
    return()
  
  #################################################
  ## decide whether the click is close enough to trigger event
  minimumIndex <- getSelectedPOI_XY(
    mouseX = hoverX, mouseY = hoverY, poiCoordinatesX = clusterDataList$poiCoordinatesX, poiCoordinatesY = clusterDataList$poiCoordinatesY,
    plotWidth = plotWidth, plotHeight = plotHeight, plotRangeX = dendrogramPlotRange$xIntervalSize, plotRangeY = dendrogramUserCoordinateRangeY
  )
  if(is.null(minimumIndex)){
    print(paste("Observe dendrogram hover", minimumIndex))
    if(!is.null(ms2PlotValues$fragmentListHovered)){
      ## reverse MS2 to clicked stuff
      ms2PlotValues$fragmentListHovered <<- NULL
    }
  } else {
    minimumLabel <- clusterDataList$poiLabels[[minimumIndex]]
    print(paste("Observe dendrogram hover i", minimumIndex, "l", minimumLabel))
    resultObj <- getMS2spectrum(dataList = dataList, clusterDataList = clusterDataList, treeLabel = minimumLabel)
    
    ## ## putative metabolite families statistics
    #putativeMetaboliteFamilies <- NULL
    #if(!is.null(classToSpectra_class)){
    #  putativeMetaboliteFamilies <- evaluatePutativeMetaboliteFamiliesOfDendrogramCluster(dataList = dataList, clusterDataList = clusterDataList, treeLabel = minimumLabel, classToSpectra_class = classToSpectra_class)
    #}
    
    #################################################
    ## output as message
    output$information <- renderText({
      print(paste("update output$information", resultObj$infoText))
      paste(
        resultObj$infoText, 
        #ifelse(test = is.null(putativeMetaboliteFamilies), yes = "", no = 
        #         paste("\n", paste(putativeMetaboliteFamilies, collapse = "\n"), sep = "")
        #), 
        sep = "")
    })
    
    if(all(!is.null(selectionAnalysisTreeNodeSet), minimumLabel == selectionAnalysisTreeNodeSet)){
      ## reverse MS2 to clicked stuff
      ms2PlotValues$fragmentListHovered <<- NULL
    } else {
      #################################################
      ## fetch ms2 spectrum
      ms2PlotValues$fragmentListHovered <<- resultObj
    }
  }
  
  ## MS2 plot
  #drawMS2Plot(consoleInfo = "dendrogram hover output$plotMS2")
  
  output$tip <- renderText({
    print(paste("update output$tip"))
    paste("Hover a cluster node or leaf node to view information about the corresponding MS\u00B9 feature cluster or MS\u00B9 feature respectively.", "Brush horizontally and double-click to zoom in.", "Double-click to zoom out.", sep = "\n")
  })
})
}
output$plotDendrogram_hover_info <- renderUI({
  hover <- input$plotDendrogram_hover
  hoverX <- hover$x
  hoverY <- hover$y
  plotWidth  <- session$clientData$output_plotDendrogram_width
  plotHeight <- session$clientData$output_plotDendrogram_height
  
  if(is.null(hoverX) | is.null(hoverY))
    return(NULL)
  
  output$tip <- renderText({
    print(paste("update output$tip"))
    paste("Hover a cluster node or leaf node to view information about the corresponding MS\u00B9 feature cluster or MS\u00B9 feature respectively.", "Brush horizontally and double-click to zoom in.", "Double-click to zoom out.", sep = "\n")
  })
  
  #################################################
  ## decide whether the hover is close enough to trigger event
  minimumIndex <- getSelectedPOI_XY(
    mouseX = hoverX, mouseY = hoverY, poiCoordinatesX = clusterDataList$poiCoordinatesX, poiCoordinatesY = clusterDataList$poiCoordinatesY,
    plotWidth = plotWidth, plotHeight = plotHeight, plotRangeX = dendrogramPlotRange$xIntervalSize, plotRangeY = dendrogramUserCoordinateRangeY
  )
  print(paste("UI dendrogram hover", hoverX, hoverY, minimumIndex))
  
  if(is.null(minimumIndex)){
    print(paste("Observe dendrogram hover", minimumIndex))
    if(!is.null(ms2PlotValues$fragmentListHovered)){
      ## reverse MS2 to clicked stuff
      ms2PlotValues$fragmentListHovered <<- NULL
    }
    return(NULL)
  }
  
  minimumLabel <- clusterDataList$poiLabels[[minimumIndex]]
  print(paste("Observe dendrogram hover i", minimumIndex, "l", minimumLabel))
  resultObj <- getMS2spectrum(dataList = dataList, clusterDataList = clusterDataList, treeLabel = minimumLabel)
  
  ## ## putative metabolite families statistics
  #putativeMetaboliteFamilies <- NULL
  #if(!is.null(classToSpectra_class)){
  #  putativeMetaboliteFamilies <- evaluatePutativeMetaboliteFamiliesOfDendrogramCluster(dataList = dataList, clusterDataList = clusterDataList, treeLabel = minimumLabel, classToSpectra_class = classToSpectra_class)
  #}
  
  #################################################
  ## output as message
  #output$information <- renderText({
  #  print(paste("update output$information", resultObj$infoText))
  #  paste(
  #    resultObj$infoText, 
  #    #ifelse(test = is.null(putativeMetaboliteFamilies), yes = "", no = 
  #    #         paste("\n", paste(putativeMetaboliteFamilies, collapse = "\n"), sep = "")
  #    #), 
  #    sep = "")
  #})
  
  if(all(!is.null(selectionAnalysisTreeNodeSet), minimumLabel == selectionAnalysisTreeNodeSet)){
    ## reverse MS2 to clicked stuff
    ms2PlotValues$fragmentListHovered <<- NULL
  } else {
    #################################################
    ## fetch ms2 spectrum
    ms2PlotValues$fragmentListHovered <<- resultObj
  }
  
  ## compile information
  if(minimumLabel < 0){
    ## leaf node
    if(FALSE){
      resultObj$fragmentMasses <- fragmentsX
      resultObj$fragmentAbundances <- fragmentsY
      resultObj$fragmentColor <- fragmentsColor
      resultObj$fragmentDiscriminativity <- fragmentDiscriminativity
      resultObj$infoText <- infoText
      #resultObj$infoFeatureLabel <- featureID
      #resultObj$infoFragmentCount <- length(fragmentsX)
      resultObj$infoFamilies <- featureFamilies
      #resultObj$infoName <- featureName
      #resultObj$metFragLinkList <- metFragLinkList
      resultObj$precursorSet <- precursorSet
      resultObj$numberOfPrecursors <- numberOfPrecursors
    }
    info <- paste(
      "<b>MS\u00B9 feature: ", "</b>", resultObj$infoFeatureLabel, "<br>",
      "<b>Name: ", "</b>", resultObj$infoName, "<br>",
      "<b>Annotation: ", "</b>", paste(resultObj$infoFamilies, collapse = "; "), "<br>",
      "<b>Fragments: ", "</b>", resultObj$infoFragmentCount, "<br>",
      "<b>Max. cluster-disciminating power: ", "</b>", format(x = max(resultObj$fragmentDiscriminativity)*100, digits = 3, nsmall = 2), "%",
      sep = ""
    )
  } else {
    ## cluster node
    if(FALSE){
      resultObj$fragmentMasses <- fragmentsX
      resultObj$fragmentAbundances <- fragmentsY
      resultObj$fragmentColor <- fragmentsColor
      resultObj$fragmentDiscriminativity <- fragmentDiscriminativity
      #resultObj$clusterDiscriminativity <- clusterDiscriminativity
      resultObj$frequentFamilies <- frequentFamilies
      resultObj$infoText <- infoText
      #resultObj$metFragLinkList <- NULL
      resultObj$precursorSet <- precursorSet
      resultObj$numberOfPrecursors <- numberOfPrecursors
    }
    info <- paste(
      "<b>MS\u00B9 features: ", "</b>", resultObj$numberOfPrecursors, "<br>",
      "<b>Frequent annotations: ", "</b>", paste(resultObj$frequentFamilies, collapse = "; "), "<br>",
      "<b>Frequent fragments (", length(resultObj$fragmentMasses), "): ", "</b>", paste(format(x = resultObj$fragmentMasses, digits = 3, nsmall = 4), collapse = "; "), "<br>",
      "<b>Max. cluster-disciminating power: ", "</b>", format(x = resultObj$clusterDiscriminativity*100, digits = 3, nsmall = 2), "%",
      sep = ""
    )
  }
  
  panelWidth <- as.integer(plotWidth*0.6)
  showPlotTooltip(hover, info, panelWidth)
})

obsDendrogramClick <- observeEvent(input$plotDendrogram_click, {
  clickX <- input$plotDendrogram_click$x
  clickY <- input$plotDendrogram_click$y
  
  brush <- input$plotDendrogram_brush
  
  plotWidth  <- session$clientData$output_plotDendrogram_width
  plotHeight <- session$clientData$output_plotDendrogram_height
  
  if(is.null(clickX) | is.null(clickY))
    return()
  if(!is.null(brush))
    return()
  
  #################################################
  ## decide whether the click is close enough to trigger event
  minimumIndex <- getSelectedPOI_XY(
    mouseX = clickX, mouseY = clickY, poiCoordinatesX = clusterDataList$poiCoordinatesX, poiCoordinatesY = clusterDataList$poiCoordinatesY,
    plotWidth = plotWidth, plotHeight = plotHeight, plotRangeX = dendrogramPlotRange$xIntervalSize, plotRangeY = dendrogramUserCoordinateRangeY
  )
  print(paste("Observe dendrogram click", is.null(minimumIndex), minimumIndex))
  
  if(is.null(minimumIndex)){
    ## reset stuff
    
    #ms2PlotValues$fragmentListClicked <<- NULL
    ms2PlotValues$fragmentListHovered <<- NULL
    
    selectionByAnalysisReset()
    selectionByFragmentReset()
    
    ##########################################################################################
    ## all fragments from the dendrogram
    
    ## get
    precursorSet <- filterHca$filter
    returnObj <- getSpectrumStatistics(dataList=dataList, precursorSet=precursorSet)
    fragmentMasses <- returnObj$fragmentMasses
    fragmentCounts <- returnObj$fragmentCounts
    
    ## filter
    theseFragments <- fragmentCounts >= minimumNumberOfPrecursorsForDendrogramStatistics
    fragmentMasses <- fragmentMasses[theseFragments]
    fragmentCounts <- fragmentCounts[theseFragments]
    
    ## set
    ms2PlotValues$fragmentListClicked <<- list(
      fragmentMasses = fragmentMasses,
      fragmentAbundances = fragmentCounts / length(precursorSet),
      fragmentColor = rep(x = "black", times = length(fragmentMasses)),
      fragmentDiscriminativity = rep(x = 0, times = length(fragmentMasses))
    )
    
    dendrogramFragmentStatistics <<- TRUE
    state$showPutativeAnnotationsTableFromAnalysis <<- FALSE
    putativeAnnotationsTableFromAnalysisCurrentlyShown <<- NULL
  } else {
    ## tree selection
    minimumLabel <- clusterDataList$poiLabels[[minimumIndex]]
    #minimumText <- clusterDataList$poiText[[minimumIndex]]
    
    ## fetch ms2 spectrum
    resultObj <- getMS2spectrum(dataList = dataList, clusterDataList = clusterDataList, treeLabel = minimumLabel)
    
    ## keep fragment selection
    selectionFragmentSelectedFragmentIndexNew <- NULL
    if(!is.null(selectionFragmentSelectedFragmentIndex)){
      fragmentMass <- ms2PlotValues$fragmentListClicked$fragmentMasses[[selectionFragmentSelectedFragmentIndex]]
      if(fragmentMass %in% resultObj$fragmentMasses)
        selectionFragmentSelectedFragmentIndexNew <- which(resultObj$fragmentMasses %in% fragmentMass)
    }
    
    ms2PlotValues$fragmentListClicked <<- resultObj
    ms2PlotValues$fragmentListHovered <<- NULL
    dendrogramFragmentStatistics <<- FALSE
    
    #################################################
    ## output as message
    selectionByHca(minimumLabel)
    
    ## update the selected fragment in case of overlapping spectra
    if(!is.null(selectionFragmentSelectedFragmentIndexNew))
      selectionByFragment(selectionFragmentSelectedFragmentIndexNew)
    else
      selectionByFragmentReset()
    
    output$information <- renderText({
      print(paste("update output$information", resultObj$infoText))
      paste(resultObj$infoText, sep = "")
    })
    
    #################################################
    ## putative metabolite families statistics
    if(!is.null(classToSpectra_class)){
      precursorSet <- getPrecursorSetFromTreeSelection(clusterDataList = clusterDataList, clusterLabel = minimumLabel)
      setPutativeAnnotationsTableFromAnalysis(precursorSet)
      state$showPutativeAnnotationsTableFromAnalysis <<- TRUE
    }
  }## node selected
  
  #################################################
  ## plots
  
  ## cluster dendrogram
  ## TODO remove plot call
  drawDendrogramPlot(consoleInfo = "dendrogram click output$plotDendrogram", withHeatmap = TRUE)
  
  ## MS2 plot
  resetMS2PlotRange()
  #drawMS2Plot(consoleInfo = "dendrogram click output$plotMS2")
  
  #if(state$showPCAplotPanel)
  #  ## update PCA plots
  #  drawPcaPlots(consoleInfo = "dendrogram click output$plotPcaScores")
})
obsDendrogramdblClick <- observeEvent(input$plotDendrogram_dblclick, {
  brush <- input$plotDendrogram_brush
  
  print(paste("observe dendrogram dblclick", is.null(brush)))
  
  if (!is.null(brush)) {
    ## set range
    dendrogramPlotRange$xMin <<- brush$xmin
    dendrogramPlotRange$xMax <<- brush$xmax
    dendrogramPlotRange$xInterval <<- c(brush$xmin, brush$xmax)
    dendrogramPlotRange$xIntervalSize <<- brush$xmax - brush$xmin
  } else {
    ## reset range
    dendrogramPlotRange$xMin <<- 1
    dendrogramPlotRange$xMax <<- filterHca$numberOfPrecursorsFiltered
    dendrogramPlotRange$xInterval <<- c(1, filterHca$numberOfPrecursorsFiltered)
    dendrogramPlotRange$xIntervalSize <<- filterHca$numberOfPrecursorsFiltered - 1
  }
})

if(FALSE){
obsHeatmaphover <- observeEvent(input$plotHeatmap_hover, {
  hoverX <- input$plotHeatmap_hover$x
  hoverY <- input$plotHeatmap_hover$y
  
  if(is.null(hoverX) | is.null(hoverY))
    return()
  if(hoverX < 0.5 | hoverX > (clusterDataList$numberOfPrecursorsFiltered + 0.5))
    return()
  if(hoverY < 0 | hoverY > 3)
    return()
  
  print(paste("Observe heatmap hover", hoverX, hoverY))
  
  #################################################
  ## info
  treeLeafIndex2 <- as.numeric(format(x = hoverX, digits = 1))
  treeLeafIndex  <- clusterDataList$cluster$order[[treeLeafIndex2]]
  precursorIndex <- filterHca$filter[[treeLeafIndex]]
  
  msg <- list()
  msg[[length(msg) + 1]] <- "MS\u00B9 feature: "
  msg[[length(msg) + 1]] <- dataList$precursorLabels[[precursorIndex]]
  msg[[length(msg) + 1]] <- "\n"
  
  if(hoverY > 2){
    ## lcf
    groupOne <- filterHca$grouXXXps[[1]]
    groupTwo <- filterHca$grouXXXps[[2]]
    msg[[length(msg) + 1]] <- paste("log-fold-change = log_2( mean(group ", groupOne, ") / mean(group ", groupTwo, ") )", sep = "")
    
    valMeanOne <- dataList$dataFrameMeasurements[precursorIndex, dataList$dataMeanColumnNameFunctionFromName(groupOne)]
    valMeanTwo <- dataList$dataFrameMeasurements[precursorIndex, dataList$dataMeanColumnNameFunctionFromName(groupTwo)]
    msg[[length(msg) + 1]] <- " = log_2( "
    msg[[length(msg) + 1]] <- as.numeric(format(x = valMeanOne, digits = 2))
    msg[[length(msg) + 1]] <- " / "
    msg[[length(msg) + 1]] <- as.numeric(format(x = valMeanTwo, digits = 2))
    msg[[length(msg) + 1]] <- " ) = "
    
    lfc <- dataList$dataFrameMeasurements[precursorIndex, dataList$lfcColumnNameFunctionFromName(groupOne, groupTwo)]
    msg[[length(msg) + 1]] <- as.numeric(format(x = lfc, digits = 2))
  } else {
    if(hoverY > 1){
      ## group 1
      groupHere <- filterHca$grouXXXps[[1]]
    } else { ## hoverY <= 1
      ## group 2
      groupHere <- filterHca$grouXXXps[[2]]
    }
    msg[[length(msg) + 1]] <- paste("Mean abundance of group ", groupHere, ": ", sep = "")
    valMean <- dataList$dataFrameMeasurements[precursorIndex, dataList$dataMeanColumnNameFunctionFromName(groupHere)]
    msg[[length(msg) + 1]] <- as.numeric(format(x = valMean, digits = 2))
    msg[[length(msg) + 1]] <- " = mean("
    #columnNames <- dataList$dataColumnsNameFunctionFromGroupName(group = groupHere, sampleNamesToExclude = dataList$excludedSamples(dataList$groupSampleDataFrame))
    columnNames <- dataList$dataColumnsNameFunctionFromGroupName(group = groupHere, sampleNamesToExclude = dataList$excludedSamples(groupSampleDataFrame = dataList$groupSampleDataFrame, grouXXXps = groupHere))
    vals <- dataList$dataFrameMeasurements[precursorIndex, columnNames]
    vals <- as.numeric(format(x = vals, digits = 2))
    msg[[length(msg) + 1]] <- paste(vals, collapse = ", ")
    msg[[length(msg) + 1]] <- ")"
  }
  
  output$information <- renderText({
    print(paste("update output$information heatmap hover", sep = ""))
    paste(msg, collapse = "")
  })
})
}  ## not finished

#print("entering the line ..line 680")
#print(columnsOfInterestForHeatmap)

output$plotHeatmap_hover_info <- renderUI({
  hover <- input$plotHeatmap_hover
  hoverX <- hover$x
  hoverY <- hover$y
  plotWidth  <- session$clientData$output_plotHeatmap_width
  plotHeight <- session$clientData$output_plotHeatmap_height
  
  columnsOfInterest <- columnsOfInterestForHeatmap
  
  if(is.null(hoverX) | is.null(hoverY))
    return(NULL)
  if(hoverX < 0.5 | hoverX > (clusterDataList$numberOfPrecursorsFiltered + 0.5))
    return(NULL)
  if(hoverY < 0 | hoverY > length(columnsOfInterest))
    return(NULL)
  
  #################################################
  treeLeafIndex2 <- as.numeric(format(x = hoverX, digits = 1))
  treeLeafIndex  <- clusterDataList$cluster$order[[treeLeafIndex2]]
  precursorIndex <- filterHca$filter[[treeLeafIndex]]
  
  ## differentiate heatmap content: LFC, samples, grouXXXps
  columnOfInterest <- columnsOfInterest[[ceiling(hoverY)]]
  #print("entering the line ...line 707")
  #print(columnOfInterest)
  #columnOfInterest <- rev(columnsOfInterest)[[round(hoverY)]]
  #####################
  #if(startsWith(x = columnOfInterest, prefix = "LFC_")){
  if(startsWith(columnOfInterest, "LFC_")){
    ####################################
    ## lcf
    #print("enter the line ...line 714")
    ########
    grouXXXps <- dataList$lfcColumnNameFunctionFromString(columnOfInterest)
    #######
    #print(columnOfInterest)
    #print(grouXXXps)
    #######
    groupOne <- grouXXXps[[1]]
    groupTwo <- grouXXXps[[2]]
    #msg[[length(msg) + 1]] <- paste("log-fold-change = log_2( mean(group ", groupOne, ") / mean(group ", groupTwo, ") )", sep = "")
    
    valMeanOne <- dataList$dataFrameMeasurements[precursorIndex, dataList$dataMeanColumnNameFunctionFromName(groupOne)]
    valMeanTwo <- dataList$dataFrameMeasurements[precursorIndex, dataList$dataMeanColumnNameFunctionFromName(groupTwo)]
    valMeanOne <- format(x = valMeanOne, digits = 2)
    valMeanTwo <- format(x = valMeanTwo, digits = 2)
    #msg[[length(msg) + 1]] <- " = log_2( "
    #msg[[length(msg) + 1]] <- valMeanOne
    #msg[[length(msg) + 1]] <- " / "
    #msg[[length(msg) + 1]] <- valMeanTwo
    #msg[[length(msg) + 1]] <- " ) = "
    
    lfc <- dataList$dataFrameMeasurements[precursorIndex, dataList$lfcColumnNameFunctionFromName(groupOne, groupTwo)]
    lfc <- format(x = lfc, digits = 2)
    #msg[[length(msg) + 1]] <- lfc
    
    #samplesOne <- dataList$dataColumnsNameFunctionFromGroupName(group = groupOne, sampleNamesToExclude = dataList$excludedSamples(groupSampleDataFrame = dataList$groupSampleDataFrame, grouXXXps = groupOne))
    #samplesTwo <- dataList$dataColumnsNameFunctionFromGroupName(group = groupTwo, sampleNamesToExclude = dataList$excludedSamples(groupSampleDataFrame = dataList$groupSampleDataFrame, grouXXXps = groupTwo))
    
    info <- paste(
      "<b>MS\u00B9 feature: ", "</b>", dataList$precursorLabels[[precursorIndex]], "<br>",
      "<b>Group ratio: ", "</b>", groupOne, " / ", groupTwo, "<br>",
      "<b>log2-fold-change: ", "</b>", lfc, "<br>",
      #"<b>Samples in groups: ", "</b>", paste(c(samplesOne, samplesTwo), collapse = ", "), "<br>",
      "<b>Mean abundances: ", "</b>", valMeanOne, " / ", valMeanTwo, #"<br>",
      #"<b>Sample abundances: ", "</b>", paste(vals, collapse = ", "),
      sep = ""
    )
  } #else if(startsWith(x = columnOfInterest, prefix = "HBR")){}
  else {
    #if(endsWith(x = columnOfInterest, suffix = "_mean")){
    if(endsWith(columnOfInterest, "_mean")){
      #####################################
      ## group
      #print("enter the line 750")
      #####
      groupHere <- dataList$dataMeanColumnNameFunctionFromString(columnOfInterest)
      
      #msg[[length(msg) + 1]] <- paste("Mean abundance of group ", groupHere, ": ", sep = "")
      valMean <- dataList$dataFrameMeasurements[precursorIndex, dataList$dataMeanColumnNameFunctionFromName(groupHere)]
      valMean <- format(x = valMean, digits = 2)
      #msg[[length(msg) + 1]] <- valMean
      #msg[[length(msg) + 1]] <- " = mean("
      #columnNames <- dataList$dataColumnsNameFunctionFromGroupName(group = groupHere, sampleNamesToExclude = dataList$excludedSamples(dataList$groupSampleDataFrame))
      columnNames <- dataList$dataColumnsNameFunctionFromGroupName(group = groupHere, sampleNamesToExclude = dataList$excludedSamples(groupSampleDataFrame = dataList$groupSampleDataFrame, grouXXXps = groupHere))
      vals <- dataList$dataFrameMeasurements[precursorIndex, columnNames]
      vals <- format(x = vals, digits = 2)
      #msg[[length(msg) + 1]] <- paste(vals, collapse = ", ")
      #msg[[length(msg) + 1]] <- ")"
      
      info <- paste(
        "<b>MS\u00B9 feature: ", "</b>", dataList$precursorLabels[[precursorIndex]], "<br>",
        "<b>Sample group: ", "</b>", groupHere, "<br>",
        "<b>Mean abundance: ", "</b>", valMean, "<br>",
        "<b>Samples in group: ", "</b>", paste(columnNames, collapse = ", "), "<br>",
        "<b>Sample abundances: ", "</b>", paste(vals, collapse = ", "),
        sep = ""
      )
    } else {
      #####################################
      ## sample
      val <- dataList$dataFrameMeasurements[precursorIndex, columnOfInterest]
      #msg[[length(msg) + 1]] <- paste("Abundance in sample ", columnOfInterest, ": ", val, sep = "")
      
      info <- paste(
        "<b>MS\u00B9 feature: ", "</b>", dataList$precursorLabels[[precursorIndex]], "<br>",
        "<b>Sample: ", "</b>", columnOfInterest, "<br>",
        "<b>Abundance: ", "</b>", format(x = val, digits = 2),
        sep = ""
      )
    }
  }
 #################################### 
  #output$information <- renderText({
  #  print(paste("update output$information heatmap hover", sep = ""))
  #  paste(msg, collapse = "")
  #})
  
  panelWidth <- as.integer(plotWidth*0.4)
  showPlotTooltip(hover, info, panelWidth)
})

setPutativeAnnotationsTableFromAnalysis <- function(precursorSet){
  if(FALSE){
    dataList_ = dataList
    precursorSet_ = precursorSet
    classToSpectra_class_ = classToSpectra_class
  }
  if(FALSE){
    dataList = dataList_
    precursorSet = precursorSet_
    classToSpectra_class = classToSpectra_class_
  }
  
  ## data.frame("Class"=character(), "pValue"=numeric(), "ProportionInPercent" = numeric())
  returnObj  <- evaluatePutativeMetaboliteFamiliesOfPrecursorSet(dataList = dataList, precursorSet = precursorSet, classToSpectra_class = classToSpectra_class)
  overviewDf <- returnObj$overviewDf
  detailDf   <- returnObj$detailDf
  
  if(nrow(overviewDf) == 0){
    msg <- ifelse(test = length(precursorSet) == 1, yes = "There are no putative annotations.", no = "There are no frequent putative annotations.")
    showDf <- data.frame("Message" = msg, stringsAsFactors = FALSE)
    print(paste(length(precursorSet), "precursors without putative annotation"))
  } else {
    type <- "PutativeAnnotationsTableFromAnalysis"
    annotateColumn <- createActionButtonInputFields(
      FUN = actionButton,  id = paste(type, "Annotate", sep = "_"), itemCount=nrow(overviewDf), 
      label   = "Annotate", tableCounter = putativeAnnotationsTableFromAnalysisInputFieldIdCounter, 
      callFunction = putativeAnnotationsTableFromAnalysisAnnotateClicked
    )
    putativeAnnotationsTableFromAnalysisInputFieldIdCounter <<- putativeAnnotationsTableFromAnalysisInputFieldIdCounter + 1
    
    if(length(precursorSet) == 1)
      #overviewDf <- data.frame("Class" = df$Class, "pValue" = df$pValue, stringsAsFactors = FALSE)
      showDf <- cbind("Class" = overviewDf$Class, "pValue" = overviewDf$pValue, "Annotate" = annotateColumn)
    else
      showDf <- cbind("Class" = overviewDf$Class, "median pValue" = overviewDf$pValue, "Annotate" = annotateColumn)
    print(paste(length(precursorSet), "precursors with", nrow(detailDf), "putative annotations in", nrow(showDf), "classes"))
  }
  
  putativeAnnotationsTableFromAnalysisCurrentlyShown <<- showDf
  
  output$putativeAnnotationsTableFromAnalysis <- DT::renderDataTable(
    expr = showDf,
    server = FALSE, escape = FALSE, selection = ifelse(test = nrow(overviewDf)>0, yes = "single", no = "none"), #rownames = FALSE,
    options = list(
      #scrollY = "600px",
      scrollY = "40vh",
      preDrawCallback = JS('function() { Shiny.unbindAll(this.api().table().node()); }'),
      drawCallback    = JS('function() { Shiny.bindAll(  this.api().table().node()); }'),
      iDisplayLength=nrow(showDf),       # initial number of records
      #aLengthMenu = c(5,10),    # records/page options
      #bLengthChange =0,         # show/hide records per page dropdown
      #bFilter = 0,              # global search box on/off
      #bInfo = 0,                # information on/off (how many records filtered, etc)
      #bAutoWidth = 0,           # automatic column width calculation, disable if passing column width via aoColumnDefs
      #aoColumnDefs = list(list(sWidth="300px", aTargets=c(list(0),list(1))))    # custom column size
      ordering = F,              # row ordering
      sDom  = 't'
      #sDom  = '<"top">rt<"bottom">ip'
    )
  )
}

#obsPutativeAnnotationsTableFromAnalysis_rows_selected <- observeEvent(eventExpr = input$putativeAnnotationsTableFromAnalysis_rows_selected, handlerExpr = {
#  print(paste("Observe putativeAnnotationsTableFromAnalysis_rows_selected", input$putativeAnnotationsTableFromAnalysis_rows_selected))
#  state$putativeAnnotationsTableFromAnalysisRowSelected <<- !is.null(input$putativeAnnotationsTableFromAnalysis_rows_selected)
#}, ignoreNULL = FALSE)
putativeAnnotationsTableFromAnalysisAnnotateClicked <- function(buttonId){
  ## PutativeAnnotationsTableFromAnalysis_Annotate_0_1
  rowIdx    <- as.integer(strsplit(x = buttonId, split = "_")[[1]][[4]])
  
  precursorSet <- getPrecursorSetFromTreeSelection(clusterDataList = clusterDataList, clusterLabel = selectionAnalysisTreeNodeSet)
  class <- putativeAnnotationsTableFromAnalysisCurrentlyShown[[rowIdx, "Class"]]
  subClass <- tail(x = strsplit(x = class, split = "; ")[[1]], n = 1)
  print(paste(length(precursorSet), "-->", class, "(", subClass, ")", "from row", rowIdx))
  
  callbackFunction <- function(value, color){
    print(paste(length(precursorSet), "-->", class, "from row", rowIdx, "-->", value, color))
    removeModal(session = session)
    
    ## add
    addAnnotation(precursorSet = precursorSet, annotationValue = value, annotationColor = color)
  }
  
  openAnnotaionNameColorDialog(predefinedClassName = subClass, callbackFunction = callbackFunction)
}

if(FALSE){
  ## plotly
  obsDendLabelsHeatmap <- observeEvent(event_data("plotly_click", source = "dendLabelsHeatmap"), {
    eventdata <- event_data("plotly_click", source = "dendLabelsHeatmap")
    #str(eventdata)
    ## 'data.frame':	1 obs. of  4 variables:
    ## $ curveNumber: int 7
    ## $ pointNumber: int 6
    ## $ x          : num 8.5
    ## $ y          : num 0.697
    
    if(is.null(eventdata))
      return()
    
    curveName <- curveNumberToCurveName[which(curveNumberToCurveName[, "curveNumber"] == eventdata$curveNumber), "name"]
    #print(paste("curveName:", curveName))
    if(curveName != "nodes")
      return()
    
    #nodeIndex <- eventdata$pointNumber + 1
    nodeIndex <- which((
      #eventdata$x == clusterDataList$poiCoordinatesX & 
      #eventdata$x %in% clusterDataList$poiCoordinatesX
      abs(eventdata$x - clusterDataList$poiCoordinatesX) <= 0.0001
    ) & (
      #eventdata$y == clusterDataList$poiCoordinatesY
      #eventdata$y %in% clusterDataList$poiCoordinatesY
      abs(eventdata$y - clusterDataList$poiCoordinatesY) <= 0.0001
    ))
    nodeLabel <- clusterDataList$poiLabels[[nodeIndex]]
    
    
    ## fetch ms2 spectrum
    resultObj <- getMS2spectrum(dataList = dataList, clusterDataList = clusterDataList, treeLabel = nodeLabel)
    
    ## keep fragment selection
    selectionFragmentSelectedFragmentIndexNew <- NULL
    if(!is.null(selectionFragmentSelectedFragmentIndex)){
      fragmentMass <- ms2PlotValues$fragmentListClicked$fragmentMasses[[selectionFragmentSelectedFragmentIndex]]
      if(fragmentMass %in% resultObj$fragmentMasses)
        selectionFragmentSelectedFragmentIndexNew <- which(resultObj$fragmentMasses %in% fragmentMass)
    }
    
    ms2PlotValues$fragmentListClicked <<- resultObj
    ms2PlotValues$fragmentListHovered <<- NULL
    dendrogramFragmentStatistics <<- FALSE
    
    print(paste("fragments:", paste(resultObj$fragmentMasses, collapse = "; ")))
    
    #################################################
    ## output as message
    selectionByHca(nodeLabel)
    
    ## update the selected fragment in case of overlapping spectra
    if(!is.null(selectionFragmentSelectedFragmentIndexNew))
      selectionByFragment(selectionFragmentSelectedFragmentIndexNew)
    else
      selectionByFragmentReset()
    
    output$information <- renderText({
      print(paste("update output$information", resultObj$infoText))
      paste(resultObj$infoText, sep = "")
    })
    
    ## TODO
    #drawMS2PlotImpl
    
    resetMS2PlotRange()
    #drawMS2Plot()
    
    #output$plotDendrogram <- renderPlotly({
  })
  
  #output$plotTmp <- renderPlotly({
  #  
  #  # Read in hover data
  #  eventdata <- event_data("plotly_click", source = "dendLabelsHeatmap")
  #  print("haha")
  #  str(eventdata)
  #  validate(need(!is.null(eventdata), "Hover over the time series chart to populate this heatmap"))
  #  
  #  curveName <- curveNumberToCurveName[which(curveNumberToCurveName[, "curveNumber"] == eventdata$curveNumber), "name"]
  #  print(curveName)
  #  
  #  plot_ly(x = 1:10, y = rnorm(10), type = "scatter", mode = "markers")
  #})
}

output$showPutativeAnnotationsTableFromAnalysis <- reactive({
  print(paste("reactive update showPutativeAnnotationsTableFromAnalysis", state$showPutativeAnnotationsTableFromAnalysis))
  return(state$showPutativeAnnotationsTableFromAnalysis)
})

outputOptions(output, 'showPutativeAnnotationsTableFromAnalysis',  suspendWhenHidden=FALSE)

output$ui_plotAnnoLegendHCA <- renderUI({
  print(paste("### GUI ### ui_plotAnnoLegendHCA"))
  if(state_tabHca$annotationLegendHeightHca != -1) {
    plotOutput(outputId = "plotAnnoLegendHCA", height = state_tabHca$annotationLegendHeightHca)
  }
})
output$ui_plotHeatmap <- renderUI({
  print(paste("### GUI ### ui_plotHeatmap"))
  plotOutput(height = state_tabHca$heatmapHeight, 
             outputId = "plotHeatmap",
             #hover    = "plotHeatmap_hover", 
             hover    = hoverOpts(
               id = "plotHeatmap_hover",
               delay = 50, 
               delayType = "debounce"
             )
             #click = "plotHeatmap_click"
  )
})


suspendOnExitFunctions <- c(suspendOnExitFunctions, function(){
  print("Suspending tabHca observers")
  obsDrawHCA$suspend()
  obsDendrogramClick$suspend()
  obsDendrogramdblClick$suspend()
})

================
File: inst/MetFamily/app_files/server_guiTabInput.R
================
## data import: fixed parameters
proportionOfMatchingPeaks_ms2PeakGroupDeisotoping <- 0.9
mzDeviationAbsolute_mapping <- 0.01
#minimumNumberOfMS2PeaksPerGroup <- 1

## data
dataList <- NULL
state_tabInput <- reactiveValues(
  importedOrLoadedFile_s_ = NULL
)
resetWorkspaceFunctions <- c(resetWorkspaceFunctions, function(){
  print("Reset tabInput state")
  state_tabInput$importedOrLoadedFile_s_ <<- NULL
})

enableLoadButtons <- function(){
  #session$sendCustomMessage("enableButton", "loadProjectData")
  #session$sendCustomMessage("enableButton", "loadExampleData")
  #session$sendCustomMessage("enableButton", "importMs1Ms2Data")
  #session$sendCustomMessage("enableButton", "importMs2Data")
  shinyjs::enable("loadProjectData")
  shinyjs::enable("loadExampleData")
  shinyjs::enable("importMs1Ms2Data")
  shinyjs::enable("importMs2Data")
}
disableLoadButtons <- function(){
  session$sendCustomMessage("disableButton", "loadProjectData")
  session$sendCustomMessage("disableButton", "loadExampleData")
  session$sendCustomMessage("disableButton", "importMs1Ms2Data")
  session$sendCustomMessage("disableButton", "importMs2Data")
  shinyjs::disable("loadProjectData")
  shinyjs::disable("loadExampleData")
  shinyjs::disable("importMs1Ms2Data")
  shinyjs::disable("importMs2Data")
}
obsFile <- observeEvent(input$matrixFile$datapath, {
  filePath <- input$matrixFile$datapath
  fileName <- input$matrixFile$name
  print(paste("Observe file for data", fileName))
  if(!is.null(filePath))
    shinyjs::enable("loadProjectData")
  
  updateFileInputInfo()
})
obsLoadProjectData <- observeEvent(input$loadProjectData, {
  disableLoadButtons()
  loadProjectData <- as.numeric(input$loadProjectData)
  print(paste("Observe loadProjectData", loadProjectData))
  
  #################################################
  ## check if button was hit
  #if(loadProjectData == loadProjectDataButtonValue)
  #  return()
  #loadProjectDataButtonValue <<- loadProjectData
  
  #################################################
  ## files
  filePath <- input$matrixFile$datapath
  loadProjectFile(filePath = filePath)
  enableLoadButtons()
})
obsLoadExampleData <- observeEvent(input$loadExampleData, {
  disableLoadButtons()
  loadExampleData <- as.numeric(input$loadExampleData)
  print(paste("Observe loadExampleData", loadExampleData))
  
  #################################################
  ## check if button was hit
  #if(loadExampleData == loadExampleDataButtonValue)
  #  return()
  #loadExampleDataButtonValue <<- loadExampleData
  
  #################################################
  ## files
  filePath <- system.file("extdata/showcase/Project_file_showcase_annotated.csv.gz", package = "MetFamily")
  
  loadProjectFile(filePath = filePath)
  enableLoadButtons()
})
loadProjectFile <- function(filePath){
  fileName <- basename(filePath)
  #########################################################################################
  ## read data
  
  #######dirty fix readClusterData.. calls readProjectData whic needs qfeatures for annotations
  fileMs1Path <- input$ms1DataFile$datapath
  filePeakMatrixQF <- readMSDial(fileMs1Path)
  fileAnnotation <- input$annotationFile$datapath
  if (!is.null(fileAnnotation)){
    # TODO: determine colums to merge by
    filePeakMatrixQF <- addSiriusAnnotations(filePeakMatrixQF,fileAnnotation)
  }
  #######dirty fix
  
  
  error <<- NULL
  withProgress(message = 'Reading file...', value = 0, {
    dataList <<- tryCatch(
      {
        readClusterDataFromProjectFile(file = filePath, progress = TRUE)
      }, 
      error = function(e) {
        print(e)
        error <<- e
      }
    )
  })
  
  if(!is.null(error)){
    print(paste("readClusterDataFromProjectFile resulted in error:", error))
    msg <- paste("An error occurred while reading the input files. Please check the file format and content and try again. The error was", error)
    output$fileInfo <- renderText({msg})
    #session$sendCustomMessage("enableButton", buttonId)
    #shinyBS::addPopover(session = session, id = "fileInputSelection", title = "Error", content = "huhu")
    
    msg <- paste(
      "An error occurred while reading the input files.",
      "Please check the file format and content and try again.",
      "The error was:",
      "<br>", 
      error
    )
    showErrorDialog(msg)
    
    return()
  }
  print(paste("readClusterDataFromProjectFile finished", dataList$minimumMass))
  
  resetWorkspace()
  
  state_tabInput$importedOrLoadedFile_s_ <<- fileName
  updateFileInputInfo()
}
obsImportMs1DataFile <- observeEvent(input$ms1DataFile$datapath, {
  fileMs1Path <- input$ms1DataFile$datapath
  fileMs1Name <- input$ms1DataFile$name
  fileMs2Path <- input$ms2DataFile$datapath
  fileMs2Name <- input$ms2DataFile$name
  print(paste("Observe import MS1 file", fileMs1Name))
  
  if(all(!is.null(fileMs1Path), !is.null(fileMs2Path)))
    shinyjs::enable("importMs1Ms2Data")
  else
    shinyjs::disable("importMs1Ms2Data")
  
  updateFileInputInfo()
})
obsImportMs2DataFile <- observeEvent(input$ms2DataFile$datapath, {
  setImportState()
})
setImportState <- function(){
  fileMs1Path <- input$ms1DataFile$datapath
  fileMs1Name <- input$ms1DataFile$name
  fileMs2Path <- input$ms2DataFile$datapath
  fileMs2Name <- input$ms2DataFile$name
  print(paste("Observe import MS2 file", fileMs2Name))
  
  if(all(!is.null(fileMs1Path), !is.null(fileMs2Path)))
    shinyjs::enable("importMs1Ms2Data")
  else
    shinyjs::disable("importMs1Ms2Data")
  
  if(!is.null(fileMs2Path))
    shinyjs::enable("importMs2Data")
  else
    shinyjs::disable("importMs2Data")
  
  updateFileInputInfo()
}
obsImportMs1Ms2Data <- observeEvent(input$importMs1Ms2Data, {
  disableLoadButtons()
  importMs1Ms2Data <- as.numeric(input$importMs1Ms2Data)
  
  print(paste("Observe importMs1Ms2Data", importMs1Ms2Data))
  
  #################################################
  ## check if button was hit
  #if(importMs1Ms2Data == importMs1Ms2DataButtonValue)
  #  return()
  #importMs1Ms2DataButtonValue <<- importMs1Ms2Data
  
  importData(TRUE)
  enableLoadButtons()
})
obsImportMs2Data <- observeEvent(input$importMs2Data, {
  enableLoadButtons()
  importMs2Data <- as.numeric(input$importMs2Data)
  
  print(paste("Observe importMs2Data", importMs2Data))
  
  #################################################
  ## check if button was hit
  #if(importMs2Data == importMs2DataButtonValue)
  #  return()
  #importMs2DataButtonValue <<- importMs2Data
  
  importData(FALSE)
  disableLoadButtons()
})
importData <- function(importMS1andMS2data){
  #################################################
  ## files
  if(importMS1andMS2data){
    fileMs1Path <- input$ms1DataFile$datapath
    fileMs1Name <- input$ms1DataFile$name
  } else {
    fileMs1Path <- NULL
    fileMs1Name <- NULL
  }
  fileMs2Path <- input$ms2DataFile$datapath
  fileMs2Name <- input$ms2DataFile$name
  fileAnnotPath <- input$annotationFile$datapath
  fileAnnotName <- input$annotationFile$name
  
  #################################################
  ## params
  
  ## project name
  projectName <- input$projectName
  projectName <- gsub(";", "_", gsub(",", "_", gsub("\t", "_", projectName)))
  projectDescription <- input$projectDescription
  projectDescription <- gsub(";", "_", gsub(",", "_", gsub("\t", "_", projectDescription)))
  
  ## minimum MS2 peak intensity
  minimumIntensityOfMaximalMS2peak <- input$minimumIntensityOfMaximalMS2peak
  minimumProportionOfMS2peaks <- input$minimumProportionOfMS2peaks
  ## grouping of MS2 peaks
  mzDeviationAbsolute_grouping <- input$mzDeviationAbsolute_grouping
  mzDeviationInPPM_grouping <- input$mzDeviationInPPM_grouping
  ## precursor deisotoping
  doPrecursorDeisotoping <- input$doPrecursorDeisotoping
  mzDeviationAbsolute_precursorDeisotoping <- input$mzDeviationAbsolute_precursorDeisotoping
  mzDeviationInPPM_precursorDeisotoping <- input$mzDeviationInPPM_precursorDeisotoping
  maximumRtDifference <- input$maximumRtDifference
  ## fragment deisotoping
  doMs2PeakGroupDeisotoping <- input$doMs2PeakGroupDeisotoping
  mzDeviationAbsolute_ms2PeakGroupDeisotoping <- input$mzDeviationAbsolute_ms2PeakGroupDeisotoping
  mzDeviationInPPM_ms2PeakGroupDeisotoping <- input$mzDeviationInPPM_ms2PeakGroupDeisotoping
  ## neutral losses
  neutralLossesPrecursorToFragments <- input$neutralLossesPrecursorToFragments
  neutralLossesFragmentsToFragments <- input$neutralLossesFragmentsToFragments
  #neutralLossesPrecursorToFragments <- TRUE
  #neutralLossesFragmentsToFragments <- FALSE
  
  ## fixed
  proportionOfMatchingPeaks_ms2PeakGroupDeisotopingHere <- proportionOfMatchingPeaks_ms2PeakGroupDeisotoping
  mzDeviationAbsolute_mappingHere <- mzDeviationAbsolute_mapping
  #minimumNumberOfMS2PeaksPerGroupHere <- minimumNumberOfMS2PeaksPerGroup
  
  #################################################
  ## check params
  error <- FALSE
  if(any(is.null(minimumIntensityOfMaximalMS2peak), length(minimumIntensityOfMaximalMS2peak) == 0, nchar(minimumIntensityOfMaximalMS2peak) == 0))
    error <- TRUE
  else{
    minimumIntensityOfMaximalMS2peak <- as.numeric(minimumIntensityOfMaximalMS2peak)
    error <- error | is.na(minimumIntensityOfMaximalMS2peak)
  }
  if(any(is.null(minimumProportionOfMS2peaks), length(minimumProportionOfMS2peaks) == 0, nchar(minimumProportionOfMS2peaks) == 0))
    error <- TRUE
  else{
    minimumProportionOfMS2peaks <- as.numeric(minimumProportionOfMS2peaks)
    error <- error | is.na(minimumProportionOfMS2peaks)
  }
  if(any(is.null(mzDeviationAbsolute_grouping), length(mzDeviationAbsolute_grouping) == 0, nchar(mzDeviationAbsolute_grouping) == 0))
    error <- TRUE
  else{
    mzDeviationAbsolute_grouping <- as.numeric(mzDeviationAbsolute_grouping)
    error <- error | is.na(mzDeviationAbsolute_grouping)
  }
  if(any(is.null(mzDeviationInPPM_grouping), length(mzDeviationInPPM_grouping) == 0, nchar(mzDeviationInPPM_grouping) == 0))
    error <- TRUE
  else{
    mzDeviationInPPM_grouping <- as.numeric(mzDeviationInPPM_grouping)
    error <- error | is.na(mzDeviationInPPM_grouping)
  }
  if(doPrecursorDeisotoping){
    if(any(is.null(mzDeviationAbsolute_precursorDeisotoping), length(mzDeviationAbsolute_precursorDeisotoping) == 0, nchar(mzDeviationAbsolute_precursorDeisotoping) == 0))
      error <- TRUE
    else{
      mzDeviationAbsolute_precursorDeisotoping <- as.numeric(mzDeviationAbsolute_precursorDeisotoping)
      error <- error | is.na(mzDeviationAbsolute_precursorDeisotoping)
    }
    if(any(is.null(mzDeviationInPPM_precursorDeisotoping), length(mzDeviationInPPM_precursorDeisotoping) == 0, nchar(mzDeviationInPPM_precursorDeisotoping) == 0))
      error <- TRUE
    else{
      mzDeviationInPPM_precursorDeisotoping <- as.numeric(mzDeviationInPPM_precursorDeisotoping)
      error <- error | is.na(mzDeviationInPPM_precursorDeisotoping)
    }
  }
  if(any(is.null(maximumRtDifference), length(maximumRtDifference) == 0, nchar(maximumRtDifference) == 0))
    error <- TRUE
  else{
    maximumRtDifference <- as.numeric(maximumRtDifference)
    error <- error | is.na(maximumRtDifference)
  }
  if(doMs2PeakGroupDeisotoping){
    if(any(is.null(mzDeviationAbsolute_ms2PeakGroupDeisotoping), length(mzDeviationAbsolute_ms2PeakGroupDeisotoping) == 0, nchar(mzDeviationAbsolute_ms2PeakGroupDeisotoping) == 0))
      error <- TRUE
    else{
      mzDeviationAbsolute_ms2PeakGroupDeisotoping <- as.numeric(mzDeviationAbsolute_ms2PeakGroupDeisotoping)
      error <- error | is.na(mzDeviationAbsolute_ms2PeakGroupDeisotoping)
    }
    if(any(is.null(mzDeviationInPPM_ms2PeakGroupDeisotoping), length(mzDeviationInPPM_ms2PeakGroupDeisotoping) == 0, nchar(mzDeviationInPPM_ms2PeakGroupDeisotoping) == 0))
      error <- TRUE
    else{
      mzDeviationInPPM_ms2PeakGroupDeisotoping <- as.numeric(mzDeviationInPPM_ms2PeakGroupDeisotoping)
      error <- error | is.na(mzDeviationInPPM_ms2PeakGroupDeisotoping)
    }
  }
  
  if(any(is.null(proportionOfMatchingPeaks_ms2PeakGroupDeisotopingHere), length(proportionOfMatchingPeaks_ms2PeakGroupDeisotopingHere) == 0, nchar(proportionOfMatchingPeaks_ms2PeakGroupDeisotopingHere) == 0))
    error <- TRUE
  else{
    proportionOfMatchingPeaks_ms2PeakGroupDeisotopingHere <- as.numeric(proportionOfMatchingPeaks_ms2PeakGroupDeisotopingHere)
    error <- error | is.na(proportionOfMatchingPeaks_ms2PeakGroupDeisotopingHere)
  }
  if(any(is.null(mzDeviationAbsolute_mappingHere), length(mzDeviationAbsolute_mappingHere) == 0, nchar(mzDeviationAbsolute_mappingHere) == 0))
    error <- TRUE
  else{
    mzDeviationAbsolute_mappingHere <- as.numeric(mzDeviationAbsolute_mappingHere)
    error <- error | is.na(mzDeviationAbsolute_mappingHere)
  }
  # if(any(is.null(minimumNumberOfMS2PeaksPerGroupHere), length(minimumNumberOfMS2PeaksPerGroupHere) == 0, nchar(minimumNumberOfMS2PeaksPerGroupHere) == 0))
  #   error <- TRUE
  # else{
  #   minimumNumberOfMS2PeaksPerGroupHere <- as.numeric(minimumNumberOfMS2PeaksPerGroupHere)
  #   error <- error | is.na(minimumNumberOfMS2PeaksPerGroupHere)
  # }
  
  if(error){
    setImportState()
    output$fileInfo <- renderText({paste("There are invalid parameter values. Please check the parameters and press 'Import MS\u00B9 and MS/MS data' again.")})
    return()
  }
  
  ## box parameters
  print(paste("Observe importMs1Ms2Data", "e", error, "mi", minimumIntensityOfMaximalMS2peak, "mp", minimumProportionOfMS2peaks, "ga", mzDeviationAbsolute_grouping, "gr", mzDeviationInPPM_grouping, "pd", doPrecursorDeisotoping, "pa", mzDeviationAbsolute_precursorDeisotoping, "pr", mzDeviationInPPM_precursorDeisotoping, "mr", maximumRtDifference, "fd", doMs2PeakGroupDeisotoping, "fa", mzDeviationAbsolute_ms2PeakGroupDeisotoping, "fr", mzDeviationInPPM_ms2PeakGroupDeisotoping, "pm", proportionOfMatchingPeaks_ms2PeakGroupDeisotopingHere, "ma", mzDeviationAbsolute_mappingHere))
  parameterSet <- list()
  parameterSet$projectName                                       <- projectName
  parameterSet$projectDescription                                <- projectDescription
  parameterSet$toolVersion                                       <- paste(toolName, toolVersion, sep = " ")
  parameterSet$minimumIntensityOfMaximalMS2peak                  <- minimumIntensityOfMaximalMS2peak
  parameterSet$minimumProportionOfMS2peaks                       <- minimumProportionOfMS2peaks
  parameterSet$mzDeviationAbsolute_grouping                      <- mzDeviationAbsolute_grouping
  parameterSet$mzDeviationInPPM_grouping                         <- mzDeviationInPPM_grouping
  parameterSet$doPrecursorDeisotoping                            <- doPrecursorDeisotoping
  parameterSet$mzDeviationAbsolute_precursorDeisotoping          <- mzDeviationAbsolute_precursorDeisotoping
  parameterSet$mzDeviationInPPM_precursorDeisotoping             <- mzDeviationInPPM_precursorDeisotoping
  parameterSet$maximumRtDifference                               <- maximumRtDifference
  parameterSet$doMs2PeakGroupDeisotoping                         <- doMs2PeakGroupDeisotoping
  parameterSet$mzDeviationAbsolute_ms2PeakGroupDeisotoping       <- mzDeviationAbsolute_ms2PeakGroupDeisotoping
  parameterSet$mzDeviationInPPM_ms2PeakGroupDeisotoping          <- mzDeviationInPPM_ms2PeakGroupDeisotoping
  parameterSet$proportionOfMatchingPeaks_ms2PeakGroupDeisotoping <- proportionOfMatchingPeaks_ms2PeakGroupDeisotopingHere
  parameterSet$mzDeviationAbsolute_mapping                       <- mzDeviationAbsolute_mappingHere
  #parameterSet$minimumNumberOfMS2PeaksPerGroup                   <- minimumNumberOfMS2PeaksPerGroupHere
  parameterSet$neutralLossesPrecursorToFragments                 <- neutralLossesPrecursorToFragments
  parameterSet$neutralLossesFragmentsToFragments                 <- neutralLossesFragmentsToFragments
  
  #################################################
  ## convert to project file
  
  ## built matrix
  error <- NULL
  withProgress(message = 'Generating matrix...', value = 0, {
    resultObj <- tryCatch(
      {
        convertToProjectFile(
          filePeakMatrix = fileMs1Path, 
          fileSpectra = fileMs2Path, 
          fileAnnotation = fileAnnotPath,
          parameterSet = parameterSet, 
          progress = TRUE
        )
      }, error = function(e) {
        error <<- e
      }
    )
  })
  
  if(!is.null(error)){
    msg <- paste(
      "There occurred an error while processing the input file. Please check the file format and content and try again.", "\n",
      "Occurred error: ", error, sep = ""
    )
    output$fileInfo <- renderText({msg})
    showErrorDialog(msg)
    setImportState()
    return()
  }
  if(length(resultObj) == 1){
    if(resultObj == "Number of spectra is zero"){
      msg <- paste("There are no MS/MS spectra which fulfill the given criteria. Please refine parameter 'Spectrum intensity' and try 'Import MS\u00B9 and MS/MS data' again.")
      output$fileInfo <- renderText({msg})
      showErrorDialog(msg)
      setImportState()
      return()
    }
  }
  
  error <- NULL
  withProgress(message = 'Processing matrix...', value = 0, {
    lines <- sparseMatrixToString(matrixRows = resultObj$matrixRows, matrixCols = resultObj$matrixCols, matrixVals = resultObj$matrixVals, parameterSet = parameterSet)
    qfeatures <- resultObj$qfeatures
    #################################################
    ## process project file
    
    dataList <<- tryCatch({
        readProjectData(fileLines = lines, progress = TRUE, qfeatures = qfeatures)
      }, error = function(e) {
        error <<- e
      }
    )
  })
  
  if(!is.null(error)){
    msg <- paste(
      "There occurred an error while processing the input file. Please check the file format and content and try again.", "\n",
      "Occurred error: ", error, sep = ""
    )
    output$fileInfo <- renderText({msg})
    showErrorDialog(msg)
    setImportState()
    return()
  }
  
  print(paste("readProjectData do data finished", dataList$minimumMass))
  
  spectraImport  <- paste(
    ## spectra
    resultObj$numberOfParsedSpectra, " / ", resultObj$numberOfSpectraOriginal, " spectra were imported successfully.",
    ifelse(test = resultObj$numberOfParsedSpectra < resultObj$numberOfSpectraOriginal, yes = paste(" (",paste( Filter(nchar, c(
      ifelse(test = resultObj$numberOfSpectraDiscardedDueToNoPeaks      > 0, yes = paste(resultObj$numberOfSpectraDiscardedDueToNoPeaks,      " empty", sep = ""), no = ""), 
      ifelse(test = resultObj$numberOfSpectraDiscardedDueToMaxIntensity > 0, yes = paste(resultObj$numberOfSpectraDiscardedDueToMaxIntensity, " low intensity", sep = ""), no = ""), 
      ifelse(test = resultObj$numberOfSpectraDiscardedDueToTooHeavy     > 0, yes = paste(resultObj$numberOfSpectraDiscardedDueToTooHeavy,     " too heavy", sep = ""), no = "")
    )), collapse = ", "), ")", sep = ""), no = ""),
    sep = ""
  )
  spectraMapping <- paste(
    ## mapping
    resultObj$numberOfPrecursors, " / ", resultObj$numberOfParsedSpectra, " spectra were successfully mapped to MS\u00B9 features.", 
    ifelse(test = resultObj$numberOfPrecursors < resultObj$numberOfParsedSpectra, yes = paste(" (",paste( Filter(nchar, c(
      #ifelse(test = resultObj$numberOfUnmappedPrecursorsMz > 0, yes = paste(resultObj$numberOfUnmappedPrecursorsMz, " with m/z deviation", sep = ""), no = ""), 
      #ifelse(test = resultObj$numberOfUnmappedPrecursorsRt > 0, yes = paste(resultObj$numberOfUnmappedPrecursorsRt, " with RT deviation",  sep = ""), no = "")
      ifelse(test = resultObj$numberOfUnmappedSpectra > 0, yes = paste(resultObj$numberOfUnmappedSpectra, " unmapped",  sep = ""), no = "")
    )), collapse = ", "), ")", sep = ""), no = ""),
    sep = ""
  )
  fragmentImport <- paste(
    ## fragments
    resultObj$numberOfMS2PeaksAboveThreshold, " / ", resultObj$numberOfMS2PeaksOriginal, " fragments were successfully imported.", 
    ifelse(test = resultObj$numberOfMS2PeaksAboveThreshold < resultObj$numberOfMS2PeaksOriginal, yes = paste(" (",paste( Filter(nchar, c(
      ifelse(test = resultObj$numberOfTooHeavyFragments      > 0, yes = paste(resultObj$numberOfTooHeavyFragments,      " too heavy",      sep = ""), no = ""), 
      ifelse(test = resultObj$numberOfMS2PeaksBelowThreshold > 0, yes = paste(resultObj$numberOfMS2PeaksBelowThreshold, " low intensity",  sep = ""), no = "")
    )), collapse = ", "), ")", sep = ""), no = ""),
    sep = ""
  )
  featureImport  <- paste(
    ## MS1 features
    resultObj$numberOfPrecursors, " / ", resultObj$numberOfParsedMs1Features, " MS\u00B9 features were successfully imported.",
    ifelse(test = resultObj$numberOfPrecursors < resultObj$numberOfParsedMs1Features, yes = paste(" (",paste( Filter(nchar, c(
      ifelse(test = resultObj$numberOfRemovedPrecursorIsotopePeaks > 0, yes = paste(resultObj$numberOfRemovedPrecursorIsotopePeaks, " were isotopes",   sep = ""), no = ""), 
      ifelse(test = resultObj$numberOfUnmappedPrecursors           > 0, yes = paste(resultObj$numberOfUnmappedPrecursors,           " without spectra", sep = ""), no = ""), 
      ifelse(test = resultObj$numberOfDuplicatedPrecursors         > 0, yes = paste(resultObj$numberOfDuplicatedPrecursors,         " duplicated",      sep = ""), no = "")
    )), collapse = ", "), ")", sep = ""), no = ""),
    sep = ""
  )
  
  msg <- paste(
    "The data import was successful.", "<br>",
    "<br>",
    spectraImport,  "<br>",
    ifelse(test = resultObj$numberOfParsedMs1Features!=-1, yes = paste(spectraMapping, "<br>", sep = ""), no = ""), 
    fragmentImport, "<br>",
    ifelse(test = resultObj$numberOfParsedMs1Features!=-1, yes = featureImport,  no = ""),
    sep = ""
  )
  showInfoDialog(msg)
  
  ## MS2
  # + returnObj$numberOfSpectraOriginal
  # + returnObj$numberOfMS2PeaksOriginal
  # - returnObj$numberOfMS2PeaksWithNeutralLosses
  # + returnObj$numberOfMS2PeaksAboveThreshold
  # + returnObj$numberOfMS2PeaksBelowThreshold
  # + returnObj$numberOfTooHeavyFragments
  # + returnObj$numberOfSpectraDiscardedDueToNoPeaks
  # + returnObj$numberOfSpectraDiscardedDueToMaxIntensity
  # + returnObj$numberOfSpectraDiscardedDueToTooHeavy
  #
  ## MS1
  # + returnObj$numberOfPrecursors
  # 
  # + returnObj$numberOfDuplicatedPrecursors
  # + returnObj$numberOfUnmappedPrecursors
  # + returnObj$numberOfUnmappedPrecursorsMz
  # + returnObj$numberOfUnmappedPrecursorsRt
  # + returnObj$numberOfParsedSpectra
  # + returnObj$numberOfParsedMs1Features
  # + returnObj$numberOfRemovedPrecursorIsotopePeaks
  
  
  resetWorkspace()
  
  if(importMS1andMS2data)
    state_tabInput$importedOrLoadedFile_s_ <<- c(fileMs1Name, fileMs2Name)
  else
    state_tabInput$importedOrLoadedFile_s_ <<- c(fileMs2Name)
  updateFileInputInfo()
  
  setImportState()
}
obsFileInputSelection <- observeEvent(input$fileInputSelection, {
  updateFileInputInfo()
})
obsApplyImportParameterFile <- observeEvent(input$importParameterFileInput$datapath, {
  filePath <- input$importParameterFileInput$datapath
  fileName <- input$importParameterFileInput$name
  print(paste("Observe importParameterFile", fileName))
  if(is.null(filePath))
    return()
  
  ## read and parse
  fileContent <- readLines(con = filePath)
  parameterSet <- deserializeParameterSetFile(fileContent)
  
  ## apply
  #projectName2 <- parameterSet$projectName
  #projectName2 <- paste(projectName2, " adopted", sep = "")
  #updateTextInput    (session = session, inputId = "projectName",                                 value = projectName2)
  #parameterSet$toolVersion
  updateTextInput    (session = session, inputId = "minimumIntensityOfMaximalMS2peak",            value = parameterSet$minimumIntensityOfMaximalMS2peak)
  updateTextInput    (session = session, inputId = "minimumProportionOfMS2peaks",                 value = parameterSet$minimumProportionOfMS2peaks)
  updateTextInput    (session = session, inputId = "mzDeviationAbsolute_grouping",                value = parameterSet$mzDeviationAbsolute_grouping)
  updateTextInput    (session = session, inputId = "mzDeviationInPPM_grouping",                   value = parameterSet$mzDeviationInPPM_grouping)
  updateCheckboxInput(session = session, inputId = "doPrecursorDeisotoping",                      value = parameterSet$doPrecursorDeisotoping)
  updateTextInput    (session = session, inputId = "mzDeviationAbsolute_precursorDeisotoping",    value = parameterSet$mzDeviationAbsolute_precursorDeisotoping)
  updateTextInput    (session = session, inputId = "mzDeviationInPPM_precursorDeisotoping",       value = parameterSet$mzDeviationInPPM_precursorDeisotoping)
  updateTextInput    (session = session, inputId = "maximumRtDifference",                         value = parameterSet$maximumRtDifference)
  updateCheckboxInput(session = session, inputId = "doMs2PeakGroupDeisotoping",                   value = parameterSet$doMs2PeakGroupDeisotoping)
  updateTextInput    (session = session, inputId = "mzDeviationAbsolute_ms2PeakGroupDeisotoping", value = parameterSet$mzDeviationAbsolute_ms2PeakGroupDeisotoping)
  updateTextInput    (session = session, inputId = "mzDeviationInPPM_ms2PeakGroupDeisotoping",    value = parameterSet$mzDeviationInPPM_ms2PeakGroupDeisotoping)
  #parameterSet$proportionOfMatchingPeaks_ms2PeakGroupDeisotoping
  #parameterSet$mzDeviationAbsolute_mapping
  #parameterSet$minimumNumberOfMS2PeaksPerGroup
  updateCheckboxInput(session = session, inputId = "neutralLossesPrecursorToFragments",           value = parameterSet$neutralLossesPrecursorToFragments)
  updateCheckboxInput(session = session, inputId = "neutralLossesFragmentsToFragments",           value = parameterSet$neutralLossesFragmentsToFragments)
})
updateFileInputInfo <- function(){
  fileInputSelection <- input$fileInputSelection
  filePath <- input$matrixFile$datapath
  fileName <- input$matrixFile$name
  fileMs1Path <- input$ms1DataFile$datapath
  fileMs1Name <- input$ms1DataFile$name
  fileMs2Path <- input$ms2DataFile$datapath
  fileMs2Name <- input$ms2DataFile$name
  #exampleDataSelection <- input$exampleDataSelection
  
  if(all(fileInputSelection == "Example data"))
    output$fileInfo <- renderText({paste("Please press 'Load example data' to load the full example data set")})
  if(all(fileInputSelection == "Load project", is.null(filePath)))
    output$fileInfo <- renderText({paste("Please select a project file and press 'Load project data'")})
  if(all(fileInputSelection == "Load project", !is.null(filePath), any(is.null(state_tabInput$importedOrLoadedFile_s_), fileName != state_tabInput$importedOrLoadedFile_s_)))
    output$fileInfo <- renderText({paste("Please press 'Load project data'")})
  if(all(fileInputSelection == "Load project", !is.null(filePath), !is.null(state_tabInput$importedOrLoadedFile_s_), fileName == state_tabInput$importedOrLoadedFile_s_))
    output$fileInfo <- renderText({paste(fileName)})
  if(all(fileInputSelection == "Import data", is.null(fileMs1Path), is.null(fileMs2Path)))
    output$fileInfo <- renderText({paste("Please select a metabolite profile and a MS/MS library and press 'Import MS1 and MS/MS data' or select a MS/MS library and press 'Import MS/MS data'")})
  if(all(fileInputSelection == "Import data", is.null(fileMs1Path), !is.null(fileMs2Path)))
    output$fileInfo <- renderText({paste("Please press 'Import MS/MS data' or select a metabolite profile and press 'Import MS1 and MS/MS data'")})
  if(all(fileInputSelection == "Import data", !is.null(fileMs1Path), is.null(fileMs2Path)))
    output$fileInfo <- renderText({paste("Please select a MS/MS library and press 'Import MS1 and MS/MS data'")})
  if(all(fileInputSelection == "Import data", !is.null(fileMs1Path), !is.null(fileMs2Path), any(is.null(state_tabInput$importedOrLoadedFile_s_), c(fileMs1Name,fileMs2Name) != state_tabInput$importedOrLoadedFile_s_)))
    output$fileInfo <- renderText({paste("Please press 'Import MS1 and MS/MS data'")})
  if(all(fileInputSelection == "Import data", !is.null(fileMs1Path), !is.null(fileMs2Path), !is.null(state_tabInput$importedOrLoadedFile_s_), c(fileMs1Name,fileMs2Name) == state_tabInput$importedOrLoadedFile_s_))
    output$fileInfo <- renderText({paste(fileMs1Name, "\n", fileMs2Name, sep = "")})
}

output$fileInfo <- renderText({
  print(paste("init output$fileInfo"))
  paste("Please select a project file and press 'Load project data'")
})

suspendOnExitFunctions <- c(suspendOnExitFunctions, function(){
  print("Suspending tabInput observers")
  obsFile$suspend()
  obsLoadProjectData$suspend()
  obsLoadExampleData$suspend()
  obsImportMs1DataFile$suspend()
  obsImportMs2DataFile$suspend()
  obsImportMs1Ms2Data$suspend()
  obsImportMs2Data$suspend()
  obsFileInputSelection$suspend()
  obsApplyImportParameterFile$suspend()
})

================
File: inst/MetFamily/app_files/server_guiTabMsmsFilter.R
================
fragmentPlotRange    <- reactiveValues(xMin = NULL, xMax = NULL, xInterval = NULL, xIntervalSize = NULL)

resetWorkspaceFunctions <- c(resetWorkspaceFunctions, function(){
  print("Reset tabMsmsFilter state")
  state_tabClassifier$classifierLoaded <<- FALSE
  state_tabClassifier$classifierClassSelected <<- FALSE
  state_tabClassifier$classifierClassMS1featureSelected <<- FALSE
  
  #########################################################################################
  ## update fragment plot
  min <- min(dataList$ms2_masses)
  max <- max(dataList$ms2_masses)
  
  ## reset plot range
  fragmentPlotRange$xMin <<- min
  fragmentPlotRange$xMax <<- max
  fragmentPlotRange$xInterval <<- c(min, max)
  fragmentPlotRange$xIntervalSize <<- (max - min)
  
  output$fragmentPlot <- renderPlot({
    print(paste("### MS2 ### all init"))
    plotFragmentsFromDataList(dataList = dataList, xInterval = fragmentPlotRange$xInterval)
    #}, bg = "transparent")
  })
})

obsFragmentPlotdblClick <- observeEvent(input$fragmentPlot_dblclick, {
  brush <- input$fragmentPlot_brush
  print(paste("observe fragmentPlot dblclick", paste(brush, collapse = "; ")))
  
  if (!is.null(brush)) {
    ## set range
    min <- brush$xmin
    max <- brush$xmax
  } else {
    ## reset range
    min <- min(dataList$ms2_masses)
    max <- max(dataList$ms2_masses)
  }
  
  fragmentPlotRange$xMin <<- min
  fragmentPlotRange$xMax <<- max
  fragmentPlotRange$xInterval <<- c(min, max)
  fragmentPlotRange$xIntervalSize <<- max - min
})
obsApplyGlobalMS2filters <- observeEvent(input$applyGlobalMS2filters, {
  session$sendCustomMessage("disableButton", "applyGlobalMS2filters")
  applyGlobalMS2filters <- as.numeric(input$applyGlobalMS2filters)
  
  print(paste("Observe applyGlobalMS2filters", applyGlobalMS2filters))
  
  #################################################
  ## check if button was hit
  #if(applyGlobalMS2filters == applyGlobalMS2filtersButtonValue)
  #  return()
  #applyGlobalMS2filtersButtonValue <<- applyGlobalMS2filters
  
  #################################################
  ## get inputs
  filter_ms2_masses1  <- input$globalFilter_ms2_masses1
  filter_ms2_masses2  <- input$globalFilter_ms2_masses2
  filter_ms2_masses3  <- input$globalFilter_ms2_masses3
  filter_ms2_ppm      <- input$globalFilter_ms2_ppm
  
  applyGlobalMS2filters(filter_ms2_masses1, filter_ms2_masses2, filter_ms2_masses3, filter_ms2_ppm)
  session$sendCustomMessage("enableButton", "applyGlobalMS2filters")
})
obsClearGlobalMS2filters <- observeEvent(input$clearGlobalMS2filters, {
  session$sendCustomMessage("disableButton", "clearGlobalMS2filters")
  clearGlobalMS2filters <- as.numeric(input$clearGlobalMS2filters)
  
  print(paste("Observe clearGlobalMS2filters", clearGlobalMS2filters))
  
  #################################################
  ## check if button was hit
  #if(clearGlobalMS2filters == clearGlobalMS2filtersButtonValue)
  #  return()
  #clearGlobalMS2filtersButtonValue <<- clearGlobalMS2filters
  
  #################################################
  ## get inputs
  filter_ms2_masses1  <- ""
  filter_ms2_masses2  <- ""
  filter_ms2_masses3  <- ""
  filter_ms2_ppm      <- 20
  
  applyGlobalMS2filters(filter_ms2_masses1, filter_ms2_masses2, filter_ms2_masses3, filter_ms2_ppm)
  session$sendCustomMessage("enableButton", "clearGlobalMS2filters")
})

suspendOnExitFunctions <- c(suspendOnExitFunctions, function(){
  print("Suspending tabMsmsFilter observers")
  obsFragmentPlotdblClick$suspend()
  obsApplyGlobalMS2filters$suspend()
  obsClearGlobalMS2filters$suspend()
})

================
File: inst/MetFamily/app_files/server_guiTabPca.R
================
scoresGroupsLegendEntryHeight <- 20

pcaDataList <- NULL

scoresGroups <- NULL

pcaScoresPlotRange   <- reactiveValues(
  xMin = NULL, xMax = NULL, xInterval = NULL, xIntervalSize = NULL, 
  yMin = NULL, yMax = NULL, yInterval = NULL, yIntervalSize = NULL
)
pcaLoadingsPlotRange <- reactiveValues(
  xMin = NULL, xMax = NULL, xInterval = NULL, xIntervalSize = NULL, 
  yMin = NULL, yMax = NULL, yInterval = NULL, yIntervalSize = NULL
)


state_tabPca <- reactiveValues(
  ## plot controls
  ## changing showScoresLabels = TRUE to FALSE
  showScoresLabels = FALSE,
  loadingsLabels = "None",
  showLoadingsFeaturesAnnotated = TRUE, 
  showLoadingsFeaturesUnannotated = TRUE, 
  showLoadingsFeaturesSelected = TRUE, 
  showLoadingsFeaturesUnselected = TRUE,
  showLoadingsAbundance = FALSE,
  ## annotation legend height
  annotationLegendHeightPca = -1,
  ## plot annotations: $setOfAnnotations, $setOfColors
  annotationsPca = NULL,
  scoresGroupsLegendHeight = -1
)
resetWorkspaceFunctions <- c(resetWorkspaceFunctions, function(){
  print("Reset tabPca state")
  ## plot controls
  ###showScoresLabels from TRUE to FALSE
  state_tabPca$showScoresLabels <<- FALSE
  state_tabPca$loadingsLabels   <<- "None"
  state_tabPca$showLoadingsFeaturesAnnotated   <<- TRUE 
  state_tabPca$showLoadingsFeaturesUnannotated <<- TRUE 
  state_tabPca$showLoadingsFeaturesSelected    <<- TRUE 
  state_tabPca$showLoadingsFeaturesUnselected  <<- TRUE
  state_tabPca$showLoadingsAbundance           <<- FALSE
  ## annotation legend height
  state_tabPca$annotationLegendHeightPca <<- -1
  ## plot annotations: $setOfAnnotations, $setOfColors
  state_tabPca$annotationsPca <<- NULL
  state_tabPca$scoresGroupsLegendHeight <<- -1
  
  ## reset variables
  pcaDataList <<- NULL
  scoresGroups <<- NULL
  
  ## reset plot range
  pcaScoresPlotRange$xMin <<- NULL
  pcaScoresPlotRange$xMax <<- NULL
  pcaScoresPlotRange$xInterval <<- NULL
  pcaScoresPlotRange$xIntervalSize <<- NULL
  pcaScoresPlotRange$yMin <<- NULL
  pcaScoresPlotRange$yMax <<- NULL
  pcaScoresPlotRange$yInterval <<- NULL
  pcaScoresPlotRange$yIntervalSize <<- NULL
  pcaLoadingsPlotRange$xMin <<- NULL
  pcaLoadingsPlotRange$xMax <<- NULL
  pcaLoadingsPlotRange$xInterval <<- NULL
  pcaLoadingsPlotRange$xIntervalSize <<- NULL
  pcaLoadingsPlotRange$yMin <<- NULL
  pcaLoadingsPlotRange$yMax <<- NULL
  pcaLoadingsPlotRange$yInterval <<- NULL
  pcaLoadingsPlotRange$yIntervalSize <<- NULL
  
  ## number of components for PCA
  maximumNumberOfComponents <- length(dataList$includedSamples(dataList$groupSampleDataFrame)) - 1
  maximumNumberOfComponents <- min(maximumNumberOfComponents, 5)
  if(maximumNumberOfComponents < 2){
    updateSelectInput(session = session, inputId = "pcaDimensionOne", choices = "1")
    updateSelectInput(session = session, inputId = "pcaDimensionTwo", choices = "1")
    shinyjs::disable(id = "pcaDimensionOne")
    shinyjs::disable(id = "pcaDimensionTwo")
  } else {
    updateSelectInput(session = session, inputId = "pcaDimensionOne", choices = seq_len(maximumNumberOfComponents), selected = 1)
    updateSelectInput(session = session, inputId = "pcaDimensionTwo", choices = seq_len(maximumNumberOfComponents), selected = 2)
  }
})


obsDrawPCA <- observeEvent(input$drawPCAplots, {
  session$sendCustomMessage("disableButton", "drawPCAplots")
  #################################################
  ## get input
  drawPlots <- as.numeric(input$drawPCAplots)
  
  print(paste("Observe draw PCA plots", drawPlots))
  
  ## check if button was hit
  #if(drawPlots == drawPCAButtonValue)
  #  return()
  #drawPCAButtonValue <<- drawPlots
  
  ms1AnalysisMethod <- input$ms1AnalysisMethod
  pcaScaling      <- input$pcaScaling
  pcaLogTransform <- input$pcaLogTransform
  pcaDimensionOne <<- as.numeric(input$pcaDimensionOne)
  pcaDimensionTwo <<- as.numeric(input$pcaDimensionTwo)
  
  calculatePca(ms1AnalysisMethod, pcaScaling, pcaLogTransform, pcaDimensionOne, pcaDimensionTwo)
})

calculatePca <- function(ms1AnalysisMethod, pcaScaling, pcaLogTransform, pcaDimensionOne, pcaDimensionTwo){
  #################################################
  ## calc PCA
  pca <- calculatePCA(dataList = dataList, filterObj = filterPca, ms1AnalysisMethod = ms1AnalysisMethod, scaling = pcaScaling, logTransform = pcaLogTransform)
  print("enter the line ...line number 114")
  #print(pca)
  #print(colnames(as.data.frame(dataList$dataFrameInfos)))
  #print(table(as.data.frame(dataList$dataFrameInfos)$"m/z"))
  #print(table(as.data.frame(dataList$dataFrameInfos)$"RT"))
  #print(table(as.data.frame(dataList$dataFrameInfos)$"Annotation"))
  #print(table(as.data.frame(dataList$dataFrameInfos)$"Average Rt(min)"))
  #print(table(as.data.frame(dataList$dataFrameInfos)$"Average Mz"))
  #print(table(as.data.frame(dataList$dataFrameInfos)$"Metabolite name"))
  #print(table(as.data.frame(dataList$dataFrameInfos)$"Adduct ion name"))
  #print(table(as.data.frame(dataList$dataFrameInfos)$"MySample"))
  ########
  #print(as.data.frame(table(unlist(dataList))))
  #########################################
  pcaDataList <<- list()
  pcaDataList$pcaObj <<- pca
  pcaDataList$pcaScoresX <<- pca$scores[, pcaDimensionOne]
  pcaDataList$pcaScoresY <<- pca$scores[, pcaDimensionTwo]
  pcaDataList$pcaLoadingsX <<- pca$loadings[, pcaDimensionOne]
  pcaDataList$pcaLoadingsY <<- pca$loadings[, pcaDimensionTwo]
  pcaDataList$dimensionOne <<- pcaDimensionOne
  pcaDataList$dimensionTwo <<- pcaDimensionTwo
  
  ##########################
  ## hca selections
  if(!is.null(listForTable_Fragment_HCA)){ ## selection from fragment
    fragmentIndex <- which(dataList$fragmentMasses == ms2PlotValues$fragmentListClicked$fragmentMasses[[selectionFragmentSelectedFragmentIndex]])
    precursorSet  <- which(dataList$featureMatrix[, fragmentIndex] != 0)
    selectionByFragmentInitPca(precursorSet)
  } else {
    selectionByFragmentReset()
  }
  if(!is.null(listForTable_Analysis_HCA)){ ## selection from HCA
    precursorSet <- getPrecursorSetFromTreeSelections(clusterDataList = clusterDataList, clusterLabels = selectionAnalysisTreeNodeSet)
    selectionByAnalysisInitPca(precursorSet)
  } else {
    selectionByAnalysisReset()
  }
  if(!is.null(filterSearch)){ ## selection from search
    selectionBySearchInitPca(filterSearch$filter)
  } else {
    selectionBySearchReset()
  }
  
  ##########################
  ## reset MS2 stuff
  if(!state$showHCAplotPanel){
    ms2PlotValues$fragmentListClicked <<- NULL
    ms2PlotValues$fragmentListHovered <<- NULL
    dendrogramFragmentStatistics <<- FALSE
  }
  
  ##########################
  ## draw
  resetPcaPlotRange()
  drawPcaPlots(consoleInfo = "drawPCA output$plotPcaScores")
  drawMS2Plot(consoleInfo = "drawPCA output$plotMS2")
  drawAnnotationLegendPCA(consoleInfo = "init output$plotAnnoLegend")
  
  scoresGroups <<- list(
    grouXXXps = filterPca$grouXXXps,
    colors = colorPaletteScores()[unlist(lapply(X = filterPca$grouXXXps, FUN = dataList$groupIdxFromGroupName))]
  )
  state_tabPca$scoresGroupsLegendHeight <<- scoresGroupsLegendEntryHeight * (length(scoresGroups$grouXXXps) + 1)
  drawScoresGroupsLegend(consoleInfo = "init output$plotScoresGroupsLegend")
  
  if(!state$anyPlotDrawn){
    drawMS2Legend(consoleInfo = "init output$ms2LegendPlot")
    drawFragmentDiscriminativityLegend(consoleInfo = "init output$plotFragmentDiscriminativityLegend")
    drawHeatmapLegend(consoleInfo = "init output$plotHeatmapLegend")
    drawDendrogramLegend(consoleInfo = "init output$calcPlotDendrogramLegend")
    state$anyPlotDrawn <<- TRUE
  }
  
  ## state
  state$showPCAplotPanel <<- TRUE
  state$plotPcaShown <<- TRUE
  updateChangePlotRadioButton()
  
  ##########################
  ## update info and tip
  output$information <- renderText({
    print(paste("update output$information clear"))
    paste("", sep = "")
  })
  output$tip <- renderText({
    print(paste("update output$tip"))
    paste("Hover a score node in the scores plot or a loadings node in the loadings plot to view information about the corresponding sample or MS\u00B9 feature respectively.", "Brush and double-click to zoom in.", "Double-click to zoom out.", sep = "\n")
  })
  session$sendCustomMessage("enableButton", "drawPCAplots")
}
drawPcaPlots <- function(consoleInfo = NULL){
  drawPcaScoresPlot(consoleInfo = consoleInfo)
  drawPcaLoadingsPlot(consoleInfo = consoleInfo)
}
drawPcaScoresPlot <- function(consoleInfo = NULL){
  output$plotPcaScores <- renderPlot({
    print(paste("### psp ###", consoleInfo))
    drawPcaScoresPlotImpl()
  })
}
drawPcaLoadingsPlot <- function(consoleInfo = NULL){
  output$plotPcaLoadings <- renderPlot({
    print(paste("### plp ###", consoleInfo))
    drawPcaLoadingsPlotImpl()
  })
}

drawAnnotationLegendPCA <- function(consoleInfo = NULL){
  output$plotAnnoLegendPCA <- renderPlot({
    print(paste("### leg ###", consoleInfo))
    drawAnnotationLegendPCAimpl()
  })
}
drawScoresGroupsLegend <- function(consoleInfo = NULL){
  output$plotScoresGroupsLegend <- renderPlot({
    print(paste("### leg ###", consoleInfo))
    drawScoresGroupsLegendImpl()
  })
}

resetPcaPlotRange <- function(){
  minX <- min(pcaDataList$pcaObj$scores[, pcaDataList$dimensionOne])
  maxX <- max(pcaDataList$pcaObj$scores[, pcaDataList$dimensionOne])
  minY <- min(pcaDataList$pcaObj$scores[, pcaDataList$dimensionTwo])
  maxY <- max(pcaDataList$pcaObj$scores[, pcaDataList$dimensionTwo])
  
  if(any(is.na(c(minX, maxX, minY, maxY)))){
    minX <- -1
    maxX <- 1
    minY <- -1
    maxY <- 1
  }
  
  pcaScoresPlotRange$xMin <<- minX
  pcaScoresPlotRange$xMax <<- maxX
  pcaScoresPlotRange$xInterval <<- c(minX, maxX)
  pcaScoresPlotRange$xIntervalSize <<- maxX - minX
  pcaScoresPlotRange$yMin <<- minY
  pcaScoresPlotRange$yMax <<- maxY
  pcaScoresPlotRange$yInterval <<- c(minY, maxY)
  pcaScoresPlotRange$yIntervalSize <<- maxY - minY
  
  minX <- min(pcaDataList$pcaObj$loadings[, pcaDataList$dimensionOne])
  maxX <- max(pcaDataList$pcaObj$loadings[, pcaDataList$dimensionOne])
  minY <- min(pcaDataList$pcaObj$loadings[, pcaDataList$dimensionTwo])
  maxY <- max(pcaDataList$pcaObj$loadings[, pcaDataList$dimensionTwo])
  
  if(any(is.na(c(minX, maxX, minY, maxY)))){
    minX <- -1
    maxX <- 1
    minY <- -1
    maxY <- 1
  }
  
  pcaLoadingsPlotRange$xMin <<- minX
  pcaLoadingsPlotRange$xMax <<- maxX
  pcaLoadingsPlotRange$xInterval <<- c(minX, maxX)
  pcaLoadingsPlotRange$xIntervalSize <<- maxX - minX
  pcaLoadingsPlotRange$yMin <<- minY
  pcaLoadingsPlotRange$yMax <<- maxY
  pcaLoadingsPlotRange$yInterval <<- c(minY, maxY)
  pcaLoadingsPlotRange$yIntervalSize <<- maxY - minY
}

if(FALSE){
obsPCAscoresHover <- observeEvent(input$plotPcaScores_hover, {
  hoverX <- input$plotPcaScores_hover$x
  hoverY <- input$plotPcaScores_hover$y
  plotWidth  <- session$clientData$output_plotPcaScores_width
  plotHeight <- session$clientData$output_plotPcaScores_height
  
  if(is.null(hoverX) | is.null(hoverY))
    return()
  print(paste("Observe PCA scores hover", hoverX, hoverY))
  
  #################################################
  ## decide whether the hover is close enough to trigger event
  minimumIndex <- getSelectedPOI_XY(
    mouseX = hoverX, mouseY = hoverY, poiCoordinatesX = pcaDataList$pcaScoresX, poiCoordinatesY = pcaDataList$pcaScoresY,
    plotWidth = plotWidth, plotHeight = plotHeight, plotRangeX = pcaScoresPlotRange$xIntervalSize, plotRangeY = pcaScoresPlotRange$yIntervalSize
  )
  print(paste("Observe PCA scores hover", hoverX, hoverY, minimumIndex))
  
  if(is.null(minimumIndex)){
    #output$information <- renderText({
    #  print(paste("update output$information PCA scores hover", sep = ""))
    #  paste("", group, sep = "")
    #})
  }
  else{
    dataColumnName <- filterPca$sampleSet[[minimumIndex]]
    #dataColumnName <- dataList$dataColumnsNameFunctionFromGroupNames(grouXXXps = filterPca$grouXXXps, sampleNamesToExclude = dataList$excludedSamples(dataList$groupSampleDataFrame))[[minimumIndex]]
    group <- dataList$groupNameFunctionFromDataColumnName(dataColumnName = dataColumnName, sampleNamesToExclude = dataList$excludedSamples(dataList$groupSampleDataFrame))
    output$information <- renderText({
      print(paste("update output$information PCA scores hover", sep = ""))
      paste("Sample '", dataColumnName , "' is a replicate of group '", group, "'.", sep = "")
    })
  }
  
  output$tip <- renderText({
    print(paste("update output$tip"))
    paste("Hover a scores node to view information about the sample.", "Brush and double-click to zoom in.", "Double-click to zoom out.", sep = "\n")
  })
})
}
obsPCAscoresDblClick <- observeEvent(input$plotPcaScores_dblclick, {
  brush <- input$plotPcaScores_brush
  
  print(paste("observe PCAscores dblclick", is.null(brush)))
  
  if (!is.null(brush)) {
    ## set range
    pcaScoresPlotRange$xMin <<- brush$xmin
    pcaScoresPlotRange$xMax <<- brush$xmax
    pcaScoresPlotRange$xInterval <<- c(brush$xmin, brush$xmax)
    pcaScoresPlotRange$xIntervalSize <<- brush$xmax - brush$xmin
    pcaScoresPlotRange$yMin <<- brush$ymin
    pcaScoresPlotRange$yMax <<- brush$ymax
    pcaScoresPlotRange$yInterval <<- c(brush$ymin, brush$ymax)
    pcaScoresPlotRange$yIntervalSize <<- brush$ymax - brush$ymin
  } else {
    ## reset range
    minX <- min(pcaDataList$pcaObj$scores[, pcaDataList$dimensionOne])
    maxX <- max(pcaDataList$pcaObj$scores[, pcaDataList$dimensionOne])
    minY <- min(pcaDataList$pcaObj$scores[, pcaDataList$dimensionTwo])
    maxY <- max(pcaDataList$pcaObj$scores[, pcaDataList$dimensionTwo])
    
    pcaScoresPlotRange$xMin <<- minX
    pcaScoresPlotRange$xMax <<- maxX
    pcaScoresPlotRange$xInterval <<- c(minX, maxX)
    pcaScoresPlotRange$xIntervalSize <<- maxX - minX
    pcaScoresPlotRange$yMin <<- minY
    pcaScoresPlotRange$yMax <<- maxY
    pcaScoresPlotRange$yInterval <<- c(minY, maxY)
    pcaScoresPlotRange$yIntervalSize <<- maxY - minY
  }
})
obsPCAloadingsClick <- observeEvent(input$plotPcaLoadings_click, {
  clickX <- input$plotPcaLoadings_click$x
  clickY <- input$plotPcaLoadings_click$y
  plotWidth  <- session$clientData$output_plotPcaLoadings_width
  plotHeight <- session$clientData$output_plotPcaLoadings_height
  brush <- input$plotPcaLoadings_brush
  
  if(!is.null(brush))
    return()
  if(is.null(clickX) | is.null(clickY))
    return()
  print(paste("Observe PCA Loadings click", clickX, clickY))
  
  #################################################
  ## decide whether the hover is close enough to trigger event
  minimumIndex <- getSelectedPOI_XY(
    mouseX = clickX, mouseY = clickY, poiCoordinatesX = pcaDataList$pcaLoadingsX, poiCoordinatesY = pcaDataList$pcaLoadingsY,
    plotWidth = plotWidth, plotHeight = plotHeight, plotRangeX = pcaLoadingsPlotRange$xIntervalSize, plotRangeY = pcaLoadingsPlotRange$yIntervalSize
  )
  print(paste("Observe PCA Loadings hover", clickX, clickY, minimumIndex))
  
  if(is.null(minimumIndex)){
    ## reset stuff
    
    ms2PlotValues$fragmentListClicked <<- NULL
    ms2PlotValues$fragmentListHovered <<- NULL
    dendrogramFragmentStatistics <<- FALSE
    
    selectionByAnalysisReset()
    selectionByFragmentReset()
  } else {
    ## loadng selection
    precursorIndex <- filterPca$filter[[minimumIndex]]
    ## fetch ms2 spectrum
    resultObj <- getMS2spectrumInfoForPrecursor(dataList = dataList, precursorIndex = precursorIndex)
    
    ## keep fragment selection
    selectionFragmentSelectedFragmentIndexNew <- NULL
    if(!is.null(selectionFragmentSelectedFragmentIndex)){
      fragmentMass <- ms2PlotValues$fragmentListClicked$fragmentMasses[[selectionFragmentSelectedFragmentIndex]]
      if(fragmentMass %in% resultObj$fragmentMasses)
        selectionFragmentSelectedFragmentIndexNew <- which(resultObj$fragmentMasses %in% fragmentMass)
    }
    
    ms2PlotValues$fragmentListClicked <<- resultObj
    ms2PlotValues$fragmentListHovered <<- NULL
    dendrogramFragmentStatistics <<- FALSE
    
    selectionByPca(minimumIndex)
    
    ## update the selected fragment in case of overlapping spectra
    if(!is.null(selectionFragmentSelectedFragmentIndexNew))
      selectionByFragment(selectionFragmentSelectedFragmentIndexNew)
    else
      selectionByFragmentReset()
  }
  
  ## MS2 plot
  resetMS2PlotRange()
  drawMS2Plot(consoleInfo = "PCA loadings click output$plotMS2")
  
  ## TODO remove plot call
  drawPcaLoadingsPlot(consoleInfo = "PCA loadings click output$plotPcaLoadings")
  
  if(state$showHCAplotPanel)
    ## update dendrogram plot
    drawDendrogramPlot(consoleInfo = "PCA loadings click output$plotDendrogram", withHeatmap = TRUE)
})
if(FALSE){
obsPCAloadingsHover <- observeEvent(input$plotPcaLoadings_hover, {
  hoverX <- input$plotPcaLoadings_hover$x
  hoverY <- input$plotPcaLoadings_hover$y
  plotWidth  <- session$clientData$output_plotPcaLoadings_width
  plotHeight <- session$clientData$output_plotPcaLoadings_height
  
  if(is.null(hoverX) | is.null(hoverY))
    return()
  print(paste("Observe PCA Loadings hover", hoverX, hoverY))
  
  #################################################
  ## decide whether the hover is close enough to trigger event
  minimumIndex <- getSelectedPOI_XY(
    mouseX = hoverX, mouseY = hoverY, poiCoordinatesX = pcaDataList$pcaLoadingsX, poiCoordinatesY = pcaDataList$pcaLoadingsY,
    plotWidth = plotWidth, plotHeight = plotHeight, plotRangeX = pcaLoadingsPlotRange$xIntervalSize, plotRangeY = pcaLoadingsPlotRange$yIntervalSize
  )
  if(is.null(minimumIndex)){
    ## no loading hovered
    ms2PlotValues$fragmentListHovered <<- NULL
    #output$information <- renderText({
    #  print(paste("update output$information PCA Loadings hover ", minimumIndex, sep = ""))
    #  paste("", sep = "")
    #})
  } else {
    print(paste("Observe PCA Loadings hover", hoverX, hoverY, minimumIndex))
    
    #################################################
    ## fetch ms2 spectrum
    precursorIndex <- filterPca$filter[[minimumIndex]]
    resultObj <- getMS2spectrumInfoForPrecursor(dataList = dataList, precursorIndex = precursorIndex)
    if(all(!is.null(selectionAnalysisPcaLoadingSet), minimumIndex == selectionAnalysisPcaLoadingSet)){
      ## reverse MS2 to clicked stuff
      ms2PlotValues$fragmentListHovered <<- NULL
    } else {
      ms2PlotValues$fragmentListHovered <<- resultObj
    }
    
    #output$information <- renderText({
    #  print(paste("update output$information PCA Loadings hover ", precursorIndex, sep = ""))
    #  paste(resultObj$infoText, sep = "")
    #})
  }
  
  drawMS2Plot(consoleInfo = "loadings hover output$plotMS2")
  
  output$tip <- renderText({
    print(paste("update output$tip"))
    paste(
      "Hover or click a loadings node to view information about the corresponding MS\u00B9 feature.", 
      "Brush and double-click to zoom in.", 
      "Double-click to zoom out.", 
      sep = "\n"
    )
  })
})
}
obsPCAloadingsDblClick <- observeEvent(input$plotPcaLoadings_dblclick, {
  brush <- input$plotPcaLoadings_brush
  
  print(paste("observe PCAloadings dblclick", is.null(brush)))
  
  if (!is.null(brush)) {
    ## set range
    pcaLoadingsPlotRange$xMin <<- brush$xmin
    pcaLoadingsPlotRange$xMax <<- brush$xmax
    pcaLoadingsPlotRange$xInterval <<- c(brush$xmin, brush$xmax)
    pcaLoadingsPlotRange$xIntervalSize <<- brush$xmax - brush$xmin
    pcaLoadingsPlotRange$yMin <<- brush$ymin
    pcaLoadingsPlotRange$yMax <<- brush$ymax
    pcaLoadingsPlotRange$yInterval <<- c(brush$ymin, brush$ymax)
    pcaLoadingsPlotRange$yIntervalSize <<- brush$ymax - brush$ymin
  } else {
    ## reset range
    minX <- min(pcaDataList$pcaObj$loadings[, pcaDataList$dimensionOne])
    maxX <- max(pcaDataList$pcaObj$loadings[, pcaDataList$dimensionOne])
    minY <- min(pcaDataList$pcaObj$loadings[, pcaDataList$dimensionTwo])
    maxY <- max(pcaDataList$pcaObj$loadings[, pcaDataList$dimensionTwo])
    
    pcaLoadingsPlotRange$xMin <<- minX
    pcaLoadingsPlotRange$xMax <<- maxX
    pcaLoadingsPlotRange$xInterval <<- c(minX, maxX)
    pcaLoadingsPlotRange$xIntervalSize <<- maxX - minX
    pcaLoadingsPlotRange$yMin <<- minY
    pcaLoadingsPlotRange$yMax <<- maxY
    pcaLoadingsPlotRange$yInterval <<- c(minY, maxY)
    pcaLoadingsPlotRange$yIntervalSize <<- maxY - minY
  }
})
obsPCAloadingsBrush <- observeEvent(input$plotPcaLoadings_brush, {
  if(is.null(classToSpectra_class))
    return()
  
  brush <- input$plotPcaLoadings_brush
  
  xInterval <- c(brush$xmin, brush$xmax)
  yInterval <- c(brush$ymin, brush$ymax)
  
  
  indeces <- which(
    pcaDataList$pcaLoadingsX >= brush$xmin & pcaDataList$pcaLoadingsX <= brush$xmax &
      pcaDataList$pcaLoadingsY >= brush$ymin & pcaDataList$pcaLoadingsY <= brush$ymax
  )
  precursorSet <- filterPca$filter[indeces]
  print(paste("observe PCAloadings brush", length(precursorSet)))
  if(length(precursorSet) == 0)
    return()
  
  ## putative metabolite families statistics
  #putativeMetaboliteFamilies <- evaluatePutativeMetaboliteFamiliesOfPrecursorSet(dataList = dataList, precursorSet = precursorSet, classToSpectra_class = classToSpectra_class)
  
  output$information <- renderText({
    print(paste("update output$information", resultObj$infoText))
    paste(
      resultObj$infoText, 
      #paste("\n", paste(putativeMetaboliteFamilies, collapse = "\n"), sep = ""),
      sep = "")
  })
})

observeGroupSet <- observeEvent(input$pcaGroups, {
  print(paste("observe groups change", paste(input$pcaGroups, collapse = "-"), length(input$pcaGroups), length(input$pcaGroups) == 2))
  shinyjs::toggleState("pcaFilter_lfc", length(input$pcaGroups) == 2)
  
  if(FALSE){
    ## update samples
    sampleNames <- dataList$dataColumnsNameFunctionFromGroupNames(grouXXXps = input$pcaGroups, sampleNamesToExclude = dataList$excludedSamples(dataList$groupSampleDataFrame))
    updateCheckboxGroupInput(session = session, inputId = "pcaSamples",                         selected = sampleNames)
  }
})
observeSampleSet <- observeEvent(input$pcaSamples, {
  print(paste("observe samples change", paste(input$pcaSamples, collapse = "-"), length(input$pcaSamples)))
  
  groupsFromSamples <- unlist(lapply(X = dataList$grouXXXps, FUN = function(x){
    samplesOfGroups <- dataList$dataColumnsNameFunctionFromGroupName(group = x, sampleNamesToExclude = dataList$excludedSamples(dataList$groupSampleDataFrame))
    if(any(samplesOfGroups %in% input$pcaSamples))
      return(x)
    else
      return(NULL)
  }))
  
  shinyjs::toggleState(id = "pcaFilter_lfc", condition = length(groupsFromSamples) == 2)
  
  #########################################################################################
  ## update filter
  
  #if(!is.null(filterHca)){
  ##  applyHcaFilters(
  ##    filterHca$groupSetOriginal[[1]], 
  ##    filterHca$groupSetOriginal[[2]], 
  ##    filterHca$filter_averageOriginal, 
  ##    filterHca$filter_lfcOriginal, 
  ##    filterHca$includeIgnoredPrecursorsOriginal
  ##  )
  #  applyPcaFilters_default()
  ##}
  
  if(!is.null(filterPca))
    applyPcaFilters_default()
})

observeSelectAllPCAGroups <- observeEvent(input$selectAllPCAGroups, {
  print(paste("observe selectAllPCAGroups"))
  updateCheckboxGroupInput(session = session, inputId = "pcaGroups",   choices = dataList$grouXXXps, selected = dataList$grouXXXps)
})
observeSelectNoPCAGroups <- observeEvent(input$selectNoPCAGroups, {
  print(paste("observe selectNoPCAGroups"))
  updateCheckboxGroupInput(session = session, inputId = "pcaGroups",   choices = dataList$grouXXXps, selected = NULL)
})
observeSelectInvertedPCAGroups <- observeEvent(input$selectInvertedPCAGroups, {
  print(paste("observe selectInvertedPCAGroups"))
  updateCheckboxGroupInput(session = session, inputId = "pcaGroups",   choices = dataList$grouXXXps, selected = setdiff(dataList$grouXXXps, input$pcaGroups))
})

output$plotPcaScores_hover_info <- renderUI({
  hover <- input$plotPcaScores_hover
  hoverX <- hover$x
  hoverY <- hover$y
  plotWidth  <- session$clientData$output_plotPcaScores_width
  plotHeight <- session$clientData$output_plotPcaScores_height
  
  if(is.null(hoverX) | is.null(hoverY))
    return(NULL)
  #print(paste("UI PCA scores hover", hoverX, hoverY))
  
  output$tip <- renderText({
    print(paste("update output$tip"))
    paste("Hover a scores node to view information about the sample.", "Brush and double-click to zoom in.", "Double-click to zoom out.", sep = "\n")
  })
  
  #################################################
  ## decide whether the hover is close enough to trigger event
  minimumIndex <- getSelectedPOI_XY(
    mouseX = hoverX, mouseY = hoverY, poiCoordinatesX = pcaDataList$pcaScoresX, poiCoordinatesY = pcaDataList$pcaScoresY,
    plotWidth = plotWidth, plotHeight = plotHeight, plotRangeX = pcaScoresPlotRange$xIntervalSize, plotRangeY = pcaScoresPlotRange$yIntervalSize
  )
  print(paste("UI PCA scores hover", hoverX, hoverY, minimumIndex))
  
  if(is.null(minimumIndex))
    return(NULL)
  
  ## compile information
  dataColumnName <- filterPca$sampleSet[[minimumIndex]]
  #dataColumnName <- dataList$dataColumnsNameFunctionFromGroupNames(grouXXXps = filterPca$grouXXXps, sampleNamesToExclude = dataList$excludedSamples(dataList$groupSampleDataFrame))[[minimumIndex]]
  group <- dataList$groupNameFunctionFromDataColumnName(dataColumnName = dataColumnName, sampleNamesToExclude = dataList$excludedSamples(dataList$groupSampleDataFrame))
  info <- paste(
    "<b>Sample: ", "</b>", dataColumnName, "<br>",
    "<b>Group: ", "</b>", group,
    sep = ""
  )
  #output$information <- renderText({
  #  print(paste("update output$information PCA scores hover", sep = ""))
  #  paste("Sample '", dataColumnName , "' is a replicate of group '", group, "'.", sep = "")
  #})
  
  panelWidth <- as.integer(plotWidth*0.6)
  showPlotTooltip(hover, info, panelWidth)
})
output$plotPcaLoadings_hover_info <- renderUI({
  hover <- input$plotPcaLoadings_hover
  hoverX <- hover$x
  hoverY <- hover$y
  plotWidth  <- session$clientData$output_plotPcaLoadings_width
  plotHeight <- session$clientData$output_plotPcaLoadings_height
  
  if(is.null(hoverX) | is.null(hoverY))
    return(NULL)
  #print(paste("UI PCA loadings hover", hoverX, hoverY))
  
  output$tip <- renderText({
    print(paste("update output$tip"))
    paste(
      "Hover or click a loadings node to view information about the corresponding MS\u00B9 feature.", 
      "Brush and double-click to zoom in.", 
      "Double-click to zoom out.", 
      sep = "\n"
    )
  })
  
  #################################################
  ## decide whether the hover is close enough to trigger event
  minimumIndex <- getSelectedPOI_XY(
    mouseX = hoverX, mouseY = hoverY, poiCoordinatesX = pcaDataList$pcaLoadingsX, poiCoordinatesY = pcaDataList$pcaLoadingsY,
    plotWidth = plotWidth, plotHeight = plotHeight, plotRangeX = pcaLoadingsPlotRange$xIntervalSize, plotRangeY = pcaLoadingsPlotRange$yIntervalSize
  )
  print(paste("UI PCA loadings hover", hoverX, hoverY, minimumIndex))
  
  if(is.null(minimumIndex)){
    ms2PlotValues$fragmentListHovered <<- NULL
    return(NULL)
  }
  
  ## compile information
  precursorIndex <- filterPca$filter[[minimumIndex]]
  resultObj <- getMS2spectrumInfoForPrecursor(dataList = dataList, precursorIndex = precursorIndex)
  if(all(!is.null(selectionAnalysisPcaLoadingSet), minimumIndex == selectionAnalysisPcaLoadingSet)){
    ## reverse MS2 to clicked stuff
    ms2PlotValues$fragmentListHovered <<- NULL
  } else {
    ms2PlotValues$fragmentListHovered <<- resultObj
  }
  
  info <- paste(
    "<b>MS\u00B9 feature: ", "</b>", resultObj$infoFeatureLabel, "<br>",
    "<b>Name: ", "</b>", resultObj$infoName, "<br>",
    "<b>Annotation: ", "</b>", resultObj$infoFamilies, "<br>",
    "<b>Fragments: ", "</b>", resultObj$infoFragmentCount,
    sep = ""
  )
  
  panelWidth <- as.integer(plotWidth*0.6)
  showPlotTooltip(hover, info, panelWidth)
})

output$ui_plotAnnoLegendPCA <- renderUI({
  print(paste("### GUI ### ui_plotAnnoLegendPCA"))
  if(state_tabPca$annotationLegendHeightPca != -1) {
    plotOutput(outputId = "plotAnnoLegendPCA", height = state_tabPca$annotationLegendHeightPca)
  }
})
output$ui_plotScoresGroupsLegend <- renderUI({
  print(paste("### GUI ### ui_plotScoresGroupsLegend"))
  if(state_tabPca$scoresGroupsLegendHeight != -1) {
    plotOutput(outputId = "plotScoresGroupsLegend", height = state_tabPca$scoresGroupsLegendHeight)
  }
})

suspendOnExitFunctions <- c(suspendOnExitFunctions, function(){
  print("Suspending tabPca observers")
  obsDrawPCA$suspend()
  obsPCAscoresDblClick$suspend()
  obsPCAloadingsClick$suspend()
  obsPCAloadingsDblClick$suspend()
  obsPCAloadingsBrush$suspend()
  observeGroupSet$suspend()
  observeSampleSet$suspend()
  observeSelectAllPCAGroups$suspend()
  observeSelectNoPCAGroups$suspend()
  observeSelectInvertedPCAGroups$suspend()
})

================
File: inst/MetFamily/app_files/server_guiTabSampleFilter.R
================
## for saving the table state while rearranging
sampleOrder_tmp <- NULL
sampleExclusion_tmp <- NULL

sampleTableInputFieldIdCounter <- 0
sampleTable <- NULL

resetWorkspaceFunctions <- c(resetWorkspaceFunctions, function(){
  print("Reset sampleFilter state")
  ## sample table
  sampleOrder_tmp     <<- dataList$groupSampleDataFrame[, "Order"]
  sampleExclusion_tmp <<- dataList$groupSampleDataFrame[, "Exclude"]
  
  sampleTable <<- createSampleTable()
  setSampleTable()
})

createSampleTable <- function(){
  sampleTableInputFieldIdCounter <<- sampleTableInputFieldIdCounter + 1
  
  groupSampleDataFrame <- dataList$groupSampleDataFrame[sampleOrder_tmp, c("Group", "Sample")]
  isExcluded <- sampleExclusion_tmp[sampleOrder_tmp]
  
  iconUp   <- icon(name = "chevron-up",   lib = "font-awesome")
  iconDown <- icon(name = "chevron-down", lib = "font-awesome")
  
  checkboxes   <- createCheckboxInputFields2(    FUN = checkboxInput, id = "Sample_Exclude", values = isExcluded, tableCounter = sampleTableInputFieldIdCounter, triggerSampleExclusionClick = TRUE)
  buttonUpDown <- createActionButtonInputFields2(FUN = actionButton,  id = "Sample_Move", itemCount = length(isExcluded), iconUp = iconUp, iconDown = iconDown, tableCounter = sampleTableInputFieldIdCounter)
  dataFrameExcludeMove <- data.frame(check.names = F,
                                     "Exclude" = checkboxes,
                                     #"Move \u2191\u2193" = buttonUpDown
                                     "Change order" = buttonUpDown
  )
  
  ## assemble
  dataFrame <<- cbind(
    groupSampleDataFrame,
    dataFrameExcludeMove
  )
  
  return(dataFrame)
}
obsSampleValuesChanged <- observeEvent(input$updateSampleTable, {
  session$sendCustomMessage("disableButton", "updateSampleTable")
  updateSampleTable <- as.numeric(input$updateSampleTable)
  
  #################################################
  ## check if button was hit
  #if(updateSampleTable == updateSamplesButtonValue)
  #  return()
  #updateSamplesButtonValue <<- updateSampleTable
  
  updateSampleOrderAndExclusion()
  session$sendCustomMessage("enableButton", "updateSampleTable")
})
updateSampleOrderAndExclusion <- function(){
  ## check list validity
  if(length(unique(dataList$groupSampleDataFrame[!sampleExclusion_tmp, "Group"])) < length(unique(dataList$groupSampleDataFrame[, "Group"]))){
    showModal(modalDialog(
      title = "Invalid sample exclusion",
      #footer = tagList(
      #  actionButton(inputId = "ok", label = "OK")
      #),
      HTML(
        paste(
          "It is not supported to exclude all samples of one sample group.",
          "<br>",
          "Please retain at least one sample of each sample group."
        )
      )
    ))
    
    return()
  }
  
  ## update dataList
  dataList$groupSampleDataFrame[, "Order"]   <<- sampleOrder_tmp
  dataList$groupSampleDataFrame[, "Exclude"] <<- sampleExclusion_tmp
  
  sampleNamesToExclude <- dataList$groupSampleDataFrame[sampleExclusion_tmp, "Sample"]
  
  returnObj <- processMS1data(sampleNamesToExclude=sampleNamesToExclude, numberOfMS1features=dataList$numberOfPrecursors, precursorLabels=dataList$precursorLabels, 
                              grouXXXps=dataList$grouXXXps, metaboliteProfileColumnNames=dataList$metaboliteProfileColumnNames, tagsSector = dataList$tagsSector, 
                              dataColumnIndecesFunctionFromGroupIndex=dataList$dataColumnIndecesFunctionFromGroupIndex, dataColumnsNameFunctionFromGroupIndex=dataList$dataColumnsNameFunctionFromGroupIndex, dataColumnsNameFunctionFromGroupName=dataList$dataColumnsNameFunctionFromGroupName, dataColumnsNameFunctionFromGroupNames=dataList$dataColumnsNameFunctionFromGroupNames, groupNameFunctionFromDataColumnName=dataList$groupNameFunctionFromDataColumnName,
                              metaboliteProfile=dataList$dataFrameInfos, progress=FALSE)
  
  ## name functions
  dataList$dataMeanColumnNameFunctionFromIndex <<- returnObj$dataMeanColumnNameFunctionFromIndex
  dataList$dataMeanColumnNameFunctionFromName  <<- returnObj$dataMeanColumnNameFunctionFromName
  dataList$lfcColumnNameFunctionFromIndex      <<- returnObj$lfcColumnNameFunctionFromIndex
  dataList$lfcColumnNameFunctionFromName       <<- returnObj$lfcColumnNameFunctionFromName
  dataList$groupNameFromGroupIndex             <<- returnObj$groupNameFromGroupIndex
  dataList$groupIdxFromGroupName               <<- returnObj$groupIdxFromGroupName
  ## data and names
  dataList$dataFrameMeasurements               <<- returnObj$dataFrameMeasurements
  #dataMeanColumnNames                 <- returnObj$dataMeanColumnNames
  #lfcColumnNames                      <- returnObj$lfcColumnNames
  ## colors
  #matrixDataFrame                     <- returnObj$matrixDataFrame
  dataList$colorMatrixDataFrame                <<- returnObj$colorMatrixDataFrame
  dataList$colorMapAbsoluteData                <<- returnObj$colorMapAbsoluteData
  dataList$colorMapLogFoldChange               <<- returnObj$colorMapLogFoldChange
  dataList$columnGroupLabels                   <<- returnObj$columnGroupLabels
  ## constants
  dataList$meanAllMax       <<- returnObj$meanAllMax
  dataList$logFoldChangeMax <<- returnObj$logFoldChangeMax
  dataList$logAbsMax        <<- returnObj$logAbsMax
  
  ## update filter
  sampleNames <- dataList$groupSampleDataFrame[sampleOrder_tmp, "Sample"][!sampleExclusion_tmp[sampleOrder_tmp]]
  #selectedSampleNames <- intersect(input$pcaSamples, sampleNames)
  #updateCheckboxGroupInput(session = session, inputId = "pcaSamples",  choices = sampleNames,     selected = selectedSampleNames)
  updateCheckboxGroupInput(session = session, inputId = "pcaSamples",  choices = sampleNames,     selected = sampleNames)
}
sampleExcludeClicked <- function(){
  ## get exclusion
  sampleExclude <- getInputValues(id = paste("Sample_Exclude", sep = "_"), counter = sampleTableInputFieldIdCounter, len = nrow(sampleTable))
  sampleExclude <- sampleExclude[order(sampleOrder_tmp)]
  
  ## update exclusion
  sampleExclusion_tmp <<- sampleExclude
}
sampleMoveClicked <- function(buttonId){
  ## get source
  buttonUp <-            strsplit(x = buttonId, split = "_")[[1]][[3]] == "Up"
  rowId    <- as.numeric(strsplit(x = buttonId, split = "_")[[1]][[5]])
  
  ## ignore two cases
  if(rowId == 1 & buttonUp)
    return()
  if(rowId == nrow(dataList$groupSampleDataFrame) & !buttonUp)
    return()
  
  ## update sample order
  rowId2 <- ifelse(buttonUp, rowId - 1, rowId + 1)
  sampleOrder <- sampleOrder_tmp
  
  ## switch
  tmp <- sampleOrder[[rowId]]
  sampleOrder[[rowId]] <- sampleOrder[[rowId2]]
  sampleOrder[[rowId2]] <- tmp
  
  sampleOrder_tmp <<- sampleOrder
  
  ## update table
  sampleTable <<- createSampleTable()
  setSampleTable()
}
setSampleTable <- function(){
  output$sampleTable <- DT::renderDataTable(
    expr = sampleTable,
    server = FALSE, escape = FALSE, selection = "none", #rownames = FALSE,
    options = list(
      #scrollY = "600px",
      scrollY = "65vh",
      preDrawCallback = JS('function() { Shiny.unbindAll(this.api().table().node()); }'),
      drawCallback    = JS('function() { Shiny.bindAll(  this.api().table().node()); }'),
      iDisplayLength=nrow(sampleTable),       # initial number of records
      #aLengthMenu = c(5,10),    # records/page options
      #bLengthChange =0,        # show/hide records per page dropdown
      #bFilter = 0,              # global search box on/off
      #bInfo = 0,                # information on/off (how many records filtered, etc)
      #bAutoWidth = 0,           # automatic column width calculation, disable if passing column width via aoColumnDefs
      #aoColumnDefs = list(list(sWidth="300px", aTargets=c(list(0),list(1))))    # custom column size
      ordering = F,              # row ordering
      sDom  = 't'
      #sDom  = '<"top">rt<"bottom">ip'
    )
  )
}

suspendOnExitFunctions <- c(suspendOnExitFunctions, function(){
  print("Suspending tabSampleFilter observers")
  obsSampleValuesChanged$suspend()
})

================
File: inst/MetFamily/app_files/server_guiTabSearch.R
================
resetWorkspaceFunctions <- c(resetWorkspaceFunctions, function(){
  print("Reset tabSearch state")
  ## input fields: MS1 search
  updateTextInput(session = session, inputId = "searchMS1mass", value = "")
  updateTextInput(session = session, inputId = "searchMS1massPpm", value = 20)
  ## input fields: MS2 search
  updateTextInput(session = session, inputId = "search_ms2_masses1", value = "")
  updateTextInput(session = session, inputId = "search_ms2_masses2", value = "")
  updateTextInput(session = session, inputId = "search_ms2_masses3", value = "")
  updateTextInput(session = session, inputId = "searchMS2massPpm", value = 20)
  updateCheckboxInput(session = session, inputId = "searchIncludeIgnoredPrecursors", value = FALSE)
})

obsClearSearch <- observeEvent(input$clearSearch, {
  session$sendCustomMessage("disableButton", "clearSearch")
  clearSearch <- as.numeric(input$clearSearch)
  
  print(paste("Observe clearSearch", clearSearch))
  
  #################################################
  ## check if button was hit
  #if(clearSearch == clearSearchButtonValue)
  #  return()
  #clearSearchButtonValue <<- clearSearch
  
  filterSearch <<- NULL
  state_filters$filterSearchActive <<- FALSE
  state_filters$searchFilterValid <<- TRUE
  
  selectionBySearchReset()
  updateSearchInformation()
  
  #################################################
  ## update plots
  if(state$showHCAplotPanel)  drawDendrogramPlot( consoleInfo = "clear search", withHeatmap = TRUE)
  if(state$showPCAplotPanel)  drawPcaPlots(       consoleInfo = "clear search")
  session$sendCustomMessage("enableButton", "clearSearch")
})
obsApplySearch <- observeEvent(input$applySearch, {
  session$sendCustomMessage("disableButton", "applySearch")
  applySearch <- as.numeric(input$applySearch)
  
  print(paste("Observe applySearch", applySearch))
  
  #################################################
  ## check if button was hit
  #if(applySearch == applySearchButtonValue)
  #  return()
  #applySearchButtonValue <<- applySearch
  
  #################################################
  ## MS1 or MS2?
  includeIgnoredPrecursors  <- input$searchIncludeIgnoredPrecursors
  
  searchMode <- input$searchMS1orMS2
  switch (searchMode,
          'MS1 feature m/z' = {
            filter_ms1_masses <- input$searchMS1mass
            filter_ms1_ppm    <- input$searchMS1massPpm
            
            if(nchar(trimws(filter_ms1_masses)) == 0)
              return()
            
            resultObj <- doApplySearch(filter_ms1_masses = filter_ms1_masses, filter_ms1_ppm = filter_ms1_ppm, includeIgnoredPrecursors = includeIgnoredPrecursors)
          },
          'Fragment m/z' = {
            filter_ms2_masses1 <- input$search_ms2_masses1
            filter_ms2_masses2 <- input$search_ms2_masses2
            filter_ms2_masses3 <- input$search_ms2_masses3
            filter_ms2_ppm     <- input$searchMS2massPpm
            
            resultObj <- doApplySearch(filter_ms2_masses1 = filter_ms2_masses1, filter_ms2_masses2 = filter_ms2_masses2, filter_ms2_masses3 = filter_ms2_masses3, filter_ms2_ppm = filter_ms2_ppm, includeIgnoredPrecursors = includeIgnoredPrecursors)
          }
  )
  
  processSearchFilterResult(resultObj)
  
  session$sendCustomMessage("enableButton", "applySearch")
})
doApplySearch <- function(filter_ms2_masses1 = NULL, filter_ms2_masses2 = NULL, filter_ms2_masses3 = NULL, filter_ms2_ppm = NULL, filter_ms1_masses = NULL, filter_ms1_ppm = NULL, includeIgnoredPrecursors){
  filter_lfc      <- NULL
  filter_average  <- NULL
  groupSet        <- dataList$grouXXXps
  
  #################################################
  ## do filtering
  sampleSet <- dataList$groupSampleDataFrame[, "Sample"][!dataList$groupSampleDataFrame[, "Exclude"]]
  filterBySamples <- TRUE
  
  print(paste("Observe applySearch", "1m", filter_ms1_masses, "1p", filter_ms1_ppm, "i", includeIgnoredPrecursors, "gs", paste(groupSet, collapse = "-")))
  resultObj <- doPerformFiltering(groupSet, sampleSet, filterBySamples, filter_average, filter_lfc, filter_ms2_masses1, filter_ms2_masses2, filter_ms2_masses3, filter_ms2_ppm, filter_ms1_masses, filter_ms1_ppm, includeIgnoredPrecursors)
  return(resultObj)
}
processSearchFilterResult <- function(resultObj){
  state_filters$filterSearchActive <<- TRUE
  #################################################
  ## info / error
  if(resultObj$error){
    filterSearch <<- NULL
    state_filters$searchFilterValid <<- FALSE
    selectionBySearch(NULL)
    updateSearchInformation()
  } else {
    filterSearch <<- resultObj$filter
    state_filters$searchFilterValid <<- TRUE
    selectionBySearch(filterSearch$filter)
    updateSearchInformation()
    
    #################################################
    ## update plots
    if(state$showHCAplotPanel)  drawDendrogramPlot( consoleInfo = "update search", withHeatmap = TRUE)
    if(state$showPCAplotPanel)  drawPcaPlots(       consoleInfo = "update search")
  }
}
updateSearchInformation <- function(){
  if(!state_filters$filterSearchActive)
    output$searchInfo <- renderText({
      print(paste("update output$searchInfo inactive search", sep = ""))
      paste("Please search for MS\u00B9 features", sep = "")
    })
  if(state_filters$filterSearchActive & is.null(filterSearch))
    output$searchInfo <- renderText({
      print(paste("update output$searchInfo invalid search", sep = ""))
      paste("There are invalid or missing search values", sep = "")
    })
  if(state_filters$filterSearchActive & !is.null(filterSearch)){
    str1 <- ""
    str2 <- ""
    if(state$showHCAplotPanel & !is.null(listForTable_Search_HCA))
      str1 <- paste(length(listForTable_Search_HCA$precursorSet), " in HCA", sep = "")
    if(state$showPCAplotPanel & !is.null(listForTable_Search_PCA))
      str2 <- paste(length(listForTable_Search_PCA$precursorSet), " in PCA", sep = "")
    
    if(nchar(str1) > 0 & nchar(str2) > 0)
      val <- paste(str1, str2, sep = ", ")
    if(nchar(str1) > 0 & !(nchar(str2) > 0))
      val <- str1
    if(!(nchar(str1) > 0) & nchar(str2) > 0)
      val <- str2
    if(!(nchar(str1) > 0) & !(nchar(str2) > 0))
      val <- "None"
    
    output$searchInfo <- renderText({
      print(paste("update output$searchInfo", sep = ""))
      paste("Number of hits among MS\u00B9 features: ", val, sep = "")
    })
  }
}

suspendOnExitFunctions <- c(suspendOnExitFunctions, function(){
  print("Suspending tabSearch observers")
  obsClearSearch$suspend()
  obsApplySearch$suspend()
})

================
File: inst/MetFamily/app_files/ui_rightColumn.R
================
#output$runRightColumn <- renderUI({
  #print(paste("### GUI ### Generate right GUI"))
  #column(width = state$runRightColumnWidth,
  column(width = 8,
         #########################################################################################
         ## show side bar and change plot
         conditionalPanel(
           condition = "(output.showHCAplotPanel & output.analysisType == 'HCA') | (output.showPCAplotPanel & output.analysisType == 'PCA') | (output.showAnnotationplotPanel & output.analysisType == 'Annotation')",
           #condition = "output.showHCAplotPanel | output.showPCAplotPanel",
           fluidRow(
           #  column(width = 6,
           #         div(style="float:right",
           #             bsTooltip(id = "showSideBar", title = "Display or hide the side bar", placement = "bottom", trigger = "hover"),
           #             checkboxInput(inputId = "showSideBar", label = "Display side bar", value = showSideBar)
           #         )
           #  ),##column
           #  column(width = 6,
                    conditionalPanel(
                      condition = "(output.showHCAplotPanel & output.showPCAplotPanel) | (output.showHCAplotPanel & output.showAnnotationplotPanel) | (output.showAnnotationplotPanel & output.showPCAplotPanel)",
                      div(style="float:left",
                          bsTooltip(id = "changePlot", title = "Switch between HCA plots and PCA plots", placement = "bottom", trigger = "hover"),
                          #c("Display HCA", "Display PCA", "Display Annotation")
                          #radioButtons(inputId = "changePlot", label = NULL, choices = plotsToShow, inline = TRUE, selected = plotToShow)
                          radioButtons(inputId = "changePlot", label = NULL, choices = "Display HCA", inline = TRUE, selected = "Display HCA")
                      )
                    )##conditional
           #  )##column
           )##row
         ),##conditional
         ##############################################################################################
         ##############################################################################################
         ## plots
         
         ##############################################################################################
         ## plots controls
         conditionalPanel(## plot properties
           condition = '(output.analysisType == "HCA" & output.showHCAplotPanel) | (output.analysisType == "PCA" & output.showPCAplotPanel)',
           wellPanel(
             fluidRow(
               column(width = 6,
                      div(style="float:left",
                          h4("Plot controls")
                      )
               ),##column
               column(width = 6,
                      div(style="float:right",
                          bsTooltip(id = "showPlotControls", title = "Display control panels for the plots below", placement = "bottom", trigger = "hover"),
                          #checkboxInput(inputId = "showPlotControls", label = "Show plot controls", value = input$showPlotControls)
                          checkboxInput(inputId = "showPlotControls", label = "Show plot controls", value = FALSE)
                      )
               )##column
             ),##row
             fluidRow(
               ################################################
               ## HCA plot controls
               conditionalPanel(## dendrogram properties
                 condition = 'output.analysisType == "HCA" & output.showHCAplotPanel & input.showPlotControls',
                 column(width = 3,
                        h5("Heatmap content"),
                        tags$div(
                          title="Please select the abundance information you would like to display in the heatmap below the dendrogram",
                          #radioButtons(inputId = "heatmapContent", label = NULL, choices = c("Log-fold-change", "Abundance by group", "Abundance by sample"), selected = input$heatmapContent)
                          radioButtons(inputId = "heatmapContent", label = NULL, choices = c("Log-fold-change", "Abundance by group", "Abundance by sample"), selected = "Log-fold-change")
                        )
                 ),
                 column(width = 3,
                        h5("Heatmap ordering"),
                        tags$div(
                          title="Please select the mode of ordering the heatmap rows below the dendrogram",
                          #radioButtons(inputId = "heatmapOrdering", label = NULL, choices = c("Specified order", "MS1 clustering"), selected = input$heatmapOrdering)
                          radioButtons(inputId = "heatmapOrdering", label = NULL, choices = c("Specified order", "MS1 clustering"), selected = "Specified order")
                        )
                 ),
                 column(width = 3,
                        h5("HCA dendrogram"),
                        bsTooltip(id = "showClusterLabels", title = "Display the labels of cluster nodes and MS\u00B9 feature nodes representing the number of characteristic fragments", placement = "bottom", trigger = "hover"),
                        #checkboxInput(inputId = "showClusterLabels", label = "Show node labels", value = input$showClusterLabels)
                        checkboxInput(inputId = "showClusterLabels", label = "Show node labels", value = TRUE)
                 ),
                 column(width = 3,
                        h5("Precursor label"),
                        tags$div(
                          title="Please select the information you would like to display in the labels below the precursors",
                          #radioButtons(inputId = "hcaPrecursorLabels", label = NULL, choices = c("m/z / RT", "Metabolite name", "Metabolite family"), selected = input$hcaPrecursorLabels)
                          radioButtons(inputId = "hcaPrecursorLabels", label = NULL, choices = c("m/z / RT", "Metabolite name", "Metabolite family"), selected = "m/z / RT")
                        )
                 )
               ),## conditional
               ################################################
               ## PCA plot controls
               conditionalPanel(## scores / loadings properties
                 condition = 'output.analysisType == "PCA" & output.showPCAplotPanel & input.showPlotControls',
                 column(width = 3,
                        h5("PCA scores"),
                        bsTooltip(id = "showScoresLabels", title = "Display scores labels", placement = "bottom", trigger = "hover"),
                        #checkboxInput(inputId = "showScoresLabels", label = "Show labels", value = input$showScoresLabels)
                        checkboxInput(inputId = "showScoresLabels", label = "Show labels", value = TRUE)
                 ),
                 column(width = 3,
                        h5("PCA loadings labels"),
                        tags$div(
                          title="Please select the information you would like to display in the precursor labels of the loadings",
                          #radioButtons(inputId = "loadingsLabels", label = NULL, choices = c("None", "m/z / RT", "Metabolite name", "Metabolite family"), selected = input$loadingsLabels)
                          radioButtons(inputId = "loadingsLabels", label = NULL, choices = c("None", "m/z / RT", "Metabolite name", "Metabolite family"), selected = "None")
                        )
                 ),
                 column(width = 3,
                        h5("PCA loadings shown"),
                        tags$div(
                          title="Please select the MS\u00B9 features you would like to display in the loadings plot",
                          bsTooltip(id = "showLoadingsAbundance", title = "Use abundance in MS\u00B9 to scale the size of loadings nodes", placement = "bottom", trigger = "hover"),
                          checkboxGroupInput(inputId = "showLoadingsFeatures", label = NULL, 
                                             choices = c("Annotated", "Not Annotated", "Selected", "Not Selected"), 
                                             selected = c("Annotated", "Not Annotated", "Selected", "Not Selected")
                                             #selected = c(
                                             #  ifelse(test = state_tabPca$showLoadingsFeaturesAnnotated,   yes = "Annotated", no = ""),
                                             #  ifelse(test = state_tabPca$showLoadingsFeaturesUnannotated, yes = "Not Annotated", no = ""),
                                             #  ifelse(test = state_tabPca$showLoadingsFeaturesSelected,    yes = "Selected", no = ""),
                                             #  ifelse(test = state_tabPca$showLoadingsFeaturesUnselected,  yes = "Not Selected", no = "")
                                             #)
                          )
                          #checkboxInput(inputId = "showLoadingsFeaturesAnnotated",   label = "Annotated",     value = input$showLoadingsFeaturesAnnotated),
                          #checkboxInput(inputId = "showLoadingsFeaturesUnannotated", label = "Not Annotated", value = input$showLoadingsFeaturesUnannotated),
                          #checkboxInput(inputId = "showLoadingsFeaturesSelected",    label = "Selected",      value = input$showLoadingsFeaturesSelected),
                          #checkboxInput(inputId = "showLoadingsFeaturesUnselected",  label = "Not Selected",  value = input$showLoadingsFeaturesUnselected)
                        )
                 ),
                 column(width = 3,
                        h5("PCA loadings size"),
                        bsTooltip(id = "showLoadingsAbundance", title = "Use abundance in MS\u00B9 to scale the size of loadings nodes", placement = "bottom", trigger = "hover"),
                        #checkboxInput(inputId = "showLoadingsAbundance", label = "Scale by abundance", value = input$showLoadingsAbundance)
                        checkboxInput(inputId = "showLoadingsAbundance", label = "Scale by abundance", value = FALSE)
                 )
               )## conditional
             )## row
           )## well
         ),## conditional
         ##############################################################################################
         ## plots
         fluidRow(
           #column(width = 12-state$legendColumnWidth,
           column(width = 12-2,
                  ##############################################################################################
                  ## HCA plots
                  conditionalPanel(
                    condition = 'output.analysisType == "HCA" & output.showHCAplotPanel',
                    fluidRow(
                      #plotlyOutput(
                      #   height = state$dendrogramHeatmapHeight, 
                      #   #height = 500, 
                      #   outputId = "plotDendrogram"
                      # )
                      div(style = "position:relative",
                      plotOutput(height = 500, 
                                 outputId = "plotDendrogram", 
                                 #hover    = "plotDendrogram_hover", 
                                 hover    = hoverOpts(
                                   id = "plotDendrogram_hover",
                                   delay = 50, 
                                   delayType = "debounce",
                                   clip = FALSE,
                                   nullOutside = FALSE
                                 ),
                                 click    = "plotDendrogram_click",
                                 dblclick = "plotDendrogram_dblclick",
                                 #brush    = "plotDendrogram_brush"
                                 brush    = brushOpts(
                                   id = "plotDendrogram_brush",
                                   resetOnNew = TRUE,
                                   direction = "x",
                                   delay = 00,
                                   delayType = "debounce"
                                 )
                      ),
                      uiOutput("plotDendrogram_hover_info")
                      )
                    ),## row
                    fluidRow(
                      div(style = "position:relative",
                        uiOutput("ui_plotHeatmap"),
                        uiOutput("plotHeatmap_hover_info")
                      )
                    )## row
                  ),## conditional
                  ##############################################################################################
                  ## PCA plots
                  conditionalPanel(
                    condition = 'output.analysisType == "PCA" & output.showPCAplotPanel',
                    fluidRow(
                      column(width = 6,
                             div(style = "position:relative",
                               plotOutput(height = 500, 
                                          outputId = "plotPcaScores", 
                                          #hover    = "plotPcaScores_hover",
                                          hover    = hoverOpts(
                                            id = "plotPcaScores_hover",
                                            delay = 50, 
                                            delayType = "debounce"
                                          ),
                                          click    = "plotPcaScores_click",
                                          dblclick = "plotPcaScores_dblclick",
                                          #brush    = "plotPcaScores_brush"
                                          brush = brushOpts(
                                            id = "plotPcaScores_brush",
                                            resetOnNew = TRUE,
                                            direction = "xy",
                                            delay = 00,
                                            delayType = "debounce"
                                          )
                               ),
                               uiOutput("plotPcaScores_hover_info")
                             )
                      ),## column
                      column(width = 6,
                             div(style = "position:relative",
                               plotOutput(height = 500, 
                                          outputId = "plotPcaLoadings", 
                                          #hover    = "plotPcaLoadings_hover",
                                          hover    = hoverOpts(
                                            id = "plotPcaLoadings_hover",
                                            delay = 50, 
                                            delayType = "debounce"
                                          ),
                                          click    = "plotPcaLoadings_click",
                                          dblclick = "plotPcaLoadings_dblclick",
                                          #brush    = "plotPcaScores_brush"
                                          brush = brushOpts(
                                            id = "plotPcaLoadings_brush",
                                            resetOnNew = TRUE,
                                            direction = "xy",
                                            delay = 00,
                                            delayType = "debounce"
                                          )
                               ),
                               uiOutput("plotPcaLoadings_hover_info")
                             )
                      )## column
                    )## row
                  )## conditional
           ),##column for plot controls and plots
           #column(width = state$legendColumnWidth,
           column(width = 2,
                  conditionalPanel(
                    condition = 'output.analysisType == "HCA" & output.showHCAplotPanel',
                    splitLayout(
                      style = "border: 1px solid silver;",
                      uiOutput("ui_plotAnnoLegendHCA")
                    )
                  ),## conditional
                  conditionalPanel(
                    condition = 'output.analysisType == "PCA" & output.showPCAplotPanel',
                    splitLayout(
                      style = "border: 1px solid silver;",
                      uiOutput("ui_plotAnnoLegendPCA")
                    )
                  ),## conditional
                  conditionalPanel(
                    condition = '(output.analysisType == "HCA" & output.showHCAplotPanel) | (output.analysisType == "PCA" & output.showPCAplotPanel)',
                    splitLayout(
                      style = "border: 1px solid silver;",
                      plotOutput(outputId = "calcPlotDendrogramLegend", height = 80)
                    )
                  ),## conditional
                  conditionalPanel(
                    condition = 'output.analysisType == "HCA" & output.showHCAplotPanel',
                    splitLayout(
                      style = "border: 1px solid silver;",
                      plotOutput(outputId = "plotHeatmapLegend", height = 150)
                    )
                  ),## conditional
                  conditionalPanel(## loadings properties
                    condition = 'output.analysisType == "PCA" & output.showPCAplotPanel',
                    splitLayout(
                      style = "border: 1px solid silver;",
                      uiOutput("ui_plotScoresGroupsLegend")
                    )
                  ),
                  conditionalPanel(
                    condition = '(output.analysisType == "HCA" & output.showHCAplotPanel) | (output.analysisType == "PCA" & output.showPCAplotPanel)',
                    splitLayout(
                      style = "border: 1px solid silver;",
                      plotOutput(outputId = "plotMS2Legend", height = 80)
                    )
                  ),## conditional
                  conditionalPanel(
                    condition = '(output.analysisType == "HCA" & output.showHCAplotPanel)',
                    splitLayout(
                      style = "border: 1px solid silver;",
                      plotOutput(outputId = "plotFragmentDiscriminativityLegend", height = 100)
                    )
                  )## conditional
           )## column
         ),## row
         #########################################################################################
         ## MS2 plot and info
         conditionalPanel(
           condition = '(output.showHCAplotPanel & output.analysisType == "HCA") | (output.showPCAplotPanel & output.analysisType == "PCA")',
           fluidRow(
             div(style = "position:relative",
             plotOutput(height = 250, 
                        outputId = "plotMS2",
                        #hover    = "plotMS2_hover",
                        hover    = hoverOpts(
                          id = "plotMS2_hover",
                          delay = 50, 
                          delayType = "debounce"
                        ),
                        click    = "plotMS2_click",
                        dblclick = "plotMS2_dblclick",
                        #brush    = "plotMS2_brush",
                        brush = brushOpts(
                          id = "plotMS2_brush",
                          resetOnNew = TRUE,
                          direction = "x",
                          delay = 00,
                          delayType = "debounce"
                        )
             ),
             uiOutput("plotMS2_hover_info")
             ),
             ##############################################################################################
             ## classifier results on dendrogram node
             conditionalPanel(
               condition = 'output.showPutativeAnnotationsTableFromAnalysis',
               DT::dataTableOutput("putativeAnnotationsTableFromAnalysis")
               #putativeAnnotationsTableFromAnalysisRowSelected
             ),
             ##############################################################################################
             ## infos
             wellPanel(
               #h4("Information"),
               #bsTooltip(id = "information", title = "Information about items in the plot", placement = "bottom", trigger = "hover"),
               #verbatimTextOutput("information"),
               h4("Tip"),
               bsTooltip(id = "tip", title = "Information about operating options", placement = "bottom", trigger = "hover"),
               verbatimTextOutput("tip")
             )## well
           )## row
         ),## conditional
         ##############################################################################################
         ## precursor set selection and annotation
         ## change selection
         conditionalPanel(
           condition = '(output.showHCAplotPanel & output.analysisType == "HCA") | (output.showPCAplotPanel & output.analysisType == "PCA")',
           fluidRow(
             wellPanel(
               h4("MS\u00B9 feature selections"),
               bsTooltip(id = "changeSelection", title = "Switch MS\u00B9 feature selection", placement = "bottom", trigger = "hover"),
               #radioButtons(inputId = "changeSelection", label = NULL, choices = c(selectionAnalysisName, selectionFragmentName, selectionSearchName), selected = changeSelectionCurrentSelection, inline = TRUE),
               radioButtons(inputId = "changeSelection", label = NULL, choices = c("Selection by HCA/PCA", "Selection by fragment", "Selection by search"), selected = "Selection by HCA/PCA", inline = TRUE),
               bsTooltip(id = "selectionInfo", title = "The number of MS\u00B9 features in the current selection", placement = "bottom", trigger = "hover"),
               hr(),
               verbatimTextOutput("selectionInfo"),
               conditionalPanel(
                 condition = 'output.precursorSetSelected',
                 tabsetPanel(id = "precursorSelectionTabs",
                             #tabPanel(title = precursorSelectionTabSelection, 
                             tabPanel(title = "Selection", 
                                      wellPanel(
                                        ## selection infos
                                        tags$div(
                                          style="margin-bottom:5px;",
                                          bsTooltip(id = "metFragLink", title = "Press to send the current MS\u00B9 feature as well as the corresponding MS/MS spectrum to MetFrag", placement = "bottom", trigger = "hover"),
                                          htmlOutput(outputId = "metFragLink")
                                        ),
                                        bsTooltip(id = "downloadSelectedPrecursors", title = "Download a project file which is reduced to the selected set of MS\u00B9 features", placement = "bottom", trigger = "hover"),
                                        downloadButton('downloadSelectedPrecursors', 'Download reduced project file'),
                                        bsTooltip(id = "clearSelection", title = "Press to clear this selection", placement = "bottom", trigger = "hover"),
                                        actionButton(inputId = "clearSelection", label = "Clear selection", class="btn-danger")
                                      )## well
                             ),## tab
                             #tabPanel(title = precursorSelectionTabAnnotation, 
                             tabPanel(title = "Annotation", 
                                      wellPanel(
                                        h4("Present annotation(s)"),
                                        fluidRow(
                                          column(
                                            width = 3,
                                            bsTooltip(id = "presentAnnotationValue", title = "The set of present annotations for the set of selected MS\u00B9 features", placement = "bottom", trigger = "hover"),
                                            selectInput(inputId = "presentAnnotationValue", label = NULL, choices = c("[init]"), selectize = FALSE)
                                          ),## column
                                          column(
                                            width = 3,
                                            bsTooltip(id = "setPresentAnnotationPrimary", title = "Sets the selected annotation primary for the set of selected MS\u00B9 features; i.e. this annotation will be used preferentially for coloring in HCA and PCA", placement = "bottom", trigger = "hover"),
                                            actionButton(inputId = "setPresentAnnotationPrimary", label = "Set primary", class="btn-success")
                                          ),## column
                                          column(
                                            width = 6,
                                            bsTooltip(id = "removePresentAnnotation", title = "Removes the selected annotation from the set of selected MS\u00B9 features", placement = "bottom", trigger = "hover"),
                                            actionButton(inputId = "removePresentAnnotation", label = "Remove annotation", class="btn-danger")
                                          )## column
                                        ),##row
                                        fluidRow(
                                          column(
                                            width = 6,
                                            h4("Add new annotation"),
                                            bsTooltip(id = "newAnnotationValue", title = "The name of this annotation", placement = "bottom", trigger = "hover"),
                                            textInput(inputId = "newAnnotationValue", placeholder = 'Metabolite family name here', label = "Type new annotation"),
                                            bsTooltip(id = "newAnnotationColor", title = "The color of this annotation", placement = "bottom", trigger = "hover"),
                                            colourpicker::colourInput(inputId = "newAnnotationColor", label = "Select annotation color", palette = "limited", showColour = "background", allowedCols = c(
                                              "blue",
                                              "red",
                                              "yellow",
                                              "green",
                                              "brown",
                                              "deepskyblue",
                                              "orange",
                                              "deeppink",
                                              "aquamarine",##
                                              "burlywood", 
                                              "cadetblue",
                                              "coral",
                                              "cornflowerblue",
                                              "cyan",##
                                              "firebrick",
                                              "goldenrod",
                                              "indianred",
                                              "khaki",##
                                              "magenta",
                                              "maroon",
                                              "beige",
                                              "moccasin",
                                              "olivedrab",
                                              "orangered",
                                              "orchid",
                                              "paleturquoise3",##
                                              "rosybrown",
                                              "salmon",
                                              "seagreen3",
                                              "skyblue",
                                              "steelblue",
                                              "#BF360C",
                                              "#33691E",
                                              "#311B92",
                                              "#880E4F",
                                              "#1A237E",
                                              "#006064",
                                              "#004D40",
                                              "#FF6F00",
                                              "#E65100"
                                            )),
                                            bsTooltip(id = "submitNewAnnotation", title = "Adds this annotation to the set of selected MS\u00B9 features", placement = "bottom", trigger = "hover"),
                                            actionButton(inputId = "submitNewAnnotation", label = "Add new annotation", class="btn-success")
                                          ),
                                          column(
                                            width = 6,
                                            h4("Add previous annotation"),
                                            bsTooltip(id = "previousAnnotationValue", title = "The set of annotations which have been assigned before", placement = "bottom", trigger = "hover"),
                                            selectInput(inputId = "previousAnnotationValue", label = "Select previous annotation", choices = c("Artifact"), selectize = FALSE),
                                            bsTooltip(id = "submitPreviousAnnotation", title = "Adds this annotation to the set of selected MS\u00B9 features", placement = "bottom", trigger = "hover"),
                                            actionButton(inputId = "submitPreviousAnnotation", label = "Add previous annotation", class="btn-success")
                                          )
                                        )
                                      )## well
                             ),## tab
                             #tabPanel(title = precursorSelectionTabTable, 
                             tabPanel(title = "Table", 
                                      wellPanel(
                                        h4("Selected MS\u00B9 features"),
                                        bsTooltip(id = "updateArtifactsFromCheckboxes", title = "Adds the annotation \\'ignore\\' to the set of checked MS\u00B9 features in the table", placement = "bottom", trigger = "hover"),
                                        actionButton(inputId = "updateArtifactsFromCheckboxes", label = "Apply annotation 'Ignore' to MS\u00B9 features", class="btn-danger"),
                                        DT::dataTableOutput("ms1FeatureTable")
                                      )## well
                             ),## tab
                             #tabPanel(title = precursorSelectionTabSpectrum, 
                             tabPanel(title = "Fragments", 
                                      wellPanel(
                                        bsTooltip(id = "selectedSpectrum", title = "The selected spectrum or frequent fragments / neutral losses", placement = "bottom", trigger = "hover"),
                                        tags$style(type="text/css", "textarea {width:100%}"),
                                        tags$textarea(id = 'selectedSpectrum', placeholder = 'Nothing selected', rows = 10, "")
                                      )## well
                             )## tab
                 )## tab set
               )## conditional
             )## well
           )## row
         ),##conditional
         ##############################################################################################
         ## classifier annotation
         conditionalPanel(
           condition = "(output.showAnnotationplotPanel & output.analysisType == 'Annotation')",
           fluidRow(
             wellPanel(
               h4("Metabolite family selection"),
               fluidRow(
                 column(width = 6, style="width:70%",
                        div(style="float:left;width:100%",
                            bsTooltip(id = "familyCount", title = "The number of metabolite families with one or more potential MS\u00B9 features", placement = "bottom", trigger = "hover"),
                            verbatimTextOutput(outputId = "familyCount"),
                            tags$style(type='text/css', "#familyCount { width:100%}")
                        )
                 ),##column
                 column(width = 6, style="width:30%",
                        div(style="float:right;width:100%",
                            bsTooltip(id = "downloadAllAnnotationResults", title = "Download the annotation results for all putative metabolite families", placement = "bottom", trigger = "hover"),
                            downloadButton('downloadAllAnnotationResults', 'Download annotation results'),
                            tags$style(type='text/css', "#downloadAllAnnotationResults { width:100%}")
                        )
                 )##column
               ),##row
               DT::dataTableOutput("annotationResultTableClass"),
               conditionalPanel(
                 condition = "output.classifierClassSelected",
                 h4("MS\u00B9 feature annotation"),
                 fluidRow(
                   column(width = 6, style="width:70%",
                          div(style="float:left;width:100%",
                              bsTooltip(id = "classToSpectraCount", title = "The number of potential MS\u00B9 feature hits", placement = "bottom", trigger = "hover"),
                              verbatimTextOutput(outputId = "classToSpectraCount"),
                              tags$style(type='text/css', "#classToSpectraCount { width:100%}")
                          )
                   ),##column
                   column(width = 6, style="width:30%",
                          div(style="float:right;width:100%",
                              bsTooltip(id = "downloadMetaboliteFamilyAnnotationResults", title = "Download the annotation results for all putative metabolite families", placement = "bottom", trigger = "hover"),
                              downloadButton('downloadMetaboliteFamilyAnnotationResults', 'Download annotation results'),
                              tags$style(type='text/css', "#downloadMetaboliteFamilyAnnotationResults { width:100%}")
                          )
                   )##column
                 ),##row
                 DT::dataTableOutput("annotationResultTableFeature"),
                 conditionalPanel(
                   condition = "output.classifierClassMS1featureSelected",
                   h4("MS\u00B9 feature spectrum versus Metabolite family"),
                   plotOutput(height = 250, 
                              outputId = "plotMS2vsClass",
                              #hover    = "plotMS2vsClass_hover",
                              #hover    = hoverOpts(
                              #  id = "plotMS2vsClass_hover",
                              #  delay = 50, 
                              #  delayType = "debounce"
                              #),
                              #click    = "plotMS2vsClass_click",
                              dblclick = "plotMS2vsClass_dblclick",
                              ##brush    = "plotMS2vsClass_brush",
                              brush = brushOpts(
                                id = "plotMS2vsClass_brush",
                                resetOnNew = TRUE,
                                direction = "x",
                                delay = 00,
                                delayType = "debounce"
                              )
                   ),
                   ## annotation stuff
                   bsTooltip(id = "newAnnotationValue2", title = "The name of this annotation", placement = "bottom", trigger = "hover"),
                   textInput(inputId = "newAnnotationValue2", placeholder = 'Metabolite family name', label = "Type new annotation"),
                   bsTooltip(id = "newAnnotationColor2", title = "The color of this annotation", placement = "bottom", trigger = "hover"),
                   colourpicker::colourInput(inputId = "newAnnotationColor2", label = "Select annotation color", palette = "limited", showColour = "background", allowedCols = c(
                     "blue",
                     "red",
                     "yellow",
                     "green",
                     "brown",
                     "deepskyblue",
                     "orange",
                     "deeppink",
                     "aquamarine",##
                     "burlywood", 
                     "cadetblue",
                     "coral",
                     "cornflowerblue",
                     "cyan",##
                     "firebrick",
                     "goldenrod",
                     "indianred",
                     "khaki",##
                     "magenta",
                     "maroon",
                     "beige",
                     "moccasin",
                     "olivedrab",
                     "orangered",
                     "orchid",
                     "paleturquoise3",##
                     "rosybrown",
                     "salmon",
                     "seagreen3",
                     "skyblue",
                     "steelblue",
                     "#BF360C",
                     "#33691E",
                     "#311B92",
                     "#880E4F",
                     "#1A237E",
                     "#006064",
                     "#004D40",
                     "#FF6F00",
                     "#E65100"
                   )),
                   bsTooltip(id = "confirmAnnotation", title = "Applies the metabolite family annotation to all confirmed MS\u00B9 features", placement = "bottom", trigger = "hover"),
                   actionButton(inputId = "confirmAnnotation", label = "Apply confirmed annotations", class="btn-success")
                 )## cond ms1
               )## cond class
             )## well
           )## row
         )##conditional
  )##column
#})

================
File: inst/MetFamily/tests/testthat/_snaps/linux-4.3/shinytest2/MetFamilyLoadExample-002.json
================
{
  "input": {
    "applyGlobalMS2filters": 0,
    "applyHcaFilters": 0,
    "applyPcaFilters": 0,
    "applySearch": 0,
    "changePlot": "Display HCA",
    "changeSelection": "Selection by HCA/PCA",
    "clearGlobalMS2filters": 0,
    "clearHcaFilters": 0,
    "clearPcaFilters": 0,
    "clearSearch": 0,
    "clearSelection": 0,
    "confirmAnnotation": 0,
    "displayImportParameters": false,
    "doAnnotation": 0,
    "doMs2PeakGroupDeisotoping": true,
    "doMs2PeakGroupDeisotoping2": true,
    "doPrecursorDeisotoping": true,
    "doPrecursorDeisotoping2": true,
    "downloadHcaImageType": "png",
    "downloadPcaImageType": "png",
    "drawHCAplots": 0,
    "drawPCAplots": 0,
    "fileInputSelection": "Example data",
    "filterByPCAgroupSamples": false,
    "globalFilter_ms2_masses1": "",
    "globalFilter_ms2_masses2": "",
    "globalFilter_ms2_masses3": "",
    "globalFilter_ms2_ppm": "",
    "hcaDistanceFunction": "Jaccard (intensity-weighted)",
    "hcaFilterGroupOne": "",
    "hcaFilterGroupTwo": "",
    "hcaFilterIncludeIgnoredPrecursors": false,
    "hcaFilter_average": "",
    "hcaFilter_lfc": "",
    "hcaPrecursorLabels": "m/z / RT",
    "heatmapContent": "Log-fold-change",
    "heatmapOrdering": "Specified order",
    "importMs1Ms2Data": 0,
    "importMs2Data": 0,
    "importParameterFileInput": null,
    "loadExampleData": 1,
    "loadProjectData": 0,
    "loadingsLabels": "None",
    "matrixFile": null,
    "maximumRtDifference": "0.05",
    "maximumRtDifference2": "0.02",
    "metaboliteFamilyComparisonClass": "[init]",
    "minimumIntensityOfMaximalMS2peak": "2000",
    "minimumIntensityOfMaximalMS2peak2": "2000",
    "minimumProportionOfMS2peaks": "0.05",
    "minimumProportionOfMS2peaks2": "0.05",
    "ms1AnalysisMethod": "PCA (Principal Component Analysis)",
    "ms1DataFile": null,
    "ms2DataFile": null,
    "mzDeviationAbsolute_grouping": "0.01",
    "mzDeviationAbsolute_grouping2": "0.01",
    "mzDeviationAbsolute_ms2PeakGroupDeisotoping": "0.01",
    "mzDeviationAbsolute_ms2PeakGroupDeisotoping2": "0.01",
    "mzDeviationAbsolute_precursorDeisotoping": "0.01",
    "mzDeviationAbsolute_precursorDeisotoping2": "0.01",
    "mzDeviationInPPM_grouping": "10",
    "mzDeviationInPPM_grouping2": "10",
    "mzDeviationInPPM_ms2PeakGroupDeisotoping": "10",
    "mzDeviationInPPM_ms2PeakGroupDeisotoping2": "10",
    "mzDeviationInPPM_precursorDeisotoping": "10",
    "mzDeviationInPPM_precursorDeisotoping2": "10",
    "neutralLossesFragmentsToFragments": false,
    "neutralLossesFragmentsToFragments2": false,
    "neutralLossesPrecursorToFragments": true,
    "neutralLossesPrecursorToFragments2": true,
    "newAnnotationColor": "#0000FF",
    "newAnnotationColor2": "#0000FF",
    "newAnnotationValue": "",
    "newAnnotationValue2": "",
    "pcaDimensionOne": "1",
    "pcaDimensionTwo": "2",
    "pcaFilterIncludeIgnoredPrecursors": false,
    "pcaFilter_average": "",
    "pcaFilter_lfc": "",
    "pcaGroups": null,
    "pcaLogTransform": false,
    "pcaSamples": null,
    "pcaScaling": "Pareto",
    "precursorSelectionTabs": "Selection",
    "prepareAllPrecursors": 0,
    "presentAnnotationValue": "[init]",
    "previousAnnotationValue": "Artifact",
    "projectDescription": "",
    "projectDescription2": "",
    "projectName": "MetFamily project (created 2022-02-22_12.34.56.789)",
    "projectName2": "",
    "removeMetaboliteFamily": 0,
    "removePresentAnnotation": 0,
    "renameMetaboliteFamily": 0,
    "runTabs": "Input",
    "searchIncludeIgnoredPrecursors": false,
    "searchMS1mass": "",
    "searchMS1massPpm": "",
    "searchMS1orMS2": "MS1 feature m/z",
    "searchMS2massPpm": "",
    "search_ms2_masses1": "",
    "search_ms2_masses2": "",
    "search_ms2_masses3": "",
    "selectAllPCAGroups": 0,
    "selectInvertedPCAGroups": 0,
    "selectMetaboliteFamily": 0,
    "selectNoPCAGroups": 0,
    "selectedSpectrum": "",
    "setPresentAnnotationPrimary": 0,
    "showClusterLabels": true,
    "showFragmentPlot": false,
    "showHCAadvancedOptions": false,
    "showHCAfilterOptions": true,
    "showImportParameters": false,
    "showImportParametersAdvanced": false,
    "showLoadingsAbundance": false,
    "showLoadingsFeatures": [
      "Annotated",
      "Not Annotated",
      "Selected",
      "Not Selected"
    ],
    "showPCAadvancedOptions": false,
    "showPCAfilterOptions": true,
    "showPlotControls": false,
    "showScoresLabels": true,
    "submitNewAnnotation": 0,
    "submitPreviousAnnotation": 0,
    "updateArtifactsFromCheckboxes": 0,
    "updateProjectDescription": 0,
    "updateSampleTable": 0
  },
  "output": {
    "analysisType": "HCA",
    "classifierClassMS1featureSelected": false,
    "classifierClassSelected": false,
    "classifierLoaded": false,
    "fileInfo": "Please press 'Load example data' to load the full example data set",
    "filterSearchActive": false,
    "globalMS2filterValid": true,
    "hcaFilterValid": true,
    "metaboliteFamilySelected": false,
    "pcaFilterValid": true,
    "plotAnnotationShown": false,
    "plotDendrogram_hover_info": null,
    "plotHcaShown": false,
    "plotHeatmap_hover_info": null,
    "plotMS2_hover_info": null,
    "plotPcaLoadings_hover_info": null,
    "plotPcaScores_hover_info": null,
    "plotPcaShown": false,
    "precursorSetSelected": false,
    "searchFilterValid": true,
    "selectedSelection": null,
    "selectionInfo": "Please select a cluster or MS¹ feature in the HCA plot",
    "showAnnotationplotPanel": false,
    "showGUI": true,
    "showHCAplotPanel": false,
    "showPCAplotPanel": false,
    "showPutativeAnnotationsTableFromAnalysis": null,
    "showSideBar": true,
    "ui_plotAnnoLegendHCA": null,
    "ui_plotAnnoLegendPCA": null,
    "ui_plotHeatmap": {
      "html": "<div class=\"shiny-plot-output html-fill-item\" data-hover-clip=\"TRUE\" data-hover-delay=\"50\" data-hover-delay-type=\"debounce\" data-hover-id=\"plotHeatmap_hover\" data-hover-null-outside=\"TRUE\" id=\"plotHeatmap\" style=\"width:100%;height:1px;\"><\/div>",
      "deps": [

      ]
    },
    "ui_plotScoresGroupsLegend": null
  },
  "export": {

  }
}

================
File: inst/MetFamily/tests/testthat/setup-shinytest2.R
================
# Load application support files into testing environment
shinytest2::load_app_env()

================
File: inst/MetFamily/tests/testthat/test-shinytest2.R
================
library(shinytest2)

test_that("{shinytest2} recording: MetFamilyLoadExample", {
  app <- AppDriver$new(variant = platform_variant(), name = "MetFamilyLoadExample",
      height = 1113, width = 1549)
  #app$expect_screenshot()
  app$set_inputs(fileInputSelection = "Example data")
  app$click("loadExampleData")
  app$expect_values(screenshot_args = FALSE)
})

================
File: inst/MetFamily/tests/testthat.R
================
shinytest2::test_app()

================
File: inst/MetFamily/www/css/ipb-styles.css
================
/* ----------------- Navigation und Footer unterhalb Content ----------------------- */
#second-wrap{
    background: #ededed;
    min-height: 40px;
    overflow: visible;
    margin: 15px 0 0 0;
}

#second-nav{
    margin-left: 52px;
    float: left;
}

#second-nav ul li{
    list-style-type: none;
    float: left;
    line-height: 40px;
    color: #191F39;
    font-size: 13px;
}

#second-nav ul li a{
    font-size: 13px;
    color: #191F39;
    text-decoration: none;
}

#second-nav ul li a:hover,
#second-nav ul li a:focus{
    color:#0C67AE;
}

#footer{
    float: right;
    margin-right: 52px;
}

#footer p{
    line-height: 40px;
    color: #191F39;
    font-size: 13px;
}

/* ----------------- Sitemap ------------------- */

#sitemap-header{
    background: #19213a;
    height: 100px;
    line-height: 100px;
    overflow: visible;
}
#sitemap-header #left-nav{
    margin-left:60px;
    float: left;
}
#sitemap-header #right-nav{
    float: right;
}
#sitemap-header #left-nav li, #sitemap-header #right-nav li{
    list-style-type: none;
    color: #fff;
    line-height: 80px;
    font-size: 60px;
    float: left;
}
#sitemap-header #left-nav li{
    padding-right: 20px;
}
#sitemap-header #right-nav li{
    padding-left: 20px;
}
#sitemap-header #left-nav li .border, #sitemap-header #right-nav li .border{
    display: block;
    width: 1px;
    height: 60px;
    border-right:1px #7c8497 solid;
    margin-top: 20px;
}
#sitemap-header #left-nav{
    margin-left:60px;
    float: left;
}

================
File: inst/MetFamily/www/img/denbi-logo-white.svg
================
<?xml version="1.0" encoding="utf-8"?>
<!-- Generator: Adobe Illustrator 13.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 14948)  -->
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" id="Ebene_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
	 width="354.332px" height="91.896px" viewBox="0 0 354.332 91.896" enable-background="new 0 0 354.332 91.896"
	 xml:space="preserve">
<path fill="#FFFFFF" d="M48.72,59.09V9.794c0-4.515-2.018-6.531-6.535-6.531H30.56v10.38h3.841c1.342,0,2.111,0.672,2.111,2.112
	v8.647c0,1.634,0.101,2.884,0.101,2.884h-0.194c0,0-3.461-5.959-14.124-5.959C9.32,21.327,0,31.419,0,46.986
	c0,15.183,8.553,25.656,21.815,25.659c11.243,0,15.279-7.978,15.279-7.978h0.193v1.824c0,2.884,1.631,4.998,6.053,4.998h11.239
	V61.205h-3.742C49.488,61.205,48.72,60.439,48.72,59.09z M24.506,62.359c-7.208,0-12.111-6.053-12.111-15.373
	c0-9.707,5.578-15.182,12.3-15.182c8.171,0,12.112,7.493,12.112,15.085C36.807,57.75,30.847,62.359,24.506,62.359z M242.895,9.794
	v31.23c0,3.938,0.674,9.608,0.674,9.608h-0.191c0,0-2.979-5.67-5.672-9.608L211.854,3.26h-11.338v55.447
	c0,1.311-0.74,2.018-2.013,2.058v-0.008h-8.346c-2.601,4.104-5.873,7.729-9.668,10.732h26.073c4.613,0,6.531-1.924,6.531-6.535
	V33.821c0-3.941-0.668-9.61-0.668-9.61h0.188c0,0,2.979,5.769,5.672,9.61l25.942,37.67h11.244V16.042
	c0-1.343,0.769-2.111,2.114-2.111h4.132V3.26h-12.291C244.816,3.26,242.895,5.281,242.895,9.794z M310.547,35.643v-0.189
	c4.135-2.115,8.264-7.014,8.264-14.604c0-11.244-8.84-17.591-21.139-17.591h-29.504v10.669h6.246v51.026
	c0,4.611,2.016,6.534,6.533,6.534h17.012c12.686,0,23.545-6.152,23.545-19.798C321.504,44.773,317.949,37.854,310.547,35.643z
	 M287.006,13.93h10.574c5.572,0,8.453,3.557,8.453,8.455c0,4.901-2.983,8.743-8.268,8.743h-10.76V13.93z M298.922,60.823h-9.803
	c-1.348,0-2.118-0.769-2.117-2.115V41.125h11.92c6.05,0,9.607,4.131,9.607,9.801C308.529,56.689,305.068,60.823,298.922,60.823z
	 M353.656,60.823h-6.828V13.928h6.828V3.26h-26.569v10.669h7.827v46.895h-7.827V71.49h26.569V60.823z M83.083,71.63
	c0.803,0,1.58-0.01,2.349-0.021l41.931,0.007l-0.187-0.138c-3.789-3.002-7.058-6.625-9.654-10.724H81.291
	c-5.758-0.63-8.17-3.943-9.028-11.655h33.827c0,0,0.287-3.076,0.287-4.519c0-12.976-7.684-23.256-21.714-23.256
	c-14.704,0-24.894,10.571-24.894,25.658C59.769,60.918,66.847,71.63,83.083,71.63z M84.663,30.745c4.998,0,9.033,4.037,9.221,9.897
	H72.65C73.994,34.493,78.416,30.745,84.663,30.745z M5.66,88.155c0.234,0.06,0.402,0.136,0.504,0.229
	c0.103,0.094,0.173,0.228,0.213,0.396c0.041,0.171,0.062,0.446,0.062,0.83v0.382c0,0.455-0.122,0.792-0.364,1.011
	c-0.242,0.223-0.614,0.329-1.117,0.329c-0.471,0-0.869-0.146-1.193-0.45c-0.323-0.3-0.567-0.743-0.731-1.337
	c-0.162-0.592-0.245-1.305-0.245-2.139c0-0.825,0.097-1.525,0.291-2.104c0.194-0.58,0.464-1.018,0.812-1.317
	c0.35-0.298,0.756-0.445,1.221-0.445c0.336,0,0.613,0.046,0.832,0.139c0.219,0.093,0.407,0.242,0.564,0.46
	c0.158,0.212,0.294,0.512,0.409,0.896h0.633v-1.756c-0.448-0.11-0.855-0.188-1.22-0.232c-0.368-0.043-0.748-0.063-1.143-0.063
	c-0.753,0-1.409,0.185-1.966,0.553c-0.556,0.368-0.986,0.895-1.283,1.578c-0.298,0.687-0.446,1.481-0.446,2.39
	c0,1.455,0.272,2.554,0.816,3.288c0.545,0.738,1.356,1.107,2.432,1.107c0.393,0,0.739-0.04,1.04-0.122
	c0.303-0.08,0.593-0.206,0.869-0.376l0.466,0.498l0.498-0.134l-0.001-2.22c0-0.261,0.006-0.463,0.021-0.607
	c0.016-0.141,0.042-0.261,0.083-0.358c0.04-0.1,0.099-0.181,0.176-0.246c0.076-0.066,0.192-0.124,0.345-0.177v-0.312H5.66V88.155z
	 M14.688,90.214c-0.048,0.154-0.11,0.3-0.182,0.438c-0.073,0.143-0.155,0.255-0.249,0.343c-0.094,0.087-0.205,0.152-0.334,0.188
	c-0.131,0.034-0.3,0.054-0.508,0.054H11.43v-3.682h1.366c0.2,0,0.349,0.024,0.45,0.079c0.1,0.054,0.186,0.149,0.258,0.278
	c0.071,0.13,0.137,0.321,0.197,0.577h0.601v-2.451h-0.601c-0.063,0.275-0.131,0.476-0.199,0.603
	c-0.073,0.126-0.16,0.217-0.267,0.271c-0.106,0.054-0.252,0.08-0.439,0.08H11.43v-3.345h2.017c0.166,0,0.309,0.011,0.429,0.034
	c0.119,0.024,0.222,0.068,0.308,0.131c0.088,0.065,0.168,0.15,0.24,0.255c0.072,0.105,0.142,0.239,0.211,0.396
	c0.067,0.157,0.133,0.339,0.198,0.548h0.625v-1.928H9.49v0.312c0.197,0.055,0.334,0.104,0.416,0.146
	c0.08,0.045,0.145,0.107,0.194,0.183c0.049,0.073,0.084,0.176,0.105,0.312c0.021,0.134,0.032,0.348,0.032,0.644v5.521
	c0,0.313-0.014,0.549-0.041,0.7c-0.029,0.155-0.087,0.27-0.177,0.354c-0.089,0.083-0.265,0.16-0.529,0.229v0.312h5.91l0.121-2.237
	h-0.632C14.805,89.844,14.738,90.065,14.688,90.214z M23.501,90.937c-0.12-0.161-0.264-0.394-0.429-0.701l-0.574-1.047
	c-0.225-0.418-0.43-0.729-0.616-0.923c-0.184-0.198-0.407-0.352-0.667-0.455v-0.055c0.642-0.229,1.124-0.551,1.446-0.958
	c0.32-0.406,0.481-0.9,0.481-1.484c0-0.765-0.247-1.327-0.74-1.688c-0.493-0.358-1.238-0.542-2.234-0.542h-3.159v0.312
	c0.196,0.052,0.334,0.103,0.415,0.147s0.146,0.107,0.194,0.183c0.049,0.073,0.084,0.176,0.105,0.312
	c0.021,0.134,0.032,0.349,0.032,0.643v5.521c0,0.313-0.014,0.549-0.041,0.7c-0.029,0.155-0.086,0.27-0.176,0.354
	c-0.09,0.083-0.266,0.16-0.53,0.229v0.312h2.694v-0.312c-0.196-0.055-0.334-0.105-0.416-0.15c-0.08-0.046-0.144-0.103-0.19-0.173
	c-0.046-0.071-0.083-0.173-0.105-0.312c-0.023-0.141-0.036-0.359-0.036-0.666v-2.165h0.701c0.209,0,0.365,0.011,0.469,0.031
	c0.105,0.026,0.202,0.069,0.294,0.132c0.091,0.057,0.192,0.169,0.299,0.319c0.109,0.153,0.248,0.395,0.419,0.715l0.561,1.064
	c0.142,0.269,0.284,0.532,0.429,0.791c0.145,0.26,0.298,0.502,0.459,0.729h1.769v-0.312c-0.204-0.035-0.368-0.096-0.492-0.18
	C23.74,91.221,23.619,91.099,23.501,90.937z M20.576,87.38c-0.229,0.057-0.529,0.081-0.899,0.081h-0.722v-3.792
	c0.238-0.016,0.55-0.023,0.933-0.022c0.477,0,0.855,0.067,1.137,0.21c0.28,0.138,0.489,0.342,0.628,0.61
	c0.138,0.271,0.207,0.605,0.207,1.011c0,0.385-0.058,0.712-0.175,0.979c-0.117,0.268-0.274,0.476-0.47,0.621
	C21.019,87.229,20.806,87.328,20.576,87.38z M29.623,89.292l-2.241-6.211h-2.277v0.312c0.195,0.052,0.334,0.103,0.414,0.147
	c0.081,0.045,0.146,0.107,0.195,0.183c0.048,0.073,0.084,0.176,0.105,0.312c0.021,0.133,0.031,0.348,0.031,0.642v5.521
	c0,0.313-0.014,0.548-0.041,0.7c-0.028,0.155-0.086,0.27-0.176,0.354c-0.09,0.082-0.266,0.161-0.529,0.229v0.31h2.329v-0.312
	c-0.195-0.047-0.337-0.1-0.424-0.151c-0.088-0.048-0.153-0.116-0.198-0.189c-0.045-0.078-0.076-0.181-0.096-0.312
	c-0.019-0.132-0.029-0.342-0.029-0.625v-2.339c0-0.719-0.008-1.418-0.028-2.103c-0.019-0.679-0.039-1.148-0.06-1.407h0.107
	l2.349,6.426h0.734l2.527-6.323h0.108c-0.025,0.246-0.047,0.695-0.065,1.351c-0.02,0.656-0.029,1.306-0.029,1.95v2.444
	c0,0.343-0.018,0.589-0.052,0.739c-0.035,0.15-0.097,0.263-0.192,0.339c-0.093,0.076-0.261,0.141-0.503,0.203v0.31h2.661v-0.312
	c-0.195-0.047-0.337-0.1-0.424-0.151c-0.088-0.048-0.154-0.116-0.198-0.189c-0.046-0.078-0.076-0.181-0.096-0.312
	c-0.019-0.132-0.029-0.342-0.029-0.625v-5.521c0-0.296,0.012-0.51,0.035-0.65c0.023-0.138,0.06-0.246,0.108-0.315
	c0.05-0.071,0.115-0.128,0.198-0.176c0.083-0.047,0.217-0.094,0.405-0.142v-0.002h0.002v-0.312h-2.158L29.623,89.292z M42.3,90.857
	c-0.08-0.173-0.169-0.427-0.271-0.759l-2.17-7.116h-1.008l-2.662,7.062c-0.166,0.443-0.338,0.785-0.514,1.021
	c-0.178,0.239-0.384,0.376-0.623,0.415v0.312h2.725V91.48c-0.267-0.039-0.466-0.116-0.596-0.234
	c-0.13-0.121-0.195-0.306-0.195-0.562c0-0.127,0.018-0.277,0.052-0.439c0.034-0.161,0.107-0.403,0.217-0.716l0.218-0.625h2.974
	l0.235,0.823c0.064,0.209,0.113,0.394,0.147,0.562c0.034,0.167,0.051,0.325,0.051,0.472c0,0.15-0.025,0.272-0.076,0.364
	c-0.051,0.095-0.129,0.162-0.233,0.214c-0.104,0.053-0.263,0.101-0.475,0.143v0.312h2.941v-0.312
	c-0.191-0.046-0.343-0.12-0.453-0.217C42.474,91.169,42.379,91.033,42.3,90.857z M37.644,88.349l1.455-4.116l1.213,4.116H37.644z
	 M49.051,83.394c0.194,0.052,0.332,0.103,0.411,0.147s0.141,0.106,0.185,0.179c0.045,0.071,0.075,0.174,0.093,0.312
	c0.016,0.136,0.026,0.351,0.026,0.646v1.342c0,0.62,0.007,1.316,0.024,2.088c0.018,0.775,0.037,1.289,0.058,1.549h-0.082
	c-0.11-0.238-0.219-0.454-0.323-0.646c-0.105-0.189-0.234-0.41-0.386-0.669l-3.153-5.261h-1.997v0.312
	c0.195,0.052,0.333,0.103,0.415,0.147c0.081,0.045,0.146,0.107,0.194,0.183c0.048,0.073,0.084,0.176,0.105,0.312
	c0.02,0.134,0.032,0.348,0.032,0.642v5.521c0,0.313-0.015,0.549-0.041,0.7c-0.03,0.155-0.087,0.27-0.177,0.354
	c-0.089,0.082-0.264,0.161-0.529,0.229v0.31h2.329v-0.312c-0.195-0.047-0.337-0.1-0.424-0.151c-0.086-0.048-0.152-0.116-0.198-0.189
	c-0.044-0.078-0.076-0.181-0.096-0.312c-0.018-0.132-0.028-0.342-0.028-0.625v-1.307c0-0.851-0.007-1.706-0.019-2.562
	c-0.013-0.854-0.034-1.449-0.064-1.774h0.108c0.082,0.166,0.168,0.333,0.262,0.504c0.095,0.17,0.251,0.442,0.473,0.812l3.556,5.962
	h0.797v-7.152c0-0.313,0.014-0.533,0.038-0.673c0.026-0.137,0.063-0.239,0.113-0.307c0.047-0.067,0.111-0.123,0.19-0.166
	c0.078-0.042,0.214-0.089,0.405-0.142v-0.312h-2.297V83.394z M60.826,83.394c0.195,0.052,0.332,0.103,0.411,0.147
	c0.079,0.045,0.142,0.106,0.186,0.179c0.045,0.071,0.075,0.174,0.093,0.312c0.016,0.136,0.025,0.351,0.025,0.646v1.342
	c0,0.62,0.008,1.316,0.025,2.088c0.018,0.775,0.037,1.289,0.058,1.549h-0.083c-0.11-0.238-0.218-0.454-0.322-0.646
	c-0.105-0.189-0.235-0.41-0.387-0.669l-3.151-5.261h-1.999v0.312c0.197,0.052,0.334,0.103,0.416,0.147
	c0.081,0.045,0.145,0.107,0.193,0.183c0.049,0.073,0.084,0.176,0.105,0.312c0.021,0.134,0.033,0.348,0.033,0.642v5.521
	c0,0.313-0.015,0.549-0.042,0.7c-0.028,0.155-0.086,0.27-0.176,0.354c-0.089,0.082-0.264,0.161-0.53,0.229v0.31h2.33v-0.312
	c-0.195-0.047-0.337-0.1-0.424-0.151c-0.087-0.048-0.153-0.116-0.198-0.189c-0.044-0.078-0.077-0.181-0.096-0.312
	c-0.018-0.132-0.028-0.342-0.028-0.625v-1.307c0-0.851-0.007-1.706-0.019-2.562c-0.013-0.854-0.034-1.449-0.064-1.774h0.108
	c0.082,0.166,0.168,0.333,0.261,0.504c0.095,0.17,0.252,0.442,0.474,0.812l3.555,5.962h0.798v-7.152
	c0-0.313,0.013-0.533,0.038-0.673c0.026-0.137,0.063-0.239,0.112-0.307c0.048-0.067,0.111-0.123,0.191-0.166
	c0.078-0.042,0.213-0.089,0.405-0.142v-0.312h-2.298V83.394z M69.802,90.214c-0.048,0.154-0.11,0.3-0.182,0.438
	c-0.072,0.143-0.155,0.255-0.248,0.343c-0.095,0.087-0.205,0.152-0.335,0.188c-0.131,0.034-0.3,0.054-0.508,0.054h-1.985v-3.682
	h1.365c0.2,0,0.35,0.024,0.451,0.079c0.099,0.054,0.186,0.149,0.259,0.278c0.07,0.13,0.136,0.321,0.196,0.577h0.601v-2.451h-0.601
	c-0.063,0.275-0.131,0.476-0.2,0.603c-0.072,0.126-0.16,0.217-0.265,0.271c-0.107,0.054-0.253,0.08-0.441,0.08h-1.365v-3.345h2.017
	c0.167,0,0.309,0.011,0.428,0.034c0.12,0.024,0.223,0.068,0.31,0.131c0.087,0.065,0.167,0.15,0.24,0.255
	c0.07,0.105,0.141,0.239,0.21,0.396c0.068,0.157,0.134,0.339,0.197,0.548h0.626v-1.928l-5.967-0.003v0.312
	c0.196,0.052,0.334,0.103,0.415,0.147s0.146,0.107,0.194,0.183c0.049,0.073,0.084,0.176,0.105,0.312
	c0.02,0.134,0.032,0.348,0.032,0.643v5.521c0,0.312-0.015,0.549-0.041,0.7c-0.029,0.155-0.086,0.27-0.177,0.354
	c-0.089,0.083-0.265,0.16-0.529,0.229v0.312h5.91l0.121-2.236h-0.632C69.919,89.844,69.852,90.065,69.802,90.214z M71.771,85.312
	h0.632c0.081-0.344,0.166-0.622,0.259-0.849c0.092-0.224,0.193-0.397,0.303-0.518c0.11-0.121,0.23-0.2,0.361-0.239
	c0.129-0.038,0.294-0.058,0.494-0.058h0.804v6.536c0,0.255-0.011,0.445-0.035,0.58c-0.024,0.129-0.055,0.234-0.096,0.312
	c-0.04,0.077-0.091,0.137-0.153,0.188c-0.06,0.05-0.141,0.091-0.239,0.126c-0.098,0.034-0.211,0.065-0.339,0.097V91.8h2.917v-0.311
	c-0.208-0.046-0.362-0.095-0.459-0.146c-0.097-0.049-0.174-0.114-0.233-0.201c-0.057-0.085-0.1-0.205-0.128-0.354
	c-0.026-0.151-0.041-0.349-0.041-0.599v-6.536h0.812c0.233,0,0.409,0.02,0.525,0.068c0.118,0.048,0.227,0.125,0.329,0.235
	c0.103,0.109,0.199,0.271,0.291,0.483c0.09,0.213,0.183,0.502,0.277,0.868h0.626v-2.225h-6.906L71.771,85.312z M88.635,83.393
	c0.252,0.043,0.432,0.122,0.539,0.232c0.109,0.118,0.163,0.306,0.163,0.562c0,0.252-0.09,0.673-0.273,1.268l-1.507,4.869
	l-1.665-7.245h-1.074l-2.055,7.236l-1.281-5.041c-0.068-0.257-0.122-0.491-0.161-0.695c-0.038-0.205-0.057-0.381-0.057-0.529
	c0-0.184,0.051-0.324,0.155-0.429c0.105-0.101,0.289-0.177,0.552-0.229v-0.312h-2.73v0.312c0.139,0.039,0.247,0.084,0.322,0.139
	c0.074,0.049,0.144,0.131,0.206,0.235c0.065,0.104,0.128,0.249,0.192,0.432s0.134,0.42,0.211,0.708l1.856,6.933h1.035l2.042-7.131
	l1.762,7.134h0.913l2.324-6.89c0.11-0.325,0.206-0.583,0.29-0.771c0.082-0.196,0.159-0.334,0.229-0.429
	c0.071-0.091,0.144-0.164,0.221-0.216c0.078-0.055,0.179-0.103,0.307-0.146V83.08h-2.516V83.393z M97.109,83.486
	c-0.516-0.333-1.154-0.501-1.911-0.501c-0.711,0-1.336,0.178-1.874,0.532c-0.538,0.356-0.952,0.874-1.241,1.555
	c-0.29,0.678-0.435,1.495-0.435,2.443c0,0.769,0.083,1.43,0.246,1.983c0.164,0.549,0.396,1.007,0.695,1.361
	c0.301,0.354,0.66,0.617,1.08,0.785c0.418,0.168,0.884,0.252,1.393,0.252c0.724,0,1.357-0.169,1.9-0.506
	c0.543-0.345,0.963-0.853,1.261-1.538c0.299-0.686,0.447-1.525,0.447-2.521c0-0.932-0.132-1.723-0.393-2.371
	C98.015,84.311,97.626,83.82,97.109,83.486z M97.112,89.593c-0.163,0.57-0.405,1.005-0.728,1.3c-0.324,0.295-0.718,0.44-1.181,0.44
	c-0.732,0-1.288-0.338-1.67-1.021c-0.381-0.679-0.57-1.67-0.57-2.979c0-0.574,0.042-1.098,0.125-1.562
	c0.083-0.468,0.214-0.866,0.395-1.195c0.182-0.33,0.409-0.584,0.685-0.764c0.273-0.183,0.601-0.271,0.984-0.271
	c0.435,0,0.816,0.143,1.143,0.415c0.328,0.276,0.586,0.721,0.775,1.331c0.189,0.614,0.284,1.38,0.284,2.308
	C97.354,88.358,97.274,89.024,97.112,89.593z M106.693,90.937c-0.12-0.161-0.263-0.394-0.429-0.701l-0.573-1.047
	c-0.226-0.418-0.43-0.729-0.617-0.923c-0.184-0.198-0.407-0.352-0.666-0.455v-0.055c0.641-0.229,1.123-0.551,1.445-0.958
	c0.321-0.406,0.482-0.9,0.482-1.484c0-0.765-0.248-1.327-0.741-1.688c-0.493-0.358-1.238-0.542-2.233-0.542h-3.16v0.312
	c0.196,0.052,0.334,0.103,0.416,0.147c0.08,0.045,0.145,0.107,0.193,0.183c0.049,0.073,0.084,0.176,0.105,0.312
	c0.021,0.134,0.032,0.349,0.032,0.643v5.521c0,0.313-0.014,0.549-0.041,0.7c-0.029,0.155-0.086,0.27-0.176,0.354
	c-0.089,0.083-0.266,0.16-0.53,0.229v0.312h2.693v-0.312c-0.196-0.055-0.334-0.105-0.416-0.15c-0.079-0.046-0.144-0.103-0.19-0.173
	c-0.047-0.071-0.083-0.173-0.105-0.312c-0.022-0.141-0.035-0.359-0.035-0.666v-2.165h0.7c0.21,0,0.366,0.011,0.47,0.031
	c0.105,0.026,0.202,0.069,0.294,0.132c0.092,0.057,0.192,0.169,0.3,0.319c0.108,0.153,0.247,0.395,0.418,0.715l0.562,1.064
	c0.141,0.269,0.283,0.532,0.428,0.791c0.145,0.26,0.298,0.502,0.46,0.729h1.768v-0.312c-0.204-0.035-0.368-0.096-0.491-0.18
	C106.932,91.221,106.812,91.099,106.693,90.937z M103.767,87.38c-0.229,0.057-0.529,0.081-0.899,0.081h-0.721v-3.792
	c0.239-0.016,0.549-0.023,0.932-0.022c0.478,0,0.855,0.067,1.137,0.21c0.28,0.138,0.489,0.342,0.628,0.61
	c0.139,0.271,0.208,0.605,0.208,1.011c0,0.385-0.059,0.712-0.176,0.979c-0.117,0.268-0.274,0.476-0.469,0.621
	C104.21,87.229,103.997,87.328,103.767,87.38z M114.964,91.045c-0.141-0.146-0.333-0.395-0.581-0.751l-2.324-3.375l2.146-2.415
	c0.268-0.297,0.471-0.513,0.609-0.643c0.138-0.129,0.273-0.234,0.405-0.309c0.132-0.071,0.266-0.127,0.401-0.153v-0.312h-2.781
	v0.312c0.17,0.019,0.303,0.065,0.401,0.146c0.097,0.078,0.147,0.202,0.147,0.372c0,0.115-0.026,0.234-0.077,0.356
	c-0.064,0.167-0.189,0.371-0.376,0.61c-0.149,0.203-0.428,0.534-0.837,0.989c-0.34,0.384-0.594,0.644-0.76,0.786
	c-0.166,0.139-0.315,0.235-0.449,0.285c-0.134,0.052-0.282,0.077-0.444,0.077h-0.19l0.007-2.346c0-0.295,0.013-0.509,0.036-0.649
	c0.022-0.138,0.059-0.246,0.108-0.315c0.049-0.071,0.116-0.128,0.198-0.176c0.084-0.047,0.217-0.094,0.404-0.142v-0.312h-2.686
	v0.312c0.194,0.052,0.334,0.103,0.414,0.147c0.081,0.045,0.145,0.107,0.194,0.183c0.048,0.073,0.085,0.176,0.106,0.312
	c0.02,0.134,0.03,0.348,0.03,0.642v5.521c0,0.313-0.013,0.549-0.041,0.7c-0.029,0.155-0.086,0.27-0.175,0.354
	c-0.09,0.082-0.266,0.161-0.529,0.229v0.31h2.686v-0.312c-0.195-0.047-0.336-0.1-0.424-0.151c-0.087-0.048-0.152-0.116-0.198-0.189
	c-0.044-0.078-0.076-0.181-0.096-0.312c-0.018-0.132-0.029-0.342-0.029-0.625v-2.67h0.34c0.157,0,0.282,0.021,0.376,0.061
	c0.095,0.042,0.181,0.103,0.263,0.188c0.08,0.083,0.208,0.256,0.382,0.521l1.486,2.219c0.107,0.153,0.185,0.284,0.233,0.393
	c0.05,0.107,0.074,0.199,0.074,0.276c0,0.094-0.037,0.165-0.109,0.21c-0.073,0.048-0.187,0.077-0.345,0.09v0.312h2.815v-0.312
	c-0.144-0.023-0.281-0.068-0.409-0.13C115.239,91.291,115.105,91.189,114.964,91.045z M119.427,83.392
	c0.196,0.052,0.333,0.103,0.415,0.147c0.08,0.045,0.145,0.107,0.193,0.183c0.049,0.073,0.084,0.176,0.105,0.312
	c0.021,0.134,0.033,0.348,0.033,0.643v5.521c0,0.313-0.015,0.549-0.042,0.7c-0.029,0.155-0.086,0.27-0.176,0.354
	c-0.09,0.083-0.265,0.16-0.529,0.229v0.312h2.833v-0.312c-0.17-0.041-0.313-0.082-0.428-0.126c-0.114-0.045-0.206-0.11-0.273-0.2
	c-0.068-0.091-0.117-0.21-0.147-0.363c-0.03-0.15-0.044-0.354-0.044-0.609v-2.503h1.314c0.195,0,0.343,0.03,0.442,0.093
	c0.102,0.061,0.188,0.166,0.259,0.312c0.072,0.146,0.141,0.365,0.205,0.652h0.6v-2.69h-0.6c-0.064,0.303-0.132,0.523-0.201,0.669
	c-0.071,0.146-0.159,0.25-0.265,0.312c-0.107,0.062-0.253,0.094-0.44,0.094h-1.314v-3.473h1.869c0.209,0,0.377,0.02,0.505,0.058
	c0.127,0.039,0.239,0.103,0.335,0.198c0.094,0.094,0.186,0.228,0.273,0.407c0.087,0.179,0.178,0.413,0.272,0.699h0.625v-1.928
	l-5.819-0.003V83.392z M131.792,83.486c-0.517-0.333-1.154-0.501-1.911-0.501c-0.711,0-1.336,0.178-1.874,0.532
	c-0.539,0.356-0.952,0.874-1.241,1.555c-0.29,0.678-0.435,1.495-0.435,2.443c0,0.769,0.082,1.431,0.246,1.983
	c0.164,0.549,0.396,1.007,0.695,1.361c0.3,0.354,0.66,0.617,1.08,0.785c0.418,0.168,0.884,0.252,1.394,0.252
	c0.724,0,1.356-0.169,1.9-0.506c0.542-0.345,0.962-0.853,1.26-1.538c0.298-0.686,0.447-1.525,0.447-2.521
	c0-0.932-0.132-1.723-0.392-2.371C132.697,84.311,132.309,83.82,131.792,83.486z M131.795,89.593c-0.163,0.57-0.405,1.005-0.729,1.3
	c-0.323,0.295-0.717,0.44-1.181,0.44c-0.731,0-1.287-0.338-1.669-1.021c-0.381-0.679-0.57-1.67-0.57-2.979
	c0-0.574,0.042-1.095,0.124-1.562c0.084-0.468,0.215-0.866,0.396-1.195c0.181-0.33,0.409-0.584,0.684-0.764
	c0.273-0.183,0.602-0.271,0.985-0.271c0.435,0,0.816,0.143,1.143,0.415c0.328,0.276,0.586,0.721,0.775,1.331
	c0.189,0.614,0.285,1.38,0.285,2.308C132.038,88.358,131.957,89.024,131.795,89.593z M141.375,90.937
	c-0.119-0.161-0.263-0.394-0.428-0.701l-0.575-1.047c-0.223-0.418-0.429-0.729-0.614-0.923c-0.185-0.198-0.408-0.352-0.668-0.455
	v-0.055c0.643-0.229,1.126-0.551,1.445-0.958c0.321-0.406,0.483-0.9,0.483-1.484c0-0.765-0.248-1.327-0.74-1.688
	c-0.494-0.358-1.24-0.542-2.234-0.542h-3.159v0.312c0.195,0.052,0.333,0.103,0.415,0.147c0.08,0.045,0.145,0.107,0.193,0.183
	c0.049,0.073,0.084,0.176,0.105,0.312c0.021,0.134,0.033,0.349,0.033,0.643v5.521c0,0.313-0.015,0.549-0.042,0.7
	c-0.029,0.155-0.086,0.27-0.177,0.354c-0.089,0.083-0.264,0.16-0.528,0.229v0.312h2.693v-0.312c-0.196-0.055-0.334-0.105-0.415-0.15
	c-0.081-0.046-0.144-0.103-0.191-0.173c-0.047-0.071-0.082-0.173-0.105-0.312c-0.023-0.141-0.035-0.359-0.035-0.666v-2.165h0.699
	c0.209,0,0.366,0.011,0.47,0.031c0.106,0.026,0.203,0.069,0.294,0.132c0.091,0.057,0.191,0.169,0.3,0.319
	c0.108,0.153,0.247,0.395,0.418,0.715l0.562,1.064c0.142,0.269,0.282,0.532,0.428,0.791c0.146,0.26,0.299,0.502,0.459,0.729h1.769
	v-0.312c-0.204-0.035-0.368-0.096-0.492-0.18C141.614,91.221,141.494,91.099,141.375,90.937z M138.451,87.38
	c-0.228,0.057-0.529,0.081-0.899,0.081h-0.721v-3.792c0.237-0.016,0.549-0.023,0.933-0.022c0.476,0,0.854,0.067,1.136,0.21
	c0.28,0.138,0.489,0.342,0.629,0.61c0.137,0.271,0.206,0.605,0.206,1.011c0,0.385-0.057,0.712-0.176,0.979
	c-0.116,0.268-0.273,0.476-0.469,0.621C138.894,87.229,138.681,87.328,138.451,87.38z M150.561,87.238v-0.057
	c0.361-0.155,0.657-0.319,0.886-0.498c0.231-0.183,0.417-0.407,0.559-0.679c0.144-0.273,0.215-0.594,0.215-0.965
	c0-0.45-0.101-0.812-0.3-1.096c-0.2-0.285-0.506-0.499-0.916-0.646c-0.41-0.144-0.955-0.216-1.631-0.216h-3.492v0.312
	c0.196,0.052,0.335,0.103,0.415,0.147s0.145,0.107,0.195,0.183c0.048,0.073,0.083,0.176,0.104,0.312
	c0.022,0.133,0.032,0.351,0.032,0.644v5.52c0,0.313-0.014,0.549-0.041,0.7c-0.028,0.155-0.086,0.27-0.176,0.354
	c-0.09,0.082-0.265,0.161-0.53,0.229v0.321h3.286c0.661,0,1.223-0.079,1.687-0.243c0.463-0.163,0.823-0.432,1.081-0.795
	c0.258-0.366,0.387-0.841,0.387-1.416c0-0.506-0.149-0.941-0.447-1.303C151.578,87.682,151.138,87.413,150.561,87.238z
	 M147.819,83.686c0.133-0.005,0.33-0.017,0.594-0.024c0.265-0.009,0.477-0.013,0.64-0.013c0.267,0,0.517,0.02,0.747,0.069
	c0.23,0.052,0.428,0.135,0.596,0.245c0.168,0.116,0.299,0.273,0.396,0.464c0.096,0.193,0.144,0.438,0.144,0.73
	c0,0.593-0.171,1.05-0.514,1.362c-0.342,0.313-0.837,0.47-1.484,0.47l-1.119,0.004V83.686z M150.831,90.401
	c-0.14,0.271-0.361,0.478-0.67,0.622c-0.308,0.141-0.741,0.21-1.299,0.21c-0.384,0-0.729-0.018-1.041-0.045V87.55h0.989
	c0.553,0,0.988,0.065,1.302,0.197c0.316,0.132,0.549,0.332,0.7,0.604c0.152,0.267,0.226,0.607,0.226,1.021
	C151.038,89.783,150.97,90.128,150.831,90.401z M153.873,83.393c0.196,0.052,0.334,0.103,0.416,0.147
	c0.08,0.045,0.144,0.107,0.193,0.183c0.049,0.073,0.084,0.176,0.105,0.312c0.021,0.134,0.033,0.348,0.033,0.642v5.521
	c0,0.31-0.015,0.549-0.042,0.7c-0.028,0.155-0.086,0.27-0.176,0.354c-0.089,0.082-0.266,0.161-0.53,0.229v0.31h2.694v-0.312
	c-0.197-0.047-0.338-0.1-0.426-0.151c-0.088-0.048-0.152-0.116-0.196-0.189c-0.046-0.078-0.077-0.181-0.097-0.312
	c-0.017-0.132-0.028-0.342-0.028-0.625h0.002v-5.524c0-0.295,0.013-0.509,0.035-0.649c0.024-0.138,0.059-0.246,0.108-0.315
	c0.048-0.071,0.114-0.128,0.198-0.176c0.082-0.047,0.218-0.094,0.405-0.142v-0.312h-2.694V83.393z M163.558,83.486
	c-0.516-0.333-1.153-0.501-1.91-0.501c-0.711,0-1.335,0.178-1.874,0.532c-0.538,0.356-0.952,0.874-1.241,1.555
	c-0.29,0.678-0.435,1.495-0.435,2.443c0,0.769,0.082,1.43,0.247,1.983c0.163,0.549,0.394,1.007,0.694,1.361
	c0.3,0.354,0.66,0.617,1.079,0.785s0.884,0.252,1.395,0.252c0.723,0,1.356-0.169,1.9-0.506c0.542-0.345,0.963-0.853,1.259-1.538
	c0.299-0.686,0.448-1.525,0.448-2.521c0-0.932-0.132-1.723-0.393-2.371C164.464,84.311,164.077,83.82,163.558,83.486z
	 M163.562,89.593c-0.162,0.57-0.405,1.005-0.729,1.3s-0.717,0.44-1.18,0.44c-0.732,0-1.289-0.338-1.67-1.021
	c-0.381-0.679-0.571-1.67-0.571-2.979c0-0.574,0.043-1.095,0.126-1.562s0.214-0.866,0.396-1.195c0.179-0.33,0.408-0.584,0.682-0.764
	c0.275-0.183,0.603-0.271,0.986-0.271c0.434,0,0.816,0.143,1.143,0.415c0.328,0.276,0.586,0.721,0.775,1.331
	c0.189,0.614,0.284,1.38,0.284,2.308C163.804,88.358,163.723,89.024,163.562,89.593z M166.652,83.393
	c0.197,0.052,0.335,0.103,0.417,0.147c0.08,0.045,0.144,0.107,0.193,0.183c0.049,0.073,0.084,0.176,0.104,0.312
	c0.022,0.134,0.034,0.348,0.034,0.642v5.521c0,0.31-0.015,0.549-0.042,0.7c-0.029,0.155-0.086,0.27-0.177,0.354
	c-0.089,0.082-0.265,0.161-0.53,0.229v0.31h2.695v-0.312c-0.197-0.047-0.338-0.1-0.426-0.151c-0.087-0.048-0.152-0.116-0.197-0.189
	c-0.045-0.078-0.076-0.181-0.097-0.312c-0.017-0.132-0.027-0.342-0.027-0.625h0.002v-5.524c0-0.295,0.012-0.509,0.035-0.649
	c0.023-0.138,0.059-0.246,0.108-0.315c0.049-0.071,0.114-0.128,0.198-0.176c0.082-0.047,0.217-0.094,0.405-0.142v-0.312h-2.695
	V83.393z M176.009,83.394c0.195,0.052,0.333,0.103,0.411,0.147c0.081,0.045,0.141,0.106,0.186,0.179
	c0.045,0.071,0.076,0.174,0.093,0.312c0.017,0.136,0.026,0.351,0.026,0.646v1.342c0,0.62,0.006,1.316,0.023,2.088
	c0.019,0.775,0.038,1.289,0.059,1.549h-0.082c-0.111-0.238-0.219-0.454-0.324-0.646c-0.104-0.189-0.232-0.41-0.386-0.669
	l-3.151-5.261h-1.997v0.312c0.195,0.052,0.334,0.103,0.415,0.147c0.08,0.045,0.145,0.107,0.193,0.183
	c0.048,0.073,0.085,0.176,0.106,0.312c0.02,0.134,0.032,0.348,0.032,0.642v5.521c0,0.313-0.015,0.549-0.042,0.7
	c-0.028,0.155-0.086,0.27-0.176,0.354c-0.09,0.082-0.265,0.161-0.529,0.229v0.31h2.329v-0.312c-0.196-0.047-0.337-0.1-0.425-0.151
	c-0.086-0.048-0.152-0.116-0.197-0.189c-0.045-0.078-0.076-0.181-0.096-0.312c-0.019-0.132-0.029-0.342-0.029-0.625v-1.307
	c0-0.851-0.006-1.706-0.018-2.562c-0.013-0.854-0.036-1.449-0.064-1.774h0.108c0.081,0.166,0.169,0.333,0.262,0.504
	c0.093,0.17,0.251,0.442,0.473,0.812l3.555,5.962h0.799v-7.152c0-0.313,0.012-0.533,0.037-0.673
	c0.026-0.137,0.062-0.239,0.113-0.307c0.046-0.067,0.113-0.123,0.188-0.166c0.08-0.042,0.217-0.089,0.408-0.142v-0.312h-2.3V83.394z
	 M179.791,83.392c0.195,0.052,0.334,0.103,0.416,0.147c0.08,0.045,0.143,0.107,0.193,0.183c0.045,0.073,0.082,0.176,0.104,0.312
	c0.018,0.134,0.031,0.348,0.031,0.643v5.521c0,0.313-0.016,0.549-0.041,0.7c-0.03,0.155-0.086,0.27-0.178,0.354
	c-0.09,0.083-0.262,0.16-0.529,0.229v0.312h2.836v-0.312c-0.17-0.041-0.314-0.082-0.432-0.126c-0.111-0.045-0.205-0.11-0.271-0.2
	c-0.068-0.091-0.119-0.21-0.146-0.363c-0.026-0.15-0.045-0.354-0.045-0.609v-2.503h1.314c0.195,0,0.339,0.03,0.441,0.093
	c0.1,0.061,0.188,0.166,0.26,0.312c0.07,0.146,0.141,0.365,0.203,0.652h0.602v-2.69h-0.602c-0.062,0.303-0.131,0.523-0.199,0.669
	c-0.075,0.146-0.162,0.25-0.266,0.312c-0.105,0.062-0.252,0.094-0.439,0.094h-1.314v-3.473h1.869c0.209,0,0.377,0.02,0.504,0.058
	c0.127,0.039,0.238,0.103,0.336,0.198c0.094,0.094,0.186,0.227,0.273,0.407c0.083,0.179,0.178,0.413,0.271,0.699h0.625v-1.928
	l-5.816-0.003V83.392z M192.154,83.486c-0.516-0.333-1.153-0.501-1.911-0.501c-0.711,0-1.334,0.178-1.873,0.532
	c-0.537,0.356-0.953,0.874-1.24,1.555c-0.291,0.678-0.437,1.495-0.437,2.443c0,0.769,0.082,1.43,0.246,1.983
	c0.164,0.549,0.393,1.007,0.693,1.361c0.303,0.354,0.659,0.617,1.078,0.785s0.887,0.252,1.396,0.252
	c0.725,0,1.356-0.169,1.901-0.506c0.541-0.345,0.964-0.853,1.263-1.538c0.297-0.686,0.444-1.525,0.444-2.521
	c0-0.932-0.131-1.723-0.393-2.371C193.059,84.311,192.673,83.82,192.154,83.486z M192.159,89.593c-0.164,0.57-0.406,1.005-0.729,1.3
	c-0.326,0.295-0.718,0.44-1.181,0.44c-0.731,0-1.289-0.338-1.67-1.021c-0.381-0.679-0.572-1.67-0.572-2.979
	c0-0.574,0.042-1.098,0.126-1.562c0.084-0.468,0.215-0.866,0.396-1.195c0.183-0.33,0.41-0.584,0.685-0.764
	c0.272-0.183,0.601-0.271,0.986-0.271c0.434,0,0.817,0.143,1.143,0.415c0.328,0.276,0.587,0.721,0.775,1.331
	c0.187,0.614,0.282,1.38,0.282,2.308C192.4,88.358,192.318,89.024,192.159,89.593z M201.738,90.937
	c-0.119-0.161-0.264-0.394-0.428-0.701l-0.576-1.047c-0.225-0.418-0.428-0.729-0.615-0.923c-0.184-0.198-0.408-0.352-0.666-0.455
	v-0.055c0.639-0.229,1.123-0.551,1.443-0.958c0.319-0.406,0.479-0.9,0.479-1.484c0-0.765-0.246-1.327-0.737-1.688
	c-0.492-0.358-1.238-0.542-2.234-0.542h-3.158v0.312c0.195,0.052,0.334,0.103,0.416,0.147c0.08,0.045,0.145,0.107,0.193,0.183
	c0.049,0.073,0.084,0.176,0.104,0.312c0.021,0.134,0.033,0.349,0.033,0.643v5.521c0,0.313-0.014,0.549-0.041,0.7
	c-0.03,0.155-0.088,0.27-0.178,0.354c-0.088,0.083-0.264,0.16-0.527,0.229v0.312h2.691v-0.312c-0.195-0.055-0.334-0.105-0.414-0.15
	c-0.08-0.046-0.143-0.103-0.191-0.173c-0.047-0.071-0.083-0.173-0.104-0.312c-0.023-0.141-0.037-0.359-0.037-0.666v-2.165h0.695
	c0.209,0,0.366,0.011,0.471,0.031c0.104,0.026,0.201,0.069,0.293,0.132c0.093,0.057,0.193,0.169,0.302,0.319
	c0.106,0.153,0.248,0.395,0.416,0.715l0.562,1.064c0.144,0.269,0.284,0.532,0.43,0.791c0.147,0.26,0.3,0.502,0.459,0.729h1.771
	v-0.312c-0.202-0.035-0.364-0.096-0.487-0.18C201.977,91.221,201.855,91.099,201.738,90.937z M198.812,87.38
	c-0.229,0.057-0.527,0.081-0.898,0.081h-0.723v-3.792c0.24-0.016,0.551-0.023,0.934-0.022c0.479,0,0.855,0.067,1.137,0.21
	c0.279,0.138,0.49,0.342,0.629,0.61c0.139,0.271,0.207,0.605,0.207,1.011c0,0.385-0.059,0.712-0.176,0.979
	c-0.115,0.268-0.275,0.476-0.469,0.621C199.253,87.229,199.041,87.328,198.812,87.38z M207.867,89.292l-2.24-6.211h-2.279v0.312
	c0.197,0.052,0.336,0.103,0.416,0.147s0.145,0.107,0.193,0.183c0.048,0.073,0.083,0.176,0.104,0.312
	c0.022,0.133,0.032,0.348,0.032,0.642v5.521c0,0.313-0.014,0.548-0.041,0.7c-0.028,0.155-0.086,0.27-0.178,0.354
	c-0.088,0.082-0.263,0.161-0.526,0.229v0.31h2.329v-0.312c-0.196-0.047-0.338-0.1-0.426-0.151c-0.086-0.048-0.151-0.116-0.196-0.189
	c-0.043-0.078-0.076-0.181-0.097-0.312c-0.019-0.132-0.028-0.342-0.028-0.625v-2.339c0-0.719-0.008-1.418-0.029-2.103
	c-0.017-0.679-0.039-1.148-0.06-1.407h0.106l2.351,6.426h0.733l2.527-6.323h0.105c-0.023,0.246-0.044,0.695-0.064,1.351
	c-0.019,0.656-0.029,1.306-0.029,1.95v2.444c0,0.343-0.02,0.588-0.051,0.739c-0.033,0.15-0.097,0.263-0.19,0.339
	c-0.095,0.076-0.263,0.141-0.505,0.203v0.31h2.66v-0.312c-0.195-0.047-0.336-0.1-0.424-0.151c-0.088-0.048-0.152-0.116-0.197-0.189
	c-0.045-0.078-0.075-0.181-0.096-0.312c-0.019-0.132-0.029-0.342-0.029-0.625v-5.521c0-0.296,0.014-0.51,0.035-0.65
	c0.021-0.138,0.057-0.246,0.105-0.315c0.053-0.071,0.115-0.128,0.199-0.176c0.082-0.047,0.214-0.094,0.4-0.142v-0.002h0.008v-0.312
	h-2.154L207.867,89.292z M220.534,90.857c-0.08-0.173-0.167-0.427-0.271-0.759l-2.173-7.116h-1.01l-2.66,7.062
	c-0.166,0.443-0.336,0.785-0.514,1.021c-0.179,0.239-0.386,0.376-0.623,0.415v0.312h2.728V91.48
	c-0.271-0.039-0.468-0.116-0.599-0.234c-0.129-0.121-0.192-0.306-0.192-0.562c0-0.127,0.02-0.277,0.049-0.439
	c0.037-0.161,0.109-0.403,0.221-0.716l0.217-0.625h2.977l0.234,0.823c0.064,0.209,0.114,0.394,0.146,0.562
	c0.033,0.167,0.054,0.325,0.054,0.472c0,0.15-0.028,0.272-0.078,0.364c-0.048,0.095-0.126,0.162-0.231,0.214
	c-0.104,0.053-0.265,0.101-0.476,0.143v0.312h2.935v-0.312c-0.187-0.046-0.34-0.119-0.451-0.217
	C220.708,91.169,220.611,91.033,220.534,90.857z M215.882,88.349l1.455-4.116l1.211,4.116H215.882z M221.053,83.086h-0.003v2.227
	h0.632c0.082-0.344,0.168-0.622,0.26-0.849c0.094-0.224,0.197-0.397,0.307-0.518c0.107-0.121,0.227-0.2,0.357-0.239
	c0.129-0.038,0.295-0.058,0.494-0.058h0.803v6.536c0,0.255-0.01,0.445-0.031,0.58c-0.028,0.129-0.059,0.234-0.1,0.312
	c-0.039,0.077-0.09,0.137-0.15,0.188c-0.061,0.05-0.141,0.091-0.238,0.126c-0.1,0.034-0.211,0.065-0.34,0.097V91.8h2.918v-0.311
	c-0.209-0.046-0.361-0.095-0.459-0.146c-0.098-0.049-0.173-0.114-0.232-0.201c-0.059-0.085-0.104-0.205-0.127-0.354
	c-0.028-0.151-0.043-0.349-0.043-0.599v-6.536h0.812c0.23,0,0.406,0.02,0.523,0.068c0.117,0.048,0.225,0.125,0.328,0.235
	c0.104,0.109,0.198,0.271,0.291,0.483c0.09,0.213,0.182,0.502,0.276,0.868h0.625v-2.225h-6.904L221.053,83.086z M229.156,83.393
	c0.195,0.052,0.334,0.103,0.416,0.147c0.08,0.045,0.143,0.107,0.193,0.183c0.043,0.073,0.082,0.176,0.104,0.312
	c0.018,0.134,0.029,0.348,0.029,0.642v5.521c0,0.31-0.015,0.549-0.041,0.7c-0.028,0.155-0.088,0.27-0.176,0.354
	c-0.091,0.082-0.264,0.161-0.531,0.229v0.31h2.695v-0.312c-0.197-0.047-0.339-0.1-0.427-0.151c-0.088-0.048-0.151-0.116-0.196-0.189
	c-0.046-0.078-0.076-0.181-0.097-0.312c-0.019-0.132-0.028-0.342-0.028-0.625h0.008v-5.524c0-0.295,0.014-0.509,0.035-0.649
	c0.022-0.138,0.057-0.246,0.106-0.315c0.049-0.071,0.114-0.128,0.198-0.176c0.082-0.047,0.218-0.094,0.406-0.142v-0.312h-2.695
	V83.393z M237.074,82.972c-0.775,0-1.439,0.188-1.998,0.562c-0.559,0.375-0.983,0.902-1.268,1.59
	c-0.287,0.688-0.433,1.484-0.433,2.396c0,1.45,0.272,2.542,0.828,3.271c0.553,0.733,1.371,1.1,2.448,1.1
	c0.505,0,0.966-0.025,1.386-0.079c0.419-0.052,0.83-0.135,1.229-0.239v-1.825h-0.635c-0.137,0.421-0.281,0.741-0.43,0.957
	c-0.155,0.218-0.342,0.376-0.562,0.479c-0.221,0.097-0.504,0.146-0.854,0.146c-0.461,0-0.85-0.146-1.162-0.45
	c-0.318-0.3-0.553-0.741-0.715-1.334c-0.162-0.59-0.242-1.302-0.242-2.135c0-0.829,0.1-1.537,0.293-2.122
	c0.198-0.583,0.467-1.02,0.811-1.312c0.342-0.292,0.731-0.438,1.17-0.438c0.295,0,0.547,0.047,0.754,0.143
	c0.209,0.094,0.394,0.25,0.55,0.47c0.159,0.22,0.289,0.515,0.392,0.885h0.631v-1.769c-0.422-0.111-0.795-0.187-1.123-0.234
	C237.818,82.993,237.461,82.972,237.074,82.972z M244.789,87.61c-0.301-0.236-0.725-0.489-1.268-0.76
	c-0.453-0.224-0.793-0.424-1.021-0.602c-0.234-0.181-0.402-0.374-0.508-0.581c-0.107-0.209-0.162-0.464-0.162-0.768
	c0-0.284,0.059-0.53,0.188-0.736c0.129-0.207,0.301-0.358,0.521-0.463c0.219-0.099,0.467-0.152,0.744-0.152
	c0.318,0,0.576,0.04,0.777,0.123c0.198,0.084,0.375,0.229,0.521,0.438c0.147,0.207,0.269,0.499,0.371,0.874h0.631V83.26
	c-0.465-0.12-0.847-0.196-1.158-0.229c-0.304-0.035-0.625-0.053-0.944-0.053c-0.557,0-1.051,0.097-1.484,0.287
	c-0.43,0.188-0.758,0.459-0.98,0.812c-0.225,0.349-0.336,0.76-0.336,1.239c0,0.328,0.07,0.631,0.215,0.905
	c0.141,0.278,0.355,0.535,0.646,0.771c0.289,0.238,0.684,0.48,1.182,0.725c0.512,0.258,0.896,0.481,1.148,0.674
	c0.25,0.188,0.432,0.392,0.541,0.609c0.111,0.219,0.168,0.489,0.168,0.807c0,0.498-0.131,0.876-0.4,1.137
	c-0.265,0.261-0.646,0.39-1.146,0.39c-0.364,0-0.657-0.05-0.886-0.153c-0.23-0.103-0.418-0.264-0.562-0.48
	c-0.146-0.218-0.259-0.512-0.345-0.886v0.002h-0.64v1.75c0.873,0.226,1.644,0.338,2.312,0.338c0.41,0,0.793-0.044,1.139-0.13
	c0.349-0.088,0.647-0.231,0.896-0.422c0.25-0.193,0.443-0.445,0.584-0.753c0.143-0.312,0.212-0.691,0.212-1.137
	c0-0.4-0.083-0.75-0.253-1.049C245.322,88.11,245.09,87.842,244.789,87.61z M241.24,89.81c0,0.001,0.001,0.002,0.001,0.003
	L241.24,89.81L241.24,89.81z M250.027,83.393c0.197,0.052,0.334,0.103,0.416,0.147c0.08,0.045,0.141,0.107,0.189,0.183
	c0.047,0.073,0.083,0.176,0.104,0.312c0.021,0.134,0.033,0.348,0.033,0.642v5.521c0,0.31-0.015,0.549-0.043,0.7
	c-0.028,0.155-0.086,0.27-0.177,0.354c-0.088,0.082-0.261,0.161-0.528,0.229v0.31h2.692v-0.312c-0.194-0.047-0.338-0.1-0.424-0.151
	c-0.088-0.048-0.153-0.116-0.197-0.189c-0.045-0.078-0.077-0.181-0.098-0.312c-0.017-0.132-0.027-0.342-0.027-0.625h0.009v-5.524
	c0-0.295,0.012-0.509,0.035-0.649c0.021-0.138,0.057-0.246,0.106-0.315c0.049-0.071,0.114-0.128,0.198-0.176
	c0.082-0.047,0.215-0.094,0.402-0.142v-0.312h-2.691V83.393z M259.378,83.394c0.195,0.052,0.331,0.103,0.412,0.147
	s0.142,0.106,0.185,0.179c0.045,0.071,0.075,0.174,0.094,0.312c0.017,0.136,0.024,0.351,0.024,0.646v1.342
	c0,0.62,0.007,1.316,0.025,2.088c0.019,0.775,0.036,1.289,0.057,1.549h-0.082c-0.11-0.238-0.217-0.454-0.321-0.646
	c-0.106-0.189-0.233-0.41-0.388-0.669l-3.147-5.261h-1.998v0.312c0.195,0.052,0.336,0.103,0.414,0.147
	c0.082,0.045,0.144,0.107,0.195,0.183c0.045,0.073,0.082,0.176,0.104,0.312c0.02,0.134,0.029,0.348,0.029,0.642v5.521
	c0,0.313-0.014,0.549-0.041,0.7c-0.028,0.155-0.086,0.27-0.176,0.354c-0.088,0.082-0.264,0.161-0.529,0.229v0.31h2.328v-0.312
	c-0.194-0.047-0.334-0.1-0.424-0.151c-0.086-0.048-0.151-0.116-0.197-0.189c-0.045-0.078-0.075-0.181-0.096-0.312
	c-0.018-0.132-0.029-0.342-0.029-0.625v-1.307c0-0.851-0.008-1.706-0.019-2.562c-0.009-0.854-0.034-1.449-0.063-1.774h0.106
	c0.082,0.166,0.171,0.333,0.263,0.504c0.096,0.17,0.252,0.442,0.477,0.812l3.555,5.962h0.801v-7.152
	c0-0.313,0.012-0.533,0.037-0.673c0.023-0.137,0.063-0.239,0.109-0.307s0.109-0.123,0.189-0.166
	c0.078-0.042,0.213-0.089,0.406-0.142v-0.312h-2.3V83.394z M263.162,83.392c0.195,0.052,0.335,0.103,0.414,0.147
	c0.08,0.045,0.146,0.107,0.195,0.183c0.047,0.073,0.082,0.176,0.104,0.312c0.02,0.134,0.032,0.348,0.032,0.643v5.521
	c0,0.313-0.015,0.549-0.044,0.7c-0.028,0.155-0.084,0.27-0.176,0.354c-0.088,0.083-0.264,0.16-0.527,0.229v0.312h2.834v-0.312
	c-0.171-0.041-0.314-0.082-0.428-0.126c-0.113-0.045-0.207-0.11-0.273-0.2c-0.068-0.091-0.119-0.21-0.146-0.363
	c-0.028-0.15-0.047-0.354-0.047-0.609v-2.503h1.318c0.191,0,0.337,0.03,0.438,0.093c0.104,0.061,0.191,0.166,0.262,0.312
	s0.14,0.365,0.201,0.652h0.604v-2.69h-0.604c-0.059,0.303-0.131,0.523-0.197,0.669c-0.073,0.146-0.161,0.25-0.268,0.312
	c-0.105,0.062-0.252,0.094-0.438,0.094H265.1v-3.473h1.871c0.211,0,0.377,0.02,0.506,0.058c0.127,0.039,0.236,0.103,0.336,0.198
	c0.092,0.094,0.185,0.228,0.271,0.407c0.086,0.179,0.176,0.413,0.271,0.699h0.625v-1.928l-5.816-0.003V83.392z M276.662,90.937
	c-0.119-0.161-0.266-0.394-0.43-0.701l-0.572-1.047c-0.223-0.418-0.428-0.729-0.615-0.923c-0.189-0.198-0.404-0.352-0.668-0.455
	v-0.055c0.639-0.229,1.125-0.551,1.443-0.958c0.32-0.406,0.48-0.9,0.48-1.484c0-0.765-0.246-1.327-0.738-1.688
	c-0.494-0.358-1.236-0.542-2.232-0.542h-3.16v0.312c0.197,0.052,0.336,0.103,0.416,0.147s0.143,0.107,0.193,0.183
	c0.047,0.073,0.084,0.176,0.104,0.312c0.019,0.134,0.03,0.349,0.03,0.643v5.521c0,0.313-0.016,0.549-0.039,0.7
	c-0.029,0.155-0.088,0.27-0.176,0.354c-0.094,0.083-0.266,0.16-0.533,0.229v0.312h2.693v-0.312c-0.193-0.055-0.334-0.105-0.412-0.15
	c-0.082-0.046-0.143-0.103-0.191-0.173c-0.045-0.071-0.083-0.173-0.104-0.312c-0.023-0.141-0.035-0.359-0.035-0.666v-2.165h0.695
	c0.207,0,0.365,0.011,0.469,0.031c0.107,0.026,0.203,0.069,0.296,0.132c0.09,0.057,0.192,0.169,0.299,0.319
	c0.108,0.153,0.248,0.395,0.419,0.715l0.562,1.064c0.142,0.269,0.283,0.532,0.429,0.791c0.146,0.26,0.299,0.502,0.461,0.729h1.769
	v-0.312c-0.205-0.035-0.369-0.096-0.492-0.18C276.9,91.221,276.779,91.099,276.662,90.937z M273.738,87.38
	c-0.229,0.057-0.529,0.081-0.898,0.081h-0.723v-3.792c0.238-0.016,0.549-0.023,0.934-0.022c0.477,0,0.857,0.067,1.135,0.21
	c0.281,0.138,0.49,0.342,0.629,0.61c0.144,0.271,0.209,0.605,0.209,1.011c0,0.385-0.059,0.712-0.176,0.979
	c-0.117,0.268-0.275,0.476-0.471,0.621C274.182,87.229,273.967,87.328,273.738,87.38z M284.803,90.857
	c-0.08-0.173-0.169-0.427-0.271-0.759l-2.171-7.116h-1.01l-2.662,7.062c-0.166,0.443-0.336,0.785-0.516,1.021
	c-0.178,0.239-0.383,0.376-0.619,0.415v0.312h2.725V91.48c-0.268-0.039-0.467-0.116-0.596-0.234
	c-0.133-0.121-0.194-0.306-0.194-0.562c0-0.127,0.018-0.277,0.051-0.439c0.033-0.161,0.108-0.403,0.219-0.716l0.216-0.625h2.979
	l0.232,0.823c0.063,0.209,0.112,0.394,0.147,0.562c0.033,0.167,0.049,0.325,0.049,0.472c0,0.15-0.024,0.272-0.073,0.364
	c-0.049,0.095-0.129,0.162-0.232,0.214c-0.108,0.053-0.266,0.101-0.477,0.143v0.312h2.939v-0.312
	c-0.189-0.046-0.342-0.12-0.453-0.217C284.975,91.169,284.881,91.033,284.803,90.857z M280.146,88.349l1.455-4.116l1.213,4.116
	H280.146z M290.369,87.61c-0.301-0.236-0.725-0.489-1.27-0.76c-0.453-0.224-0.791-0.424-1.021-0.602
	c-0.233-0.181-0.401-0.374-0.506-0.581c-0.111-0.209-0.164-0.464-0.164-0.768c0-0.284,0.062-0.53,0.188-0.736
	c0.125-0.207,0.301-0.358,0.521-0.463c0.221-0.099,0.467-0.152,0.744-0.152c0.316,0,0.576,0.039,0.775,0.123
	c0.201,0.084,0.375,0.229,0.522,0.438c0.147,0.207,0.272,0.499,0.371,0.874h0.631V83.26c-0.463-0.12-0.849-0.196-1.157-0.229
	c-0.305-0.035-0.625-0.053-0.947-0.053c-0.555,0-1.05,0.097-1.482,0.287c-0.428,0.188-0.755,0.459-0.98,0.812
	c-0.225,0.349-0.334,0.76-0.334,1.239c0,0.328,0.07,0.631,0.215,0.905c0.14,0.278,0.356,0.532,0.646,0.771s0.685,0.48,1.183,0.725
	c0.512,0.258,0.896,0.481,1.146,0.674c0.252,0.188,0.436,0.392,0.543,0.609c0.107,0.219,0.168,0.489,0.168,0.807
	c0,0.498-0.131,0.876-0.396,1.137c-0.268,0.261-0.648,0.39-1.146,0.39c-0.366,0-0.66-0.05-0.889-0.153
	c-0.23-0.103-0.416-0.264-0.562-0.48c-0.145-0.219-0.258-0.514-0.344-0.889l-0.006,0.005h-0.639v1.75
	c0.873,0.226,1.646,0.338,2.312,0.338c0.414,0,0.793-0.044,1.142-0.13c0.348-0.088,0.648-0.231,0.895-0.422
	c0.248-0.193,0.443-0.445,0.586-0.753c0.141-0.312,0.209-0.691,0.209-1.137c0-0.4-0.082-0.75-0.25-1.049
	C290.9,88.11,290.668,87.842,290.369,87.61z M292.214,85.312h0.634c0.08-0.344,0.168-0.622,0.26-0.849
	c0.092-0.224,0.193-0.397,0.305-0.518c0.107-0.121,0.229-0.2,0.357-0.239c0.129-0.038,0.295-0.058,0.496-0.058h0.803v6.536
	c0,0.255-0.01,0.445-0.031,0.58c-0.028,0.129-0.059,0.234-0.1,0.312c-0.039,0.077-0.09,0.137-0.152,0.188
	c-0.059,0.05-0.139,0.091-0.236,0.126c-0.1,0.034-0.213,0.065-0.34,0.097V91.8h2.918v-0.311c-0.209-0.046-0.361-0.095-0.459-0.146
	c-0.097-0.049-0.173-0.114-0.232-0.201c-0.059-0.085-0.104-0.205-0.127-0.354c-0.028-0.151-0.043-0.349-0.043-0.599v-6.536h0.812
	c0.23,0,0.406,0.02,0.523,0.068c0.116,0.048,0.226,0.125,0.328,0.235c0.104,0.109,0.198,0.271,0.291,0.483
	c0.088,0.213,0.182,0.502,0.276,0.868h0.625v-2.225h-6.906L292.214,85.312z M306.808,90.937c-0.116-0.161-0.262-0.394-0.428-0.701
	l-0.576-1.047c-0.22-0.418-0.425-0.729-0.61-0.923c-0.188-0.198-0.408-0.352-0.666-0.455v-0.055c0.638-0.229,1.123-0.551,1.44-0.958
	c0.32-0.406,0.482-0.9,0.482-1.484c0-0.765-0.246-1.327-0.74-1.688c-0.494-0.358-1.238-0.542-2.234-0.542h-3.155v0.312
	c0.192,0.052,0.332,0.103,0.414,0.147s0.142,0.107,0.19,0.183c0.046,0.073,0.084,0.176,0.105,0.312
	c0.019,0.134,0.032,0.349,0.032,0.643v5.521c0,0.313-0.018,0.549-0.04,0.7c-0.032,0.155-0.091,0.27-0.181,0.354
	c-0.089,0.083-0.263,0.16-0.526,0.229v0.312h2.69v-0.312c-0.192-0.055-0.334-0.105-0.414-0.15c-0.082-0.046-0.142-0.103-0.188-0.173
	c-0.044-0.071-0.082-0.173-0.105-0.312c-0.019-0.141-0.035-0.359-0.035-0.666v-2.165h0.697c0.207,0,0.365,0.011,0.469,0.031
	c0.105,0.026,0.201,0.069,0.293,0.132c0.097,0.057,0.196,0.169,0.304,0.319c0.106,0.153,0.247,0.395,0.418,0.715l0.562,1.064
	c0.144,0.269,0.283,0.532,0.428,0.791c0.147,0.26,0.302,0.502,0.459,0.729h1.771v-0.312c-0.205-0.035-0.369-0.096-0.492-0.18
	C307.048,91.221,306.927,91.099,306.808,90.937z M303.884,87.38c-0.226,0.057-0.526,0.081-0.896,0.081h-0.726v-3.792
	c0.238-0.016,0.55-0.023,0.937-0.022c0.475,0,0.855,0.067,1.135,0.21c0.281,0.138,0.49,0.342,0.629,0.61
	c0.139,0.271,0.207,0.605,0.207,1.011c0,0.385-0.057,0.712-0.174,0.979c-0.117,0.268-0.278,0.476-0.469,0.621
	C304.327,87.229,304.114,87.328,303.884,87.38z M312.743,83.398c0.26,0.065,0.43,0.141,0.514,0.21
	c0.082,0.074,0.146,0.175,0.183,0.312c0.032,0.14,0.053,0.393,0.053,0.763v3.986c0,0.522-0.025,0.94-0.08,1.251
	c-0.054,0.31-0.162,0.572-0.312,0.785c-0.147,0.212-0.335,0.374-0.562,0.479c-0.222,0.102-0.486,0.153-0.783,0.153
	c-0.329,0-0.594-0.037-0.811-0.104c-0.219-0.07-0.406-0.188-0.564-0.34c-0.156-0.154-0.279-0.373-0.365-0.654
	c-0.088-0.279-0.131-0.627-0.131-1.039v-4.52c0-0.352,0.021-0.6,0.051-0.747c0.035-0.148,0.098-0.263,0.191-0.335
	c0.094-0.073,0.26-0.141,0.498-0.201v-0.312h-2.682v0.312c0.209,0.052,0.352,0.104,0.426,0.153c0.078,0.052,0.137,0.112,0.178,0.179
	c0.041,0.065,0.073,0.161,0.094,0.275c0.021,0.116,0.031,0.344,0.031,0.676v4.198c0,0.544,0.053,1,0.16,1.355
	c0.11,0.356,0.282,0.665,0.52,0.926c0.24,0.259,0.55,0.451,0.912,0.563c0.369,0.113,0.811,0.173,1.326,0.173
	c0.421,0,0.795-0.045,1.109-0.134c0.316-0.094,0.582-0.214,0.805-0.366c0.221-0.155,0.409-0.344,0.555-0.565
	c0.162-0.247,0.283-0.532,0.363-0.85c0.086-0.336,0.129-0.735,0.129-1.199l-0.008,0.003v-4.104c0-0.349,0.022-0.596,0.051-0.741
	c0.035-0.145,0.098-0.255,0.189-0.332c0.092-0.075,0.262-0.148,0.508-0.21v-0.312h-2.547V83.398z M320.292,82.972
	c-0.773,0-1.441,0.188-1.998,0.562c-0.557,0.375-0.979,0.902-1.266,1.59c-0.288,0.688-0.435,1.484-0.435,2.396
	c0,1.45,0.275,2.542,0.828,3.271c0.555,0.733,1.371,1.1,2.451,1.1c0.502,0,0.963-0.025,1.383-0.079
	c0.417-0.052,0.831-0.135,1.229-0.239v-1.825h-0.632c-0.139,0.421-0.281,0.741-0.434,0.957c-0.152,0.218-0.338,0.376-0.559,0.479
	c-0.221,0.097-0.503,0.146-0.855,0.146c-0.459,0-0.846-0.146-1.162-0.45c-0.314-0.3-0.553-0.741-0.715-1.334
	c-0.162-0.59-0.242-1.302-0.242-2.135c0-0.829,0.101-1.537,0.293-2.122c0.2-0.583,0.47-1.02,0.812-1.312
	c0.344-0.292,0.731-0.438,1.17-0.438c0.295,0,0.547,0.047,0.754,0.143c0.209,0.094,0.392,0.25,0.551,0.47s0.289,0.515,0.394,0.885
	h0.631v-1.769c-0.422-0.111-0.795-0.187-1.126-0.234C321.036,82.993,320.679,82.972,320.292,82.972z M323.612,83.086h-0.003v2.227
	h0.633c0.08-0.344,0.168-0.622,0.26-0.849c0.09-0.224,0.196-0.397,0.303-0.518c0.109-0.121,0.23-0.2,0.361-0.239
	c0.129-0.038,0.293-0.058,0.494-0.058h0.803v6.536c0,0.255-0.012,0.445-0.035,0.58c-0.021,0.129-0.055,0.234-0.096,0.312
	s-0.09,0.137-0.152,0.188c-0.058,0.05-0.138,0.091-0.235,0.126c-0.103,0.034-0.213,0.065-0.341,0.097V91.8h2.919v-0.311
	c-0.21-0.046-0.363-0.095-0.464-0.146c-0.094-0.049-0.172-0.114-0.229-0.201c-0.059-0.085-0.104-0.204-0.129-0.354
	c-0.027-0.151-0.041-0.349-0.041-0.599v-6.536h0.811c0.234,0,0.41,0.02,0.525,0.068c0.119,0.048,0.226,0.125,0.33,0.235
	c0.102,0.109,0.199,0.271,0.291,0.483c0.087,0.213,0.179,0.502,0.272,0.868h0.627v-2.225h-6.903L323.612,83.086z M336.319,83.398
	c0.258,0.065,0.43,0.141,0.514,0.21c0.082,0.074,0.146,0.175,0.178,0.312c0.037,0.14,0.058,0.393,0.058,0.763v3.986
	c0,0.522-0.027,0.94-0.082,1.251c-0.059,0.31-0.162,0.572-0.312,0.785c-0.147,0.212-0.335,0.374-0.562,0.479
	c-0.227,0.102-0.486,0.153-0.785,0.153c-0.326,0-0.593-0.037-0.812-0.104c-0.218-0.07-0.403-0.188-0.562-0.34
	c-0.156-0.154-0.279-0.373-0.367-0.654c-0.088-0.279-0.131-0.627-0.131-1.039v-4.52c0-0.352,0.018-0.6,0.051-0.747
	c0.035-0.148,0.098-0.263,0.193-0.335c0.092-0.073,0.258-0.141,0.498-0.201v-0.312h-2.687v0.312
	c0.209,0.052,0.354,0.104,0.431,0.153c0.073,0.052,0.137,0.112,0.176,0.179c0.041,0.065,0.074,0.161,0.094,0.275
	c0.021,0.116,0.033,0.344,0.033,0.676v4.198c0,0.544,0.051,1.001,0.158,1.355c0.107,0.356,0.279,0.667,0.52,0.926
	s0.545,0.451,0.914,0.563c0.367,0.113,0.804,0.173,1.324,0.173c0.423,0,0.795-0.045,1.106-0.134
	c0.319-0.094,0.582-0.214,0.808-0.366c0.221-0.155,0.409-0.344,0.557-0.565c0.16-0.247,0.281-0.532,0.361-0.85
	c0.086-0.336,0.129-0.735,0.129-1.199l-0.006,0.003v-4.104c0-0.349,0.02-0.596,0.053-0.741c0.036-0.145,0.099-0.255,0.188-0.332
	c0.092-0.075,0.262-0.148,0.508-0.21v-0.312h-2.545V83.398z M346.675,90.937c-0.119-0.161-0.264-0.394-0.428-0.701l-0.574-1.047
	c-0.222-0.418-0.427-0.729-0.615-0.923c-0.186-0.198-0.405-0.352-0.668-0.455v-0.055c0.641-0.229,1.123-0.551,1.445-0.958
	c0.322-0.406,0.482-0.9,0.482-1.484c0-0.765-0.246-1.327-0.74-1.688c-0.494-0.358-1.238-0.542-2.234-0.542h-3.16v0.312
	c0.197,0.052,0.336,0.103,0.414,0.147c0.082,0.045,0.146,0.107,0.195,0.183c0.047,0.073,0.083,0.176,0.104,0.312
	c0.021,0.134,0.031,0.349,0.031,0.643v5.521c0,0.313-0.014,0.549-0.041,0.7c-0.027,0.155-0.086,0.27-0.176,0.354
	c-0.09,0.083-0.261,0.16-0.531,0.229v0.312h2.695v-0.312c-0.195-0.055-0.334-0.105-0.416-0.15c-0.08-0.046-0.138-0.103-0.191-0.173
	c-0.045-0.071-0.083-0.173-0.104-0.312c-0.023-0.141-0.035-0.359-0.035-0.666v-2.165h0.701c0.207,0,0.365,0.011,0.469,0.031
	c0.105,0.026,0.203,0.069,0.293,0.132c0.092,0.057,0.194,0.169,0.301,0.319c0.107,0.153,0.246,0.395,0.418,0.715l0.562,1.064
	c0.141,0.269,0.282,0.532,0.428,0.791c0.147,0.26,0.297,0.502,0.459,0.729h1.771v-0.312c-0.205-0.035-0.369-0.096-0.49-0.18
	C346.915,91.221,346.794,91.099,346.675,90.937z M343.749,87.38c-0.23,0.057-0.529,0.081-0.898,0.081h-0.723v-3.792
	c0.239-0.016,0.549-0.023,0.932-0.022c0.481,0,0.858,0.067,1.142,0.21c0.277,0.138,0.486,0.342,0.627,0.61
	c0.139,0.271,0.207,0.605,0.207,1.011c0,0.385-0.062,0.712-0.174,0.979c-0.119,0.268-0.278,0.476-0.474,0.621
	C344.192,87.229,343.978,87.328,343.749,87.38z M353.702,89.556c-0.086,0.288-0.152,0.509-0.201,0.657
	c-0.049,0.154-0.114,0.3-0.182,0.438c-0.072,0.143-0.156,0.255-0.25,0.343c-0.097,0.087-0.205,0.152-0.334,0.188
	c-0.131,0.034-0.304,0.054-0.513,0.054h-1.979v-3.682h1.365c0.196,0,0.347,0.024,0.446,0.079c0.104,0.054,0.19,0.149,0.258,0.278
	c0.072,0.13,0.139,0.321,0.197,0.577h0.604v-2.451h-0.604c-0.058,0.275-0.131,0.476-0.199,0.603
	c-0.072,0.126-0.16,0.217-0.266,0.271c-0.104,0.054-0.25,0.08-0.438,0.08h-1.365v-3.345h2.016c0.168,0,0.313,0.011,0.428,0.034
	c0.123,0.024,0.225,0.068,0.312,0.131c0.088,0.065,0.168,0.15,0.24,0.255c0.069,0.105,0.143,0.239,0.211,0.396
	c0.063,0.157,0.131,0.339,0.192,0.548h0.625v-1.928L348.3,83.08v0.312c0.197,0.052,0.336,0.103,0.416,0.147s0.145,0.107,0.195,0.183
	c0.047,0.073,0.084,0.176,0.104,0.312c0.021,0.134,0.031,0.348,0.031,0.643v5.521c0,0.312-0.014,0.549-0.039,0.7
	c-0.03,0.155-0.088,0.27-0.176,0.354c-0.092,0.083-0.263,0.16-0.531,0.229v0.312h5.914l0.119-2.236H353.702z M183.098,61.977
	c1.928-0.406,3.157-2.291,2.758-4.219c-0.373-1.783-2.022-2.956-3.794-2.801l-5.046-12.042c0.25-0.192,0.479-0.403,0.688-0.637
	l6.719,3.513c-0.079,0.439-0.082,0.899,0.016,1.363c0.404,1.927,2.291,3.16,4.217,2.758c1.926-0.406,3.158-2.291,2.758-4.218
	c-0.405-1.925-2.291-3.159-4.219-2.756c-0.749,0.157-1.389,0.543-1.873,1.064l-6.616-3.459c0.224-0.668,0.303-1.387,0.221-2.124
	l6.918-2.934c0.813,1.012,2.141,1.551,3.5,1.267c1.925-0.403,3.158-2.291,2.755-4.216c-0.402-1.926-2.289-3.16-4.216-2.756
	c-1.805,0.379-2.984,2.059-2.796,3.854l-6.78,2.875c-0.275-0.482-0.618-0.91-1.026-1.269l6.44-10.557
	c0.521,0.139,1.077,0.176,1.642,0.058c1.926-0.405,3.158-2.291,2.756-4.217c-0.403-1.926-2.289-3.159-4.217-2.756
	c-1.926,0.403-3.16,2.29-2.756,4.216c0.135,0.646,0.447,1.205,0.862,1.659l-6.468,10.605c-0.805-0.265-1.68-0.348-2.568-0.163
	c-1.534,0.322-2.734,1.327-3.396,2.621l-5.993-0.205c-0.02-0.113-0.03-0.225-0.053-0.337c-0.829-3.956-3.938-6.847-7.667-7.59
	l-0.057-6.13c1.94-0.871,3.118-2.91,2.889-5.067l12.64-5.523c0.823,0.838,2.037,1.258,3.272,1.001
	c1.925-0.404,3.16-2.29,2.756-4.216c-0.403-1.926-2.291-3.16-4.216-2.759c-1.92,0.405-3.154,2.281-2.759,4.203l-12.305,5.376
	c-0.219-0.388-0.474-0.749-0.781-1.059l4.457-6.573c0.559,0.173,1.164,0.227,1.777,0.1c1.926-0.406,3.159-2.29,2.756-4.219
	c-0.402-1.926-2.29-3.158-4.216-2.756c-1.926,0.404-3.16,2.291-2.757,4.216c0.125,0.598,0.405,1.117,0.772,1.553l-4.449,6.562
	c-0.807-0.33-1.709-0.43-2.624-0.291l-2.16-6.49c1.156-0.788,1.786-2.218,1.482-3.672c-0.403-1.926-2.291-3.16-4.217-2.756
	c-1.925,0.403-3.16,2.29-2.757,4.215c0.359,1.713,1.895,2.872,3.586,2.823l2.186,6.568c-0.433,0.269-0.812,0.597-1.139,0.976
	l-10.371-5.781c0.109-0.484,0.127-0.995,0.019-1.513c-0.402-1.926-2.291-3.16-4.216-2.758c-1.926,0.406-3.161,2.291-2.758,4.218
	c0.405,1.925,2.292,3.158,4.218,2.756c0.695-0.146,1.296-0.49,1.766-0.954l10.369,5.78c-0.251,0.792-0.33,1.649-0.148,2.519
	c0.347,1.654,1.479,2.937,2.923,3.556l0.057,6.14c-5.239,1.142-8.587,6.299-7.485,11.56c0.086,0.41,0.204,0.803,0.337,1.189
	l-5.755,3.442c-1.093-0.775-2.484-1.122-3.899-0.826c-0.004,0.001-0.007,0.002-0.011,0.003l-8.328-21.866
	c0.939-0.819,1.432-2.097,1.158-3.405c-0.404-1.926-2.291-3.159-4.217-2.756c-1.926,0.406-3.16,2.29-2.757,4.219
	c0.388,1.849,2.147,3.042,3.993,2.779l8.314,21.83c-0.009,0.007-0.017,0.016-0.026,0.022l-10.929-11.296
	c0.477-0.755,0.676-1.686,0.479-2.629c-0.403-1.927-2.29-3.159-4.216-2.759c-1.926,0.406-3.161,2.29-2.757,4.219
	c0.404,1.925,2.291,3.156,4.217,2.756c0.274-0.058,0.529-0.152,0.772-0.265l11.077,11.45c-0.087,0.144-0.163,0.295-0.235,0.448
	l-8.318-1.423c-0.013-0.115-0.012-0.229-0.037-0.346c-0.403-1.925-2.29-3.158-4.216-2.756c-1.926,0.407-3.16,2.291-2.757,4.22
	c0.404,1.925,2.292,3.155,4.218,2.755c1.108-0.232,1.974-0.965,2.443-1.905l8.186,1.4c-0.015,0.398,0.002,0.802,0.087,1.209
	c0.101,0.481,0.288,0.918,0.51,1.329l-4.457,4.004c-0.695-0.35-1.501-0.488-2.322-0.316c-1.926,0.404-3.16,2.289-2.757,4.216
	c0.404,1.925,2.291,3.16,4.217,2.757c1.926-0.404,3.159-2.292,2.757-4.217c-0.082-0.39-0.237-0.74-0.428-1.065l4.277-3.843
	c0.722,0.571,1.589,0.937,2.525,1.043l1.328,12.209c-1.615,0.61-2.598,2.306-2.234,4.052c0.405,1.925,2.292,3.157,4.218,2.756
	c1.926-0.404,3.159-2.291,2.757-4.216c-0.298-1.424-1.409-2.464-2.745-2.75l-1.33-12.233c0.268-0.08,0.526-0.175,0.771-0.296
	l11.844,17.573c-0.626,0.798-0.921,1.847-0.697,2.919c0.404,1.927,2.291,3.161,4.217,2.757c1.926-0.405,3.159-2.291,2.757-4.217
	c-0.403-1.926-2.291-3.16-4.217-2.756c-0.15,0.031-0.287,0.087-0.428,0.136L139.863,52.08c0.876-1.034,1.316-2.404,1.138-3.827
	l5.766-3.449c2.258,2.44,5.698,3.678,9.19,2.947c3.805-0.796,6.615-3.708,7.487-7.247l5.894,0.201
	c0.581,1.561,1.886,2.69,3.446,3.083l-1.56,20.831c-1.886,0.435-3.089,2.292-2.691,4.195c0.404,1.926,2.292,3.16,4.218,2.756
	s3.159-2.291,2.756-4.216c-0.263-1.258-1.161-2.208-2.286-2.612l1.563-20.867c0.077-0.013,0.153-0.008,0.23-0.024
	c0.069-0.014,0.129-0.045,0.196-0.062l4.984,11.893c-1.044,0.809-1.603,2.157-1.315,3.537
	C179.285,61.146,181.171,62.378,183.098,61.977z"/>
</svg>

================
File: inst/MetFamily/www/img/Leibniz__Logo_EN_Negative_100mm.svg
================
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:cc="http://creativecommons.org/ns#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   id="svg47"
   version="1.2"
   viewBox="0 0 327.03 268.16"
   height="268.16pt"
   width="327.03pt">
  <metadata
     id="metadata53">
    <rdf:RDF>
      <cc:Work
         rdf:about="">
        <dc:format>image/svg+xml</dc:format>
        <dc:type
           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
        <dc:title></dc:title>
      </cc:Work>
    </rdf:RDF>
  </metadata>
  <defs
     id="defs51" />
  <g
     id="surface1119">
    <path
       id="path2"
       d="M 24.417969 200.476562 L 24.417969 178.964844 L 27.257812 178.964844 L 27.257812 197.921875 L 36.667969 197.921875 L 36.667969 200.476562 L 24.417969 200.476562 "
       style=" stroke:none;fill-rule:nonzero;fill:rgb(100%,100%,100%);fill-opacity:1;" />
    <path
       id="path4"
       d="M 45.328125 187.160156 C 44.128906 187.160156 43.117188 187.550781 42.304688 188.328125 C 41.527344 189.066406 41.085938 189.984375 40.984375 191.082031 L 49.410156 191.082031 C 49.410156 189.996094 49.070312 189.089844 48.382812 188.355469 C 47.640625 187.558594 46.613281 187.160156 45.328125 187.160156 Z M 51.882812 193.046875 L 40.914062 193.046875 C 40.914062 194.828125 41.398438 196.199219 42.375 197.148438 C 43.234375 197.988281 44.34375 198.402344 45.699219 198.402344 C 47.242188 198.402344 48.53125 197.953125 49.570312 197.054688 L 50.703125 199 C 50.285156 199.421875 49.644531 199.777344 48.78125 200.082031 C 47.703125 200.476562 46.5 200.679688 45.171875 200.679688 C 43.261719 200.679688 41.636719 200.023438 40.300781 198.726562 C 38.816406 197.300781 38.070312 195.378906 38.070312 192.957031 C 38.070312 190.453125 38.832031 188.4375 40.355469 186.925781 C 41.722656 185.566406 43.335938 184.886719 45.207031 184.886719 C 47.371094 184.886719 49.070312 185.496094 50.308594 186.722656 C 51.492188 187.898438 52.09375 189.453125 52.09375 191.398438 C 52.09375 191.996094 52.019531 192.542969 51.882812 193.046875 "
       style=" stroke:none;fill-rule:nonzero;fill:rgb(100%,100%,100%);fill-opacity:1;" />
    <path
       id="path6"
       d="M 58.25 179.503906 C 58.714844 179.503906 59.113281 179.664062 59.4375 179.992188 C 59.769531 180.316406 59.925781 180.710938 59.925781 181.164062 C 59.925781 181.625 59.769531 182.023438 59.4375 182.351562 C 59.113281 182.675781 58.714844 182.84375 58.25 182.84375 C 57.800781 182.84375 57.40625 182.675781 57.078125 182.351562 C 56.753906 182.023438 56.589844 181.625 56.589844 181.164062 C 56.589844 180.695312 56.75 180.308594 57.070312 179.980469 C 57.394531 179.664062 57.785156 179.503906 58.25 179.503906 Z M 57.167969 200.476562 L 57.167969 187.527344 L 55.078125 187.527344 L 55.078125 185.253906 L 59.863281 185.253906 L 59.863281 200.476562 L 57.167969 200.476562 "
       style=" stroke:none;fill-rule:nonzero;fill:rgb(100%,100%,100%);fill-opacity:1;" />
    <path
       id="path8"
       d="M 67.808594 188.441406 L 67.808594 197.222656 C 67.808594 197.375 68.144531 197.625 68.820312 197.96875 C 69.492188 198.3125 70.003906 198.488281 70.355469 198.488281 C 72.191406 198.488281 73.511719 198.046875 74.304688 197.164062 C 75.101562 196.285156 75.496094 194.804688 75.496094 192.730469 C 75.496094 191.003906 75.035156 189.660156 74.105469 188.695312 C 73.175781 187.730469 71.925781 187.242188 70.355469 187.242188 C 70.023438 187.242188 69.5625 187.390625 68.96875 187.675781 C 68.375 187.953125 67.988281 188.207031 67.808594 188.441406 Z M 67.414062 199.386719 L 66.460938 200.761719 L 65.109375 200.761719 L 65.109375 178.875 L 67.808594 178.875 L 67.808594 186.382812 C 68.066406 186.027344 68.546875 185.703125 69.25 185.410156 C 69.960938 185.121094 70.652344 184.96875 71.335938 184.96875 C 73.417969 184.96875 75.105469 185.691406 76.398438 187.128906 C 77.691406 188.574219 78.339844 190.394531 78.339844 192.589844 C 78.339844 195.128906 77.691406 197.128906 76.390625 198.578125 C 75.09375 200.035156 73.335938 200.761719 71.121094 200.761719 C 70.402344 200.761719 69.699219 200.628906 68.996094 200.359375 C 68.300781 200.085938 67.773438 199.765625 67.414062 199.386719 "
       style=" stroke:none;fill-rule:nonzero;fill:rgb(100%,100%,100%);fill-opacity:1;" />
    <path
       id="path10"
       d="M 91.367188 200.476562 L 91.367188 191.625 C 91.367188 190.003906 91.121094 188.867188 90.636719 188.222656 C 90.148438 187.566406 89.328125 187.242188 88.183594 187.242188 C 87.570312 187.242188 86.921875 187.429688 86.253906 187.800781 C 85.578125 188.167969 85.0625 188.625 84.707031 189.164062 L 84.707031 200.476562 L 82.003906 200.476562 L 82.003906 185.253906 L 83.847656 185.253906 L 84.707031 187.21875 C 85.59375 185.71875 87.046875 184.96875 89.066406 184.96875 C 92.398438 184.96875 94.066406 186.996094 94.066406 191.058594 L 94.066406 200.476562 L 91.367188 200.476562 "
       style=" stroke:none;fill-rule:nonzero;fill:rgb(100%,100%,100%);fill-opacity:1;" />
    <path
       id="path12"
       d="M 100.757812 179.503906 C 101.222656 179.503906 101.617188 179.664062 101.945312 179.992188 C 102.273438 180.316406 102.433594 180.710938 102.433594 181.164062 C 102.433594 181.625 102.273438 182.023438 101.945312 182.351562 C 101.617188 182.675781 101.222656 182.84375 100.757812 182.84375 C 100.300781 182.84375 99.910156 182.675781 99.582031 182.351562 C 99.257812 182.023438 99.09375 181.625 99.09375 181.164062 C 99.09375 180.695312 99.253906 180.308594 99.578125 179.980469 C 99.898438 179.664062 100.292969 179.503906 100.757812 179.503906 Z M 99.671875 200.476562 L 99.671875 187.527344 L 97.582031 187.527344 L 97.582031 185.253906 L 102.371094 185.253906 L 102.371094 200.476562 L 99.671875 200.476562 "
       style=" stroke:none;fill-rule:nonzero;fill:rgb(100%,100%,100%);fill-opacity:1;" />
    <path
       id="path14"
       d="M 111.117188 198.058594 L 119.558594 198.058594 L 119.558594 200.476562 L 106.882812 200.476562 L 106.882812 199.769531 L 115.535156 187.675781 L 107.027344 187.675781 L 107.027344 185.253906 L 119.476562 185.253906 L 119.476562 186.019531 L 111.117188 198.058594 "
       style=" stroke:none;fill-rule:nonzero;fill:rgb(100%,100%,100%);fill-opacity:1;" />
    <path
       id="path16"
       d="M 187.617188 120.546875 C 186.519531 122.335938 184.457031 118.277344 180.484375 123.425781 C 178.835938 125.585938 179.9375 128.15625 177.910156 130.464844 C 175.640625 133.027344 173.484375 135.085938 175.230469 127.890625 C 177.011719 120.578125 176.105469 123.628906 176.972656 120.488281 C 177.902344 117.019531 181.242188 105.003906 182.390625 102.492188 C 184.015625 98.9375 184.421875 97.273438 188.789062 90.792969 C 188.789062 90.792969 191.847656 86.925781 192.40625 86.359375 C 194.769531 83.941406 203.570312 79.738281 199.355469 95.710938 C 196.003906 108.398438 193.363281 111.316406 187.617188 120.546875 Z M 188.15625 138.910156 C 186.683594 144.585938 184.121094 153.609375 181.917969 156.40625 C 180.394531 158.347656 176.667969 163.941406 173.824219 154.253906 C 170.992188 144.546875 177.851562 136.253906 177.851562 136.253906 C 177.851562 136.253906 180.746094 132.398438 182.644531 132.398438 C 184.984375 132.402344 189.636719 133.253906 188.15625 138.910156 Z M 36.855469 136.855469 C 35.277344 137.511719 30.875 133.886719 31.050781 131.933594 C 31.363281 128.089844 35.394531 131.964844 40.035156 131.789062 C 44.730469 131.59375 38.515625 136.144531 36.855469 136.855469 Z M 108.621094 57.589844 C 113.269531 53.0625 116.785156 49.511719 119.824219 46.691406 C 134.070312 33.476562 133.726562 34.570312 135.742188 33.265625 C 139.511719 30.828125 148.128906 26.113281 150.746094 28.441406 C 153.644531 31.015625 152.425781 36.589844 147.902344 41.4375 C 143.246094 46.425781 129.855469 60.023438 118.09375 66.542969 C 110.160156 70.9375 78.488281 86.941406 108.621094 57.589844 Z M 230.726562 147.546875 C 232.15625 149.378906 235.734375 152.648438 244.457031 144.316406 C 253.195312 135.984375 248.753906 139.503906 253.707031 150.222656 C 258.664062 160.929688 261.609375 154.933594 261.878906 152.824219 C 262.535156 147.546875 260.753906 137.242188 259.578125 133.058594 C 258.589844 129.554688 252.464844 127.898438 250.054688 129.703125 C 247.773438 131.386719 241.761719 138.3125 237.714844 139.667969 C 233.667969 141.027344 236.828125 137.097656 235.714844 130.636719 C 234.601562 124.179688 232.160156 121.28125 229.617188 122.410156 C 227.910156 123.171875 224.285156 126.851562 222.40625 126.089844 C 218.410156 124.496094 212.960938 119.804688 201.984375 125.402344 C 182.101562 135.542969 196.851562 114.824219 196.851562 114.824219 C 196.851562 114.824219 211.53125 91.828125 203.800781 79.976562 C 196.253906 68.410156 182.828125 88.839844 179.507812 95.160156 C 175.074219 103.578125 171.617188 115.070312 167.820312 132.402344 C 165.613281 142.472656 153.398438 146.238281 150.324219 142.34375 C 147.015625 138.144531 147.664062 121.359375 136.164062 128.589844 C 124.664062 135.8125 125.019531 149.917969 117.800781 134.054688 C 110.589844 118.191406 103.421875 128.5625 102.496094 130.253906 C 101.214844 132.628906 101.972656 137.777344 100.019531 138.925781 C 97.820312 140.222656 94.972656 135.746094 93.277344 135.144531 C 91.464844 134.519531 79.890625 144.257812 74.71875 154.414062 C 67.265625 169.054688 52.835938 137.925781 54.007812 135.71875 C 55.019531 133.796875 83.042969 94.71875 86.410156 89.015625 C 89.992188 82.960938 92.585938 80.992188 94.765625 80.664062 C 96.933594 80.339844 123.589844 73.820312 144.066406 53.242188 C 161.425781 35.800781 159.738281 30.34375 156.171875 25.570312 C 155.105469 24.160156 153.523438 23.101562 151.433594 22.390625 C 141.035156 18.878906 117.035156 41.175781 114.828125 43.292969 C 111.253906 46.738281 90.070312 70.414062 88.527344 73.601562 C 86.980469 76.792969 49.96875 75.855469 49.96875 75.855469 C 45.699219 78.015625 50.496094 79.695312 50.496094 79.695312 C 50.496094 79.695312 67.207031 81.925781 77.59375 81.386719 C 86.585938 80.917969 81.359375 86.828125 80.019531 88.546875 C 72.292969 98.449219 58.882812 119.601562 53.96875 125.425781 C 49.269531 130.996094 40.445312 125.714844 37.960938 125.226562 C 35.414062 124.726562 21.429688 122.816406 24.742188 134.488281 C 28.066406 146.164062 38.644531 140.792969 43.214844 141.835938 C 44.609375 142.148438 47.84375 143.664062 48.632812 145.441406 C 50.394531 149.351562 52.65625 153.722656 54.570312 156.695312 C 57.757812 161.636719 71.46875 174.839844 80.820312 156.914062 C 91.097656 137.207031 98.300781 144.496094 99.03125 155.082031 C 99.773438 165.660156 103.121094 161.652344 106.949219 159.898438 C 110.765625 158.152344 107.378906 150.855469 107.664062 141.246094 C 107.9375 131.636719 116.632812 146.039062 116.835938 149.886719 C 116.984375 152.699219 122.070312 153.105469 127.316406 150.902344 C 132.558594 148.699219 127.382812 144.621094 134.535156 137.863281 C 141.714844 131.117188 143.035156 146.558594 144.703125 150.296875 C 146.105469 153.417969 153.085938 158.957031 157.265625 150.941406 C 160.941406 143.886719 168.410156 146.226562 168.515625 156.363281 C 168.605469 164.8125 174.746094 166.550781 177.078125 166.628906 C 177.914062 166.660156 178.875 166.570312 180.195312 166.03125 C 184.824219 164.132812 192.15625 153.949219 192.0625 145.007812 C 191.902344 129.835938 216.570312 127.394531 214.808594 132.542969 C 213.53125 136.246094 208.066406 147.179688 214.742188 146.933594 C 221.414062 146.6875 218.574219 140.976562 224.71875 134.402344 C 230.859375 127.835938 228.324219 144.472656 230.726562 147.546875 "
       style=" stroke:none;fill-rule:nonzero;fill:rgb(100%,100%,100%);fill-opacity:1;" />
    <path
       id="path18"
       d="M 148.878906 90.371094 C 148.148438 99.738281 153.914062 96.617188 153.914062 96.617188 C 164.636719 90.929688 156 85.9375 156 85.9375 C 156 85.9375 149.640625 81.003906 148.878906 90.371094 "
       style=" stroke:none;fill-rule:nonzero;fill:rgb(100%,100%,100%);fill-opacity:1;" />
    <path
       id="path20"
       d="M 283.191406 198.058594 C 283.191406 198.058594 272.035156 221.433594 270.636719 223.585938 C 268.949219 226.195312 260.261719 238.5625 247.257812 240.445312 C 234.246094 242.335938 227.792969 237.238281 227.511719 230.789062 C 227.226562 224.636719 231.558594 220.46875 245.839844 213.539062 C 277.851562 198.007812 279.300781 197.128906 279.300781 197.128906 C 281.601562 196.214844 286.050781 193.226562 283.191406 198.058594 Z M 285.523438 141.019531 C 285.484375 141.171875 285.441406 141.300781 285.410156 141.394531 Z M 304.988281 177.335938 C 304.433594 175.886719 302.964844 174.027344 298.617188 179.371094 C 291.964844 187.554688 292.636719 182.613281 291.953125 177.300781 C 291.839844 176.402344 291.136719 172.152344 288.101562 170.539062 C 285.324219 169.070312 273.96875 165.308594 276.78125 163.085938 C 283.714844 157.613281 283.519531 158.023438 285.550781 155.734375 C 288.019531 152.957031 296.058594 142.65625 295.398438 132.367188 C 294.632812 120.398438 277.558594 121.773438 277.558594 121.773438 C 265.871094 123.570312 271.175781 133.785156 279.261719 132.523438 C 288.195312 131.125 286.089844 138.953125 285.523438 141.019531 C 285.515625 141.035156 284.582031 143.515625 282.683594 146.515625 C 280.148438 150.527344 276.316406 155.789062 273.957031 158.410156 C 272.421875 160.117188 263.488281 165.925781 269.933594 169.003906 C 280.640625 174.097656 288.96875 186.492188 283.519531 189.878906 C 279.710938 192.25 249.386719 206.289062 242.609375 209.285156 C 236.066406 212.1875 221.445312 217.464844 221.570312 231.578125 C 221.710938 246.785156 242.699219 246.667969 247.3125 245.859375 C 260.585938 243.546875 267.644531 236.25 272.636719 230.179688 C 276.898438 224.996094 286.949219 203.890625 288.117188 200.160156 C 289.105469 196.992188 293.054688 185.210938 298.699219 183.617188 C 305.027344 181.832031 305.785156 179.457031 304.988281 177.335938 "
       style=" stroke:none;fill-rule:nonzero;fill:rgb(100%,100%,100%);fill-opacity:1;" />
    <path
       id="path22"
       d="M 273.761719 94.992188 C 270.910156 93.882812 262.589844 98.3125 265.210938 105.441406 C 267.894531 112.714844 286.769531 100.089844 273.761719 94.992188 "
       style=" stroke:none;fill-rule:nonzero;fill:rgb(100%,100%,100%);fill-opacity:1;" />
    <path
       id="path24"
       d="M 31.179688 215.285156 L 27.695312 224.3125 L 34.375 224.3125 Z M 36.796875 231.546875 L 35.25 226.652344 L 26.878906 226.652344 L 25.222656 231.546875 L 21.785156 231.546875 L 30.589844 209.613281 L 32.066406 209.613281 L 40.207031 231.546875 L 36.796875 231.546875 "
       style=" stroke:none;fill-rule:nonzero;fill:rgb(100%,100%,100%);fill-opacity:1;" />
    <path
       id="path26"
       d="M 43.863281 230.632812 L 44.832031 228.058594 C 46.363281 229.050781 47.601562 229.542969 48.535156 229.542969 C 50.230469 229.542969 51.082031 228.839844 51.082031 227.429688 C 51.082031 226.417969 50.261719 225.550781 48.621094 224.828125 C 47.359375 224.253906 46.507812 223.824219 46.070312 223.527344 C 45.628906 223.230469 45.25 222.894531 44.925781 222.519531 C 44.601562 222.144531 44.359375 221.742188 44.203125 221.316406 C 44.042969 220.894531 43.964844 220.441406 43.964844 219.953125 C 43.964844 218.695312 44.425781 217.714844 45.351562 217.007812 C 46.28125 216.304688 47.488281 215.953125 48.984375 215.953125 C 50.109375 215.953125 51.535156 216.304688 53.25 217.007812 L 52.46875 219.523438 C 51.382812 218.667969 50.285156 218.238281 49.1875 218.238281 C 48.53125 218.238281 47.976562 218.390625 47.53125 218.695312 C 47.082031 219 46.855469 219.386719 46.855469 219.851562 C 46.855469 220.835938 47.421875 221.578125 48.546875 222.082031 L 50.519531 222.96875 C 51.722656 223.511719 52.597656 224.132812 53.148438 224.828125 C 53.699219 225.523438 53.972656 226.394531 53.972656 227.441406 C 53.972656 228.816406 53.488281 229.890625 52.511719 230.664062 C 51.539062 231.441406 50.191406 231.832031 48.460938 231.832031 C 46.832031 231.832031 45.300781 231.433594 43.863281 230.632812 "
       style=" stroke:none;fill-rule:nonzero;fill:rgb(100%,100%,100%);fill-opacity:1;" />
    <path
       id="path28"
       d="M 57.472656 230.632812 L 58.441406 228.058594 C 59.972656 229.050781 61.210938 229.542969 62.144531 229.542969 C 63.839844 229.542969 64.691406 228.839844 64.691406 227.429688 C 64.691406 226.417969 63.871094 225.550781 62.230469 224.828125 C 60.96875 224.253906 60.117188 223.824219 59.675781 223.527344 C 59.238281 223.230469 58.855469 222.894531 58.535156 222.519531 C 58.210938 222.144531 57.96875 221.742188 57.8125 221.316406 C 57.652344 220.894531 57.574219 220.441406 57.574219 219.953125 C 57.574219 218.695312 58.035156 217.714844 58.960938 217.007812 C 59.886719 216.304688 61.097656 215.953125 62.59375 215.953125 C 63.722656 215.953125 65.144531 216.304688 66.859375 217.007812 L 66.078125 219.523438 C 64.988281 218.667969 63.894531 218.238281 62.792969 218.238281 C 62.140625 218.238281 61.585938 218.390625 61.140625 218.695312 C 60.691406 219 60.46875 219.386719 60.46875 219.851562 C 60.46875 220.835938 61.03125 221.578125 62.160156 222.082031 L 64.125 222.96875 C 65.332031 223.511719 66.210938 224.132812 66.757812 224.828125 C 67.308594 225.523438 67.582031 226.394531 67.582031 227.441406 C 67.582031 228.816406 67.09375 229.890625 66.121094 230.664062 C 65.148438 231.441406 63.796875 231.832031 62.074219 231.832031 C 60.441406 231.832031 58.90625 231.433594 57.472656 230.632812 "
       style=" stroke:none;fill-rule:nonzero;fill:rgb(100%,100%,100%);fill-opacity:1;" />
    <path
       id="path30"
       d="M 73.921875 223.855469 C 73.921875 227.695312 75.296875 229.617188 78.042969 229.617188 C 79.328125 229.617188 80.335938 229.101562 81.0625 228.070312 C 81.789062 227.042969 82.152344 225.636719 82.152344 223.855469 C 82.152344 220.0625 80.785156 218.167969 78.042969 218.167969 C 76.792969 218.167969 75.789062 218.671875 75.042969 219.679688 C 74.296875 220.691406 73.921875 222.082031 73.921875 223.855469 Z M 71.03125 223.855469 C 71.03125 221.492188 71.671875 219.585938 72.960938 218.132812 C 74.246094 216.675781 75.945312 215.953125 78.042969 215.953125 C 80.265625 215.953125 81.984375 216.648438 83.210938 218.046875 C 84.433594 219.441406 85.046875 221.378906 85.046875 223.855469 C 85.046875 226.324219 84.417969 228.269531 83.164062 229.695312 C 81.914062 231.117188 80.207031 231.832031 78.042969 231.832031 C 75.835938 231.832031 74.113281 231.113281 72.882812 229.675781 C 71.648438 228.234375 71.03125 226.296875 71.03125 223.855469 "
       style=" stroke:none;fill-rule:nonzero;fill:rgb(100%,100%,100%);fill-opacity:1;" />
    <path
       id="path32"
       d="M 101.269531 217.480469 L 99.910156 219.394531 C 99.632812 219.117188 99.136719 218.859375 98.425781 218.609375 C 97.71875 218.363281 97.023438 218.238281 96.335938 218.238281 C 94.84375 218.238281 93.65625 218.753906 92.78125 219.789062 C 91.902344 220.824219 91.464844 222.238281 91.464844 224.039062 C 91.464844 225.832031 91.910156 227.199219 92.808594 228.136719 C 93.707031 229.074219 94.949219 229.542969 96.539062 229.542969 C 97.777344 229.542969 99.019531 229.074219 100.273438 228.128906 L 101.355469 230.417969 C 99.882812 231.359375 98.054688 231.832031 95.875 231.832031 C 93.765625 231.832031 92.019531 231.132812 90.640625 229.730469 C 89.261719 228.328125 88.570312 226.433594 88.570312 224.039062 C 88.570312 221.601562 89.285156 219.644531 90.71875 218.167969 C 92.152344 216.6875 94.109375 215.953125 96.597656 215.953125 C 97.398438 215.953125 98.265625 216.117188 99.203125 216.453125 C 100.140625 216.785156 100.828125 217.128906 101.269531 217.480469 "
       style=" stroke:none;fill-rule:nonzero;fill:rgb(100%,100%,100%);fill-opacity:1;" />
    <path
       id="path34"
       d="M 108.265625 210.449219 C 108.730469 210.449219 109.128906 210.613281 109.460938 210.941406 C 109.789062 211.269531 109.953125 211.664062 109.953125 212.121094 C 109.953125 212.585938 109.789062 212.984375 109.460938 213.3125 C 109.128906 213.644531 108.730469 213.808594 108.265625 213.808594 C 107.808594 213.808594 107.414062 213.644531 107.085938 213.3125 C 106.757812 212.984375 106.59375 212.585938 106.59375 212.121094 C 106.59375 211.65625 106.753906 211.257812 107.078125 210.933594 C 107.402344 210.609375 107.800781 210.449219 108.265625 210.449219 Z M 107.265625 231.546875 L 107.265625 218.523438 L 105.160156 218.523438 L 105.160156 216.238281 L 109.980469 216.238281 L 109.980469 231.546875 L 107.265625 231.546875 "
       style=" stroke:none;fill-rule:nonzero;fill:rgb(100%,100%,100%);fill-opacity:1;" />
    <path
       id="path36"
       d="M 124.164062 224.027344 C 123.308594 223.835938 122.707031 223.742188 122.363281 223.742188 C 120.988281 223.742188 119.871094 224.09375 119.003906 224.800781 C 118.136719 225.503906 117.703125 226.339844 117.703125 227.300781 C 117.703125 228.890625 118.640625 229.6875 120.519531 229.6875 C 121.890625 229.6875 123.105469 229.035156 124.164062 227.730469 Z M 124.421875 229.789062 C 123.335938 231.152344 121.671875 231.832031 119.433594 231.832031 C 118.230469 231.832031 117.191406 231.394531 116.308594 230.523438 C 115.429688 229.652344 114.988281 228.566406 114.988281 227.273438 C 114.988281 225.71875 115.664062 224.40625 117.023438 223.335938 C 118.382812 222.261719 120.113281 221.726562 122.21875 221.726562 C 122.792969 221.726562 123.441406 221.851562 124.164062 222.097656 C 124.164062 219.621094 123.058594 218.382812 120.847656 218.382812 C 119.148438 218.382812 117.84375 218.839844 116.933594 219.753906 L 115.789062 217.480469 C 116.304688 217.0625 117.015625 216.699219 117.925781 216.402344 C 118.835938 216.101562 119.703125 215.953125 120.53125 215.953125 C 122.753906 215.953125 124.367188 216.457031 125.371094 217.46875 C 126.378906 218.476562 126.878906 220.082031 126.878906 222.28125 L 126.878906 227.773438 C 126.878906 229.113281 127.28125 230.011719 128.078125 230.457031 L 128.078125 231.816406 C 126.976562 231.816406 126.148438 231.660156 125.601562 231.347656 C 125.054688 231.03125 124.660156 230.511719 124.421875 229.789062 "
       style=" stroke:none;fill-rule:nonzero;fill:rgb(100%,100%,100%);fill-opacity:1;" />
    <path
       id="path38"
       d="M 132.78125 218.382812 L 131.011719 218.382812 L 131.011719 216.238281 L 132.78125 216.238281 L 132.78125 213.035156 L 135.5 211.992188 L 135.5 216.238281 L 139.699219 216.238281 L 139.699219 218.382812 L 135.5 218.382812 L 135.5 225.984375 C 135.5 227.273438 135.714844 228.1875 136.148438 228.730469 C 136.582031 229.273438 137.28125 229.542969 138.242188 229.542969 C 138.9375 229.542969 139.65625 229.367188 140.402344 229.015625 L 140.800781 231.402344 C 139.679688 231.6875 138.441406 231.832031 137.101562 231.832031 C 135.890625 231.832031 134.867188 231.382812 134.03125 230.480469 C 133.199219 229.578125 132.78125 228.441406 132.78125 227.070312 L 132.78125 218.382812 "
       style=" stroke:none;fill-rule:nonzero;fill:rgb(100%,100%,100%);fill-opacity:1;" />
    <path
       id="path40"
       d="M 147.375 210.449219 C 147.84375 210.449219 148.242188 210.613281 148.570312 210.941406 C 148.898438 211.269531 149.0625 211.664062 149.0625 212.121094 C 149.0625 212.585938 148.898438 212.984375 148.570312 213.3125 C 148.242188 213.644531 147.84375 213.808594 147.375 213.808594 C 146.917969 213.808594 146.527344 213.644531 146.195312 213.3125 C 145.867188 212.984375 145.703125 212.585938 145.703125 212.121094 C 145.703125 211.65625 145.863281 211.257812 146.1875 210.933594 C 146.515625 210.609375 146.910156 210.449219 147.375 210.449219 Z M 146.347656 231.546875 L 146.347656 218.523438 L 144.246094 218.523438 L 144.246094 216.238281 L 149.0625 216.238281 L 149.0625 231.546875 L 146.347656 231.546875 "
       style=" stroke:none;fill-rule:nonzero;fill:rgb(100%,100%,100%);fill-opacity:1;" />
    <path
       id="path42"
       d="M 156.652344 223.855469 C 156.652344 227.695312 158.054688 229.617188 160.863281 229.617188 C 162.175781 229.617188 163.203125 229.101562 163.945312 228.070312 C 164.6875 227.042969 165.0625 225.636719 165.0625 223.855469 C 165.0625 220.0625 163.660156 218.167969 160.863281 218.167969 C 159.585938 218.167969 158.5625 218.671875 157.800781 219.679688 C 157.035156 220.691406 156.652344 222.082031 156.652344 223.855469 Z M 153.695312 223.855469 C 153.695312 221.492188 154.355469 219.585938 155.671875 218.132812 C 156.984375 216.675781 158.714844 215.953125 160.863281 215.953125 C 163.132812 215.953125 164.890625 216.648438 166.140625 218.046875 C 167.390625 219.441406 168.015625 221.378906 168.015625 223.855469 C 168.015625 226.324219 167.378906 228.269531 166.097656 229.695312 C 164.816406 231.117188 163.070312 231.832031 160.863281 231.832031 C 158.605469 231.832031 156.847656 231.113281 155.589844 229.675781 C 154.328125 228.234375 153.695312 226.296875 153.695312 223.855469 "
       style=" stroke:none;fill-rule:nonzero;fill:rgb(100%,100%,100%);fill-opacity:1;" />
    <path
       id="path44"
       d="M 181.308594 231.546875 L 181.308594 222.640625 C 181.308594 221.011719 181.0625 219.871094 180.570312 219.214844 C 180.078125 218.566406 179.257812 218.238281 178.105469 218.238281 C 177.484375 218.238281 176.839844 218.421875 176.160156 218.796875 C 175.484375 219.167969 174.964844 219.625 174.605469 220.167969 L 174.605469 231.546875 L 171.886719 231.546875 L 171.886719 216.238281 L 173.746094 216.238281 L 174.605469 218.210938 C 175.496094 216.703125 176.960938 215.953125 178.992188 215.953125 C 182.347656 215.953125 184.023438 217.992188 184.023438 222.066406 L 184.023438 231.546875 L 181.308594 231.546875 "
       style=" stroke:none;fill-rule:nonzero;fill:rgb(100%,100%,100%);fill-opacity:1;" />
  </g>
</svg>

================
File: inst/MetFamily/www/ipbfooter.html
================
<!-- Start Second Navigation & Copyright Footer -->
    <div id="second-wrap">
      <div class="wrapper">
        <nav id="second-nav">
          <ul>
            <li>
	      <svg class="octicon octicon-mark-github" style="vertical-align: text-bottom;" height="16" viewBox="0 0 16 16" version="1.1" width="32" aria-hidden="true"><path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path></svg>
              <a style="margin-left: -6px;" href="https://github.com/ipb-halle/MetFamily/">MetFamily at GitHub</a>
            </li>
            <li style="
              margin-left: 10px;
              margin-right: 10px;
              ">|</li>
            <li>
              <i class="fab fa-youtube" style="
                    font-size: 18px;
                    vertical-align: text-bottom;
                "></i>
              <a href="https://youtu.be/VOJvwh5RhT4">MetFamily tutorial (YouTube)</a>
            </li>
          </ul>
        </nav>
        <footer id="footer">
          <p>
            &copy; 2020 Leibniz Institute of Plant Biochemistry
          </p>
        </footer>
      </div>
    </div>
    <!-- End Second Navigation & Copyright Footer -->
    
    <!-- Start Sitemap -->
    
    <div id="sitemap-wrap">
      <div id="sitemap-header">
        <div class="wrapper">
          <ul id="left-nav">
            <li><a class href="#" rel="nofollow"><img style="height:85px" src="img/2020_Logo_schrift_weiss_Trans_EN.png" alt="IPB-Halle" /></a></li>
            <li><span class="border"></span></li>
            <li><a class href="#" rel="nofollow"><img style="height:85px" src="img/Leibniz__Logo_EN_Negative_100mm.svg" alt="Die Leibniz-Gemeinschaft" /></a></li>
            <li><span class="border"></span></li>
            <li><a href="#"><img style="height:70px" src="img/2019_wch_logo_de_invertiert.png" alt="Wissenschafts Campus Halle" /></a></li>
            <li><span class="border"></span></li>
            <li><a href="#"><img style="height:50px" src="img/denbi-logo-white.svg" alt="deNBI" /></a></li>
          </ul>
        </div>
      </div>
    </div>
    <!-- End Sitemap -->
    <!-- Start Bottom Navigation -->
    <!-- End Bottom Navigation -->

================
File: inst/MetFamily/server.R
================
options(shiny.sanitize.errors = FALSE)

#########################################################################################
#########################################################################################
## libraries and functions

sourceFolder <- getwd()
isDevelopment <- FALSE
errorHunting <- FALSE
hcaHeatMapNew <- TRUE

#####################################################################################################
## handling of errors and warnings
if(errorHunting){
  options(warn = 2, shiny.error = recover)
  options(shiny.trace=TRUE)
  options(shiny.fullstacktrace=TRUE)
  options(shiny.testmode=TRUE)
} else {
  options(warn = 1, shiny.error = NULL)
  options(shiny.trace=FALSE)
  options(shiny.fullstacktrace=FALSE)
  options(shiny.testmode=FALSE)
}

##
## Load dependency libraries. Formerly in sourceTheCode()
##
library(MetFamily)
load_metfamily_dependencies()

#########################################################################################
#########################################################################################
## server-side logic of the Shiny app
shinyServer(
  func = function(input, output, session) {
    show_modal_spinner(spin = "self-building-square", text="Loading libraries")
    #########################################################################################
    #########################################################################################
    ## global variables per user
    
    ##############################################
    ## constants
    source("version.R")
      
    ## annotation constants
    artifactName   <- "Ignore"
    artifactColor  <- "red"
    selectionNone  <- "None"
    
    ## Download names
    ExportMatrixName <- NULL
    
    ## GUI constants
    runRightColumnWidthFull <- 11

    ### changing the legendcolumn width part 2 to 1.8
    legendColumnWidthFull <- 1.8
    runRightColumnWidthPart <- 8
    
    ### changing the legendcolumn width part 2 to 1.8
    legendColumnWidthPart <- 1.8
    
    ### change the anno legend height ... 20 to 18
    annoLegendEntryHeight <- 18
    maximumNumberOfTableEntries <- 50
    
    ##############################################
    ## program state
    initialGuiUpdatePerformed <- FALSE
    state <- reactiveValues(
      ## side bar handling
      runRightColumnWidth = runRightColumnWidthPart, 
      legendColumnWidth = legendColumnWidthPart,
      showSideBar = TRUE, 
      ## HCA vs PCA plots handling
      analysisType = "HCA",
      anyPlotDrawn = FALSE,
      ## HCA / PCA / classifier handling
      showHCAplotPanel = FALSE, 
      showPCAplotPanel = FALSE, 
      showAnnotationplotPanel = FALSE, 
      plotHcaShown = FALSE,
      plotPcaShown = FALSE,
      plotAnnotationShown = FALSE,
      ## plot controls
      showPlotControls = FALSE
    )
    plotToShow  <- "Display HCA"
    plotsToShow <- "Display HCA"
    showSideBar <- TRUE
    
    #########################################################################################
    #########################################################################################
    ## functions
    
    #########################################################################################
    ## source all server stuff
    resetWorkspaceFunctions <- list()
    suspendOnExitFunctions <- list()
    
    source(file = "app_files/server_functionsFilters.R", local = TRUE)$value
    source(file = "app_files/server_functionsSelections.R", local = TRUE)$value
    source(file = "app_files/server_functionsTableGui.R", local = TRUE)$value
    source(file = "app_files/server_functionsDownloads.R", local = TRUE)$value
    source(file = "app_files/server_functionsSerialization.R", local = TRUE)$value
    source(file = "app_files/server_guiDialogs.R", local = TRUE)$value
    source(file = "app_files/server_guiPlots.R", local = TRUE)$value
    source(file = "app_files/server_guiAnnotation.R", local = TRUE)$value
    source(file = "app_files/server_guiTabInput.R", local = TRUE)$value
    source(file = "app_files/server_guiTabAnnotation.R", local = TRUE)$value
    source(file = "app_files/server_guiTabClassifier.R", local = TRUE)$value
    source(file = "app_files/server_guiTabSampleFilter.R", local = TRUE)$value
    source(file = "app_files/server_guiTabMsmsFilter.R", local = TRUE)$value
    source(file = "app_files/server_guiTabPca.R", local = TRUE)$value
    source(file = "app_files/server_guiTabHca.R", local = TRUE)$value
    source(file = "app_files/server_guiTabSearch.R", local = TRUE)$value
    source(file = "app_files/server_guiTabExport.R", local = TRUE)$value
    source(file = "app_files/server_guiPlotControls.R", local = TRUE)$value
    source(file = "app_files/server_guiMs2plot.R", local = TRUE)$value

    ## Parse the input file
    resetWorkspace <- function(){
      print(paste("resetWorkspace"))
      
      for(resetWorkspaceFunction in resetWorkspaceFunctions)
        resetWorkspaceFunction()
      
      #########################################################################################
      ## panels
      state$showHCAplotPanel <<- FALSE
      state$showPCAplotPanel <<- FALSE
      state$showAnnotationplotPanel <<- FALSE
      
      state$plotHcaShown <<- FALSE
      state$plotPcaShown <<- FALSE
      state$plotAnnotationShown <<- FALSE
      
      state$analysisType <<- "HCA"
      state$anyPlotDrawn <<- FALSE
      
      ## plot controls
      showPlotControls <<- FALSE
    }
    
    #########################################################################################
    #########################################################################################
    ## observer
    remove_modal_spinner() #Remove preparing message
    
    ## controls
    obsTabs <- observeEvent(input$runTabs, {
      tabId <- input$runTabs
      print(paste("observe tabs", tabId))
      if(tabId == "HCA"){
        state$analysisType <<- "HCA"
        if(state$showHCAplotPanel){
          state$plotPcaShown <<- FALSE
          state$plotAnnotationShown <<- FALSE
          state$plotHcaShown <<- TRUE
        } else {
          state$plotHcaShown <<- FALSE
          state$plotPcaShown <<- FALSE
          state$plotAnnotationShown <<- FALSE
        }
      }
      if(tabId == "PCA"){
        state$analysisType <<- "PCA"
        if(state$showPCAplotPanel){
          state$plotHcaShown <<- FALSE
          state$plotAnnotationShown <<- FALSE
          state$plotPcaShown <<- TRUE
        } else {
          state$plotHcaShown <<- FALSE
          state$plotPcaShown <<- FALSE
          state$plotAnnotationShown <<- FALSE
        }
      }
      if(tabId == "Classifiers"){
        state$analysisType <<- "Annotation"
        if(state$showAnnotationplotPanel){
          state$plotHcaShown <<- FALSE
          state$plotPcaShown <<- FALSE
          state$plotAnnotationShown <<- TRUE
        } else {
          state$plotHcaShown <<- FALSE
          state$plotPcaShown <<- FALSE
          state$plotAnnotationShown <<- FALSE
        }
      }
      
      #########################################################
      ## initial gui update
      if(tabId == "Input" & !initialGuiUpdatePerformed){
        print(paste("update GUI initially", tabId))
        
        filePath <- system.file("extdata/classifier/", package = "MetFamily")
        resultObj <- getAvailableClassifiers(filePath)
        availableClassifiersDf           <<- resultObj$availableClassifiersDf
        availableClassifiersDfProperties <<- resultObj$availableClassifiersDfProperties
        
        output$classifierCount <- renderText({
          print(paste("init output$classifierCount"))
          paste("Available classifiers:", nrow(availableClassifiersDf))
        })
        
        if(nrow(availableClassifiersDf) > 0){
          output$classifierSelectionTable <- DT::renderDataTable(
            expr = availableClassifiersDf,
            server = FALSE, escape = FALSE, rownames = FALSE,
            selection = list(mode = "single"),#, selected = 1), 
            options = list(
              #scrollY = "600px",
              scrollX = "40vh",
              scrollY = "60vh",
              preDrawCallback = JS('function() { Shiny.unbindAll(this.api().table().node()); }'),
              drawCallback    = JS('function() { Shiny.bindAll(  this.api().table().node()); }'),
              iDisplayLength=nrow(availableClassifiersDf),       # initial number of records
              ordering = F,              # row ordering
              sDom  = 't'
            )
          )
        }
        
        if(nrow(availableClassifiersDf) > 0)
          shinyjs::toggleState("doAnnotation", TRUE)
        else
          shinyjs::toggleState("doAnnotation", FALSE)
        
        
        initialGuiUpdatePerformed <<- TRUE
      }
      
      if(tabId == "HCA" | tabId == "PCA")
        updateSelectedSelection()
    })
    obsChangePlot <- observeEvent(input$changePlot, {
      plot <- input$changePlot
      print(paste("Observe changePlot", plot))
      if(plot == "Display HCA"){
        analysisType <- "HCA"
        if(state$showHCAplotPanel){
          state$plotHcaShown <<- TRUE
          state$plotPcaShown <<- FALSE
          state$plotAnnotationShown <<- FALSE
        } else {
          state$plotHcaShown <<- FALSE
          state$plotPcaShown <<- FALSE
          state$plotAnnotationShown <<- FALSE
        }
      }
      if(plot == "Display PCA") {
        analysisType <- "PCA"
        if(state$showPCAplotPanel){
          state$plotHcaShown <<- FALSE
          state$plotPcaShown <<- TRUE
          state$plotAnnotationShown <<- FALSE
        } else {
          state$plotHcaShown <<- FALSE
          state$plotPcaShown <<- FALSE
          state$plotAnnotationShown <<- FALSE
        }
      }
      if(plot == "Display Annotation") {
        analysisType <- "Annotation"
        if(state$showAnnotationplotPanel){
          state$plotHcaShown <<- FALSE
          state$plotPcaShown <<- FALSE
          state$plotAnnotationShown <<- TRUE
        } else {
          state$plotHcaShown <<- FALSE
          state$plotPcaShown <<- FALSE
          state$plotAnnotationShown <<- FALSE
        }
      }
      state$analysisType <<- analysisType
      
      updateSelectedSelection()
    })
    obsShowSideBar <- observeEvent(input$showSideBar, {
      showSideBar <- input$showSideBar
      print(paste("Observe showSideBar", showSideBar))
      
      state$showSideBar <<- showSideBar
      showSideBar <<- showSideBar
      
      if(showSideBar){
        state$runRightColumnWidth <<- runRightColumnWidthPart
        state$legendColumnWidth   <<- legendColumnWidthPart
      }
      else{
        state$runRightColumnWidth <<- runRightColumnWidthFull
        state$legendColumnWidth   <<- legendColumnWidthFull
      }
      
      ## restore gui state
      ## TODO check if necessary
      updateCheckboxInput(session = session, inputId = "showPlotControls",      value    = state$showPlotControls)
      updateCheckboxInput(session = session, inputId = "showClusterLabels",     value    = state_tabHca$showClusterLabels)
      updateRadioButtons( session = session, inputId = "heatmapContent",        selected = state_tabHca$heatmapContent)
      updateRadioButtons( session = session, inputId = "heatmapOrdering",       selected = state_tabHca$heatmapOrdering)
      updateRadioButtons( session = session, inputId = "hcaPrecursorLabels",    selected = state_tabHca$hcaPrecursorLabels)
      updateCheckboxInput(session = session, inputId = "showScoresLabels",      value    = state_tabPca$showScoresLabels)
      updateRadioButtons( session = session, inputId = "loadingsLabels",        selected = state_tabPca$loadingsLabels)
      updateCheckboxGroupInput(session = session, inputId = "showLoadingsFeatures", selected = c(
        ifelse(test = state_tabPca$showLoadingsFeaturesAnnotated,   yes = "Annotated",     no = NULL),
        ifelse(test = state_tabPca$showLoadingsFeaturesUnannotated, yes = "Not Annotated", no = NULL),
        ifelse(test = state_tabPca$showLoadingsFeaturesSelected,    yes = "Selected",      no = NULL),
        ifelse(test = state_tabPca$showLoadingsFeaturesUnselected,  yes = "Not Selected",  no = NULL)
      ))
      updateCheckboxInput(session = session, inputId = "showLoadingsAbundance", value    = state_tabPca$showLoadingsAbundance)
    })
    
    ## display of tabs
    observe({
      toggle(condition = !is.null(state_tabInput$importedOrLoadedFile_s_), selector = "#runTabs li a[data-value='MS/MS filter']")
      toggle(condition = !is.null(state_tabInput$importedOrLoadedFile_s_), selector = "#runTabs li a[data-value='Sample filter']")
      toggle(condition = !is.null(state_tabInput$importedOrLoadedFile_s_), selector = "#runTabs li a[data-value='PCA']")
      toggle(condition = !is.null(state_tabInput$importedOrLoadedFile_s_), selector = "#runTabs li a[data-value='HCA']")
      toggle(condition = !is.null(state_tabInput$importedOrLoadedFile_s_), selector = "#runTabs li a[data-value='Search']")
      toggle(condition = !is.null(state_tabInput$importedOrLoadedFile_s_), selector = "#runTabs li a[data-value='Classifiers']")
      toggle(condition = !is.null(state_tabInput$importedOrLoadedFile_s_), selector = "#runTabs li a[data-value='Annotations']")
      toggle(condition = !is.null(state_tabInput$importedOrLoadedFile_s_), selector = "#runTabs li a[data-value='Project']")
    })
    
    
    suspendOnExitFunctions <- c(suspendOnExitFunctions, function(){
      print("Suspending server observers")
      obsTabs$suspend()
      obsChangePlot$suspend()
      obsShowSideBar$suspend()
    })
    
    ## suspend observer
    session$onSessionEnded(function() {
      print("Suspending observers")
      for(suspendOnExitFunction in suspendOnExitFunctions)
        suspendOnExitFunction()
    })
    
    #########################################################################################
    #########################################################################################
    ## direct output rendering
    output$information <- renderText({
      print(paste("init output$information"))
      ""
    })
    ## about page
    output$rInfo <- renderText({
      print(paste("init rInfo"))
      paste(
        R.Version()$version.string, 
        "\nMetFamily build: ", metFamilyAppVersion, "-", system(command = "hostname", intern = TRUE),
        "\nMetFamily package: ", packageVersion,
        sep = ""
      )
    })
    output$ipbImage <- renderImage({
      file <- system.file("MetFamily/www/logo_ipb_en.png", package = "MetFamily")
      
      list(src = file,
           alt = "IPB Halle"
      )
    }, deleteFile = FALSE)
    
    #########################################################################################
    #########################################################################################
    ## reactive output values
    output$showGUI <- reactive({
      print("update output$showGUI")
      output$information <- renderText({
        print(paste("init information", sep = ""))
        paste("Please perform ploting.", sep = "")
      })
      return(!is.null(state_tabInput$importedOrLoadedFile_s_))
    })
    output$analysisType <- reactive({
      print(paste("reactive update analysisType", state$analysisType))
      if(!is.null(state$analysisType)){
        if(state$analysisType == "HCA")
          plotToShow <<- "Display HCA"
        if(state$analysisType == "PCA")
          plotToShow <<- "Display PCA"
        if(state$analysisType == "Annotation")
          plotToShow <<- "Display Annotation"
      }
      return(state$analysisType)
    })
    output$showSideBar <- reactive({
      print(paste("reactive update showSideBar", state$showSideBar))
      return(state$showSideBar)
    })
    output$showHCAplotPanel <- reactive({
      print(paste("reactive update showHCAplotPanel", state$showHCAplotPanel))
      updateChangePlotRadioButton()
      return(state$showHCAplotPanel)
    })
    output$showPCAplotPanel <- reactive({
      print(paste("reactive update showPCAplotPanel", state$showPCAplotPanel))
      updateChangePlotRadioButton()
      return(state$showPCAplotPanel)
    })
    output$showAnnotationplotPanel <- reactive({
      print(paste("reactive update showAnnotationplotPanel", state$showAnnotationplotPanel))
      updateChangePlotRadioButton()
      return(state$showAnnotationplotPanel)
    })
    output$plotHcaShown <- reactive({
      print(paste("reactive update plotHcaShown", state$plotHcaShown))
      return(state$plotHcaShown)
    })
    output$plotPcaShown <- reactive({
      print(paste("reactive update plotPcaShown", state$plotPcaShown))
      return(state$plotPcaShown)
    })
    output$plotAnnotationShown <- reactive({
      print(paste("reactive update plotAnnotationShown", state$plotAnnotationShown))
      return(state$plotAnnotationShown)
    })

    updateChangePlotRadioButton <- function(){
      if((sum(c(state$showHCAplotPanel, state$showPCAplotPanel, state$showAnnotationplotPanel)) > 1) & !is.null(state$analysisType)){
        if(state$analysisType == "HCA")
          selectedItem <- "Display HCA"
        if(state$analysisType == "PCA")
          selectedItem <- "Display PCA"
        if(state$analysisType == "Annotation")
          selectedItem <- "Display Annotation"
        
        shownPlots <- NULL
        if(state$showHCAplotPanel)
          shownPlots <- c(shownPlots, "Display HCA")
        if(state$showPCAplotPanel)
          shownPlots <- c(shownPlots, "Display PCA")
        if(state$showAnnotationplotPanel)
          shownPlots <- c(shownPlots, "Display Annotation")
        
        plotsToShow <<- shownPlots
        updateRadioButtons(session = session, inputId = "changePlot", selected = selectedItem, choices = shownPlots, inline = TRUE)
      }
    }
    
    #########################################################################################
    #########################################################################################
    ## properties
    options(shiny.maxRequestSize=1024*1024^2) ## 500 mb file size
    outputOptions(output, 'showGUI',                 suspendWhenHidden=FALSE)
    outputOptions(output, 'showSideBar',             suspendWhenHidden=FALSE)
    outputOptions(output, 'showHCAplotPanel',        suspendWhenHidden=FALSE)
    outputOptions(output, 'showPCAplotPanel',        suspendWhenHidden=FALSE)
    outputOptions(output, 'showAnnotationplotPanel', suspendWhenHidden=FALSE)
    outputOptions(output, 'analysisType',            suspendWhenHidden=FALSE)
    outputOptions(output, 'plotHcaShown',            suspendWhenHidden=FALSE)
    outputOptions(output, 'plotPcaShown',            suspendWhenHidden=FALSE)
    outputOptions(output, 'plotAnnotationShown',     suspendWhenHidden=FALSE)
  }## function(input, output, session)
)## shinyServer

================
File: inst/MetFamily/ui.R
================
library(htmltools)
library(shiny)
library(shinyBS)
library(shinyjs)
library(DT)

ipbfooter <- HTML(readLines("www/ipbfooter.html"))

importParameterSetInit <- list(
  minimumIntensityOfMaximalMS2peak = 2000,
  minimumProportionOfMS2peaks = 0.05,
  neutralLossesPrecursorToFragments = TRUE,
  neutralLossesFragmentsToFragments = FALSE,
  mzDeviationAbsolute_grouping = 0.01,
  mzDeviationInPPM_grouping = 10,
  showImportParametersAdvanced = FALSE,
  doPrecursorDeisotoping = TRUE,
  mzDeviationAbsolute_precursorDeisotoping = 0.01,
  mzDeviationInPPM_precursorDeisotoping = 10,
  maximumRtDifference = 0.05,
  doMs2PeakGroupDeisotoping = TRUE,
  mzDeviationAbsolute_ms2PeakGroupDeisotoping = 0.01,
  mzDeviationInPPM_ms2PeakGroupDeisotoping = 10
)

#shinyUI(
 # ui = fluidPage(titlePanel(ipbheader),
#                 # IPB header 
 #                tags$head(tags$link(rel = "stylesheet", type = "text/css", 
#                                     href = "css/ipb-styles.css")),
#                 navbarPage(title = "MetFamily", 


shinyUI(
    ui =  navbarPage(title = div(img(src='img/Metfamily.gif',style="margin-top: -14px; padding-right:10px;padding-bottom:10px", height = 60)),
                     windowTitle="MetFamily",
                     footer = ipbfooter,
                    
    ##########################################################################################
    ##########################################################################################
    ##########################################################################################
    ##########################################################################################
    ## tab run
    tabPanel(
      shinyjs::useShinyjs(),
      ##############################################################################################
      ## enable / disable actionButtons while process is running
      singleton(tags$head(HTML(
        '
          <script type="text/javascript">
            $(document).ready(
              function() {
                // disable start_proc button after a click
                Shiny.addCustomMessageHandler(
                  "disableButton", 
                  function(message) {
                    $("#" + message).attr("disabled", "true");
                  }
                );
                // Enable start_proc button when computation is finished
                Shiny.addCustomMessageHandler(
                  "enableButton", 
                  function(message) {
                    $("#" + message).removeAttr("disabled");
                  }
                );
              }
            )
          </script>

          '
      ))),
      singleton(tags$head(tags$style(
        HTML(".shiny-notification {
             position:fixed;
             top: calc(40%);
             left: calc(50%);
             }
             "
      )))),
      singleton(tags$head(tags$link(rel = "stylesheet", 
                                     type = "text/css",
                                     href = "css/ipb-styles.css"))),
        
      title = "Run",
      ##############################################################################################
      ##############################################################################################
      ##############################################################################################
      ## side panel
      fluidRow(
      conditionalPanel(
        condition = "output.showSideBar",
        column(width = 4,
          tabsetPanel(
            id = "runTabs",
            ##############################################################################################
            ##############################################################################################
            ## file input
            tabPanel(
              title = "Input",
              wellPanel(
                #div(style="display:inline-block",actionButton(inputId = "test", label = "", icon = icon(name = "chevron-up", lib = "font-awesome"))),
                #actionButton(inputId = "test", label = NULL, icon = icon(name = "chevron-up", lib = "font-awesome")),#, width = NULL, ...)
                #downloadButton('downloadReport2', 'Export analysis report'),
                bsTooltip(id = "fileInputSelection", title = "The user is able to load a project file or to import external data", placement = "bottom", trigger = "hover"),
                radioButtons(inputId = "fileInputSelection", label = NULL, choices = c("Import data", "Load project", "Example data"), selected = "Load project", inline = FALSE),
                shiny::hr(),
                conditionalPanel(
                  condition = 'input.fileInputSelection == "Load project"',
                  h4("Project file input"),
                  p("Please choose a project file"),
                  bsTooltip(id = "matrixFile", title = "Press to choose an input file", placement = "bottom", trigger = "hover"),
                  fileInput(
                    multiple = FALSE,
                    inputId = 'matrixFile', 
                    label = NULL, #label = 'Choose fragment matrix file',
                    accept = c('text/comma-separated-values', 'text/plain', 'text/tab-separated-values')
                  ),
                  fluidRow(
                    column(width = 6,
                           bsTooltip(id = "loadProjectData", title = "Press to load the selected project file", placement = "bottom", trigger = "hover"),
                           disabled(actionButton(inputId = "loadProjectData", label = "Load project data", class="btn-success", width = "100%"))
                    ),##column
                    column(width = 6
                           
                    )##column
                  )##row
                ),
                conditionalPanel(
                  condition = 'input.fileInputSelection == "Import data"',
                  bsTooltip(id = "projectName", title = "Please type the name of the project", placement = "bottom", trigger = "hover"),
                  # Temporarily use const date under testing, see https://github.com/rstudio/shinytest2/issues/300#issuecomment-1908500601
                  textInput(inputId = "projectName", label = "Project name", 
                            value = paste("MetFamily project (created ", gsub(" ", "_", gsub(":", ".", 
                                                                                             ifelse(isFALSE(getOption("shiny.testmode")), Sys.time(), "2022-02-22_12.34.56.789")
                                                                                             )), ")", sep = "")),
                  bsTooltip(id = "projectDescription", title = "Please type a description of this project as free text", placement = "bottom", trigger = "hover"),
                  tags$style(type="text/css", "textarea {width:100%}"),
                  tags$textarea(id = 'projectDescription', placeholder = 'Comments here', rows = 3, ""),
                  #textInput(inputId = "projectDescription", label = "Project description", value = "", placeholder = "Comments here"),
                  fluidRow(
                    column(width = 6,
                           div(style="float:left",
                               h4("Parameters for import")
                           )
                    ),##column
                    column(width = 6,
                           div(style="float:right",
                               bsTooltip(id = "showImportParameters", title = "Display parameters for processing during import", placement = "bottom", trigger = "hover"),
                               checkboxInput(inputId = "showImportParameters", label = "Show parameters", value = FALSE)
                           )
                    )##column
                  ),##row
                  conditionalPanel(
                    condition = "input.showImportParameters",
                    fileInput(
                      multiple = FALSE,
                      inputId = 'importParameterFileInput', 
                      label = 'Apply parameters from import parameter file',
                      accept = c('text/comma-separated-values', 'text/plain', 'text/tab-separated-values')
                    ),
                    h5("Spectrum filter"),
                    fluidRow(
                      column(width = 6,
                             bsTooltip(id = "minimumIntensityOfMaximalMS2peak", title = "A MS/MS spectrum is considered iff the MS/MS feature with maximum intensity is greater or equal than this value", placement = "bottom", trigger = "hover"),
                             textInput(inputId = "minimumIntensityOfMaximalMS2peak", label = "Min. spectrum intensity", value = importParameterSetInit$minimumIntensityOfMaximalMS2peak)
                      ),##column
                      column(width = 6,
                             bsTooltip(id = "minimumProportionOfMS2peaks", title = "A MS/MS feature is considered iff the intensity is greater or equal than the maximum intensity times this value", placement = "bottom", trigger = "hover"),
                             textInput(inputId = "minimumProportionOfMS2peaks", label = "MS/MS peak proportion", value = importParameterSetInit$minimumProportionOfMS2peaks)
                      )##column
                    ),##row
                    h5("Neutral losses"),
                    fluidRow(
                      column(width = 6,
                             bsTooltip(id = "neutralLossesPrecursorToFragments", title = "Include neutral losses relative to the precursor ion, i.e. the m/z difference between the m/z of the precursor ion and the m/z of each fragment ion of the corresponding MS/MS spectrum", placement = "bottom", trigger = "hover"),
                             checkboxInput(inputId = "neutralLossesPrecursorToFragments", label = "Fragment vs. precursor", value = importParameterSetInit$neutralLossesPrecursorToFragments)
                      ),##column
                      column(width = 6,
                             bsTooltip(id = "neutralLossesFragmentsToFragments", title = "Include neutral losses amongst fragment ions, i.e. the m/z difference between the m/z of all pairs of fragment ions within each MS/MS spectrum; this involves the incorporation of potentially nonexistent neutral losses and needs more time for processing", placement = "bottom", trigger = "hover"),
                             checkboxInput(inputId = "neutralLossesFragmentsToFragments", label = "Fragment vs. fragment", value = importParameterSetInit$neutralLossesFragmentsToFragments)
                      )##column
                    ),##row
                    h5("Fragment grouping"),
                    fluidRow(
                      column(width = 6,
                             bsTooltip(id = "mzDeviationAbsolute_grouping", title = "A MS/MS feature is added to a fragment group if the absolute m/z difference is smaller or equal than this value", placement = "bottom", trigger = "hover"),
                             textInput(inputId = "mzDeviationAbsolute_grouping", label = "m/z deviation (abs.)", value = importParameterSetInit$mzDeviationAbsolute_grouping)
                      ),##column
                      column(width = 6,
                             bsTooltip(id = "mzDeviationInPPM_grouping", title = "A MS/MS feature is added to a fragment group if the absolute m/z difference is smaller or equal than the m/z times this value divided by 1,000,000 (<b>p</b>arts <b>p</b>er <b>m</b>illion)", placement = "bottom", trigger = "hover"),
                             textInput(inputId = "mzDeviationInPPM_grouping", label = "m/z deviation (PPM)", value = importParameterSetInit$mzDeviationInPPM_grouping)
                      )##column
                    ),##row
                    fluidRow(
                      column(width = 6,
                             div(style="float:left",
                                 h4("Advanced parameters")
                             )
                      ),##column
                      column(width = 6,
                             div(style="float:right",
                                 bsTooltip(id = "showImportParametersAdvanced", title = "Display parameters for processing during import", placement = "bottom", trigger = "hover"),
                                 checkboxInput(inputId = "showImportParametersAdvanced", label = "Show parameters", value = FALSE)
                             )
                      )##column
                    ),##row
                    conditionalPanel(
                      condition = "input.showImportParametersAdvanced",
                      h5("MS\u00B9 feature deisotoping"),
                      bsTooltip(id = "doPrecursorDeisotoping", title = "If checked, the set of MS\u00B9 features is deisotoped", placement = "bottom", trigger = "hover"),
                      checkboxInput(inputId = "doPrecursorDeisotoping", label = "MS\u00B9 feature deisotoping", value = importParameterSetInit$doPrecursorDeisotoping),
                      conditionalPanel(
                        condition = "input.doPrecursorDeisotoping",
                        fluidRow(
                          column(width = 6,
                                 bsTooltip(id = "mzDeviationAbsolute_precursorDeisotoping", title = "A MS\u00B9 feature is considered an +1 isotopic peak if the absolute of the m/z difference to the (putative) monoisotopic peak minus 1.0033548378 (=<sup>13</sup>C - <sup>12</sup>C) is smaller or equal than this value (analog for the +2 isotopic peak)", placement = "bottom", trigger = "hover"),
                                 textInput(inputId = "mzDeviationAbsolute_precursorDeisotoping", label = "m/z deviation (abs.)", value = importParameterSetInit$mzDeviationAbsolute_precursorDeisotoping)
                          ),##column
                          column(width = 6,
                                 bsTooltip(id = "mzDeviationInPPM_precursorDeisotoping", title = "A MS\u00B9 feature is considered an +1 isotopic peak if the absolute of the m/z difference to the (putative) monoisotopic peak minus 1.0033548378 (=<sup>13</sup>C - <sup>12</sup>C) is smaller or equal than the m/z times this value divided by 1,000,000 (<b>p</b>arts <b>p</b>er <b>m</b>illion, analog for the +2 isotopic peak)", placement = "bottom", trigger = "hover"),
                                 textInput(inputId = "mzDeviationInPPM_precursorDeisotoping", label = "m/z deviation (PPM)", value = importParameterSetInit$mzDeviationInPPM_precursorDeisotoping)
                          )##column
                        )##row
                      ),##conditional
                      bsTooltip(id = "maximumRtDifference", title = "A MS\u00B9 feature is considered an isotopic peak if the absolute of the retention time difference to the (putative) monoisotopic peak is smaller or equal than this value (in minutes)", placement = "bottom", trigger = "hover"),
                      textInput(inputId = "maximumRtDifference", label = "Retention time difference", value = importParameterSetInit$maximumRtDifference),
                      h5("Fragment deisotoping"),
                      bsTooltip(id = "doMs2PeakGroupDeisotoping", title = "If checked, the set of MS/MS features is deisotoped", placement = "bottom", trigger = "hover"),
                      checkboxInput(inputId = "doMs2PeakGroupDeisotoping", label = "Fragment deisotoping", value = importParameterSetInit$doMs2PeakGroupDeisotoping),
                      conditionalPanel(
                        condition = "input.doMs2PeakGroupDeisotoping",
                        fluidRow(
                          column(width = 6,
                                 bsTooltip(id = "mzDeviationAbsolute_ms2PeakGroupDeisotoping", title = "_A MS/MS feature is considered an +1 isotopic peak if the absolute of the m/z difference to the (putative) monoisotopic peak minus 1.0033548378 (=<sup>13</sup>C - <sup>12</sup>C) is smaller or equal than this value", placement = "bottom", trigger = "hover"),
                                 textInput(inputId = "mzDeviationAbsolute_ms2PeakGroupDeisotoping", label = "m/z deviation (abs.)", value = importParameterSetInit$mzDeviationAbsolute_ms2PeakGroupDeisotoping)
                          ),##column
                          column(width = 6,
                                 bsTooltip(id = "mzDeviationInPPM_ms2PeakGroupDeisotoping", title = "A MS/MS feature is considered an +1 isotopic peak if the absolute of the m/z difference to the (putative) monoisotopic peak minus 1.0033548378 (=<sup>13</sup>C - <sup>12</sup>C) is smaller or equal than the m/z times this value divided by 1,000,000 (<b>p</b>arts <b>p</b>er <b>m</b>illion)", placement = "bottom", trigger = "hover"),
                                 textInput(inputId = "mzDeviationInPPM_ms2PeakGroupDeisotoping", label = "m/z deviation (PPM)", value = importParameterSetInit$mzDeviationInPPM_ms2PeakGroupDeisotoping)
                          )##column
                        )##row
                      )##conditional
                    )
                  ),
                  h4("Data file input"),
                  p("Please choose metabolite profile (MS1 intensity, .txt)"),
                  bsTooltip(id = "ms1DataFile", title = "Press to choose a metabolite profile", placement = "bottom", trigger = "hover"),
                  fileInput(
                    multiple = FALSE,
                    inputId = 'ms1DataFile', 
                    label = NULL, #label = 'Choose fragment matrix file',
                    accept = c('text/comma-separated-values', 'text/plain', 'text/tab-separated-values')
                  ),
                  p("Please choose sirius annotation file"),
                  fileInput(
                    multiple = FALSE,
                    inputId = 'annotationFile', 
                    label = NULL,
                    accept = c('text/tab-separated-values', 'text/plain')
                  ),
                  p("Please choose spectral library (MS/MS, .msp)"),
                  bsTooltip(id = "ms2DataFile", title = "Press to choose a MS/MS library", placement = "bottom", trigger = "hover"),
                  fileInput(
                    multiple = FALSE,
                    inputId = 'ms2DataFile', 
                    label = NULL, #label = 'Choose fragment matrix file',
                    accept = c('text/plain', 'msp')
                  ),
                  fluidRow(
                    column(width = 6,
                           bsTooltip(id = "importMs1Ms2Data", title = "Press to import the selected metabolite profile and MS/MS library", placement = "bottom", trigger = "hover"),
                           disabled(actionButton(inputId = "importMs1Ms2Data", label = "Import MS\u00B9 and MS/MS data", class="btn-success", width = "100%"))
                    ),##column
                    column(width = 6,
                           bsTooltip(id = "importMs2Data", title = "Press to import the selected MS/MS library without a metabolite profile", placement = "bottom", trigger = "hover"),
                           disabled(actionButton(inputId = "importMs2Data", label = "Import MS/MS data", class="btn-success", width = "100%"))
                    )##column
                  )##row
                ),## conditional
                conditionalPanel(
                  condition = 'input.fileInputSelection == "Example data"',
                  h4("Example data input"),
                  helpText(
                    "The data set used as showcase in the MetFamily publication referenced in the tab 'About'."
                  ),
                  br(),
                  h4("Download original metabolite profile and MS/MS library"),
                  fluidRow(
                    column(width = 6, style="width:50%",
                           div(style="float:left;width:100%",
                               bsTooltip(id = "downloadMsData", title = "Download the original metabolite profile used in the MetFamily publication", placement = "bottom", trigger = "hover"),
                               downloadButton(outputId = "downloadMsData", label = "Download metabolite profile"),
                               tags$style(type='text/css', "#downloadMsData { width:100%}")
                           )
                    ),##column
                    column(width = 6, style="width:50%",
                           div(style="float:right;width:100%",
                               bsTooltip(id = "downloadMsMsData", title = "Download the original MS/MS library used in the MetFamily publication", placement = "bottom", trigger = "hover"),
                               downloadButton(outputId = "downloadMsMsData", label = "Download MS/MS library"),
                               tags$style(type='text/css', "#downloadMsMsData { width:100%}")
                           )
                    )##column
                  ),##row
                  br(),
                  h4("Download generated fragment matrix"),
                  fluidRow(
                    column(width = 6, style="width:50%",
                           bsTooltip(id = "downloadFragmentMatrix", title = "Download the fragment matrix generated from the original metabolite profile and MS/MS library used in the MetFamily publication", placement = "bottom", trigger = "hover"),
                           downloadButton('downloadFragmentMatrix', 'Download fragment matrix'),
                           tags$style(type='text/css', "#downloadFragmentMatrix { width:100%}")
                    ),
                    column(width = 6, style="width:50%"
                           
                    )
                  ),
                  br(),
                  fluidRow(
                    column(width = 12,
                           h4("Download showcase protocol"),
                           bsTooltip(id = "downloadDocShowcaseProtocol", title = "Download the protocol which is the basis of the results of the showcase in the MetFamily publication", placement = "bottom", trigger = "hover"),
                           downloadButton('downloadDocShowcaseProtocol', 'Download showcase protocol')
                    )
                  ),
                  br(),
                  h4("Load example data"),
                  fluidRow(
                    column(width = 6,
                           bsTooltip(id = "loadExampleData", title = "Press to load the example data set", placement = "bottom", trigger = "hover"),
                           actionButton(inputId = "loadExampleData", label = "Load example data", class="btn-success", width = "100%")
                    ),##column
                    column(width = 6
                           
                    )##column
                  )##row
                )## conditional
              ),##well
              wellPanel(
                h4("Input status"),
                bsTooltip(id = "fileInfo", title = "The current input status", placement = "bottom", trigger = "hover"),
                verbatimTextOutput(outputId = "fileInfo")
              )#,## well panel
              #uiOutput("errorPopupDialog")
            ),## tab panel
            ##############################################################################################
            ##############################################################################################
            ## global MS2 filter
            #navbarMenu("Filter",
            tabPanel(
              title = "MS/MS filter",
              conditionalPanel(
                condition = "output.showGUI",
                wellPanel(
                  ##############################################################################################
                  ## MS2 filter
                  h4("Global MS/MS filter"),
                  ##############################################################################################
                  ## MS2 plot
                  fluidRow(
                    column(width = 6,
                           div(style="float:left",
                               h4("Fragment overview")
                           )
                    ),##column
                    column(width = 6,
                           div(style="float:right",
                               bsTooltip(id = "showFragmentPlot", title = "Display m/z and frequency of frequent fragments", placement = "bottom", trigger = "hover"),
                               checkboxInput(inputId = "showFragmentPlot", label = "Show frequent fragments", value = FALSE)
                           )
                    )##column
                  ),##row
                  conditionalPanel(
                    condition = "input.showFragmentPlot",
                    plotOutput(height = 200, 
                               outputId = "fragmentPlot", 
                               #hover    = "fragmentPlot_hover",
                               hover    = hoverOpts(
                                 id = "fragmentPlot_hover",
                                 delay = 50, 
                                 delayType = "debounce"
                               ),
                               click    = "fragmentPlot_click",
                               dblclick = "fragmentPlot_dblclick",
                               #brush    = "fragmentPlot_brush"
                               brush    = brushOpts(
                                 id = "fragmentPlot_brush",
                                 resetOnNew = TRUE,
                                 direction = "x",
                                 delay = 00,
                                 delayType = "debounce"
                               )
                    )
                  ),
                  fluidRow(
                    column(width = 11,
                           bsTooltip(id = "globalFilter_ms2_masses1", title = "The MS/MS spectra should include the following fragment / neutral loss mass(es) (separated by \",\")<p>E.g. \"96.969, -162.053\" for a compound with a phosphate - fragment (H<sub>2</sub>PO<sub>4</sub><sup>-</sup>) and a hexose - neutral loss (C<sub>6</sub>O<sub>5</sub>H<sub>10</sub>)", placement = "bottom", trigger = "hover"),
                           textInput(inputId = "globalFilter_ms2_masses1", placeholder = 'E.g. 161.0443', label = "MS/MS spectrum includes m/z(s) #1")
                    ),
                    column(width = 1,
                           h4("or")
                    )
                  ),
                  fluidRow(
                    column(width = 11,
                           bsTooltip(id = "globalFilter_ms2_masses2", title = "The MS/MS spectra should include the following fragment / neutral loss mass(es) (separated by \",\")<p>E.g. \"96.969, -162.053\" for a compound with a phosphate - fragment (H<sub>2</sub>PO<sub>4</sub><sup>-</sup>) and a hexose - neutral loss (C<sub>6</sub>O<sub>5</sub>H<sub>10</sub>)", placement = "bottom", trigger = "hover"),
                           textInput(inputId = "globalFilter_ms2_masses2", placeholder = 'E.g. -88.01808', label = "MS/MS spectrum includes m/z(s) #2")
                    ),
                    column(width = 1,
                           h4("or")
                    )
                  ),
                  fluidRow(
                    column(width = 11,
                           bsTooltip(id = "globalFilter_ms2_masses3", title = "The MS/MS spectra should include the following fragment / neutral loss mass(es) (separated by \",\")<p>E.g. \"96.969, -162.053\" for a compound with a phosphate - fragment (H<sub>2</sub>PO<sub>4</sub><sup>-</sup>) and a hexose - neutral loss (C<sub>6</sub>O<sub>5</sub>H<sub>10</sub>)", placement = "bottom", trigger = "hover"),
                           textInput(inputId = "globalFilter_ms2_masses3", placeholder = 'E.g. 96.969, -162.053', label = "MS/MS spectrum includes m/z(s) #3")
                    ),
                    column(width = 1,
                           h4("")
                    )
                  ),
                  bsTooltip(id = "globalFilter_ms2_ppm", title = "The MS/MS feature matching allows this error in PPM (<b>p</b>arts <b>p</b>er <b>m</b>illion)", placement = "bottom", trigger = "hover"),
                  textInput(inputId = "globalFilter_ms2_ppm", placeholder = 'PPM number here', label = "PPM"),
                  ##############################################################################################
                  ## filter button
                  fluidRow(
                    column(width = 6,
                           div(style="float:left;width:100%",
                               bsTooltip(id = "applyGlobalMS2filters", title = "Press to determine the global set of MS\u00B9 features which MS/MS spectra comprise the given MS/MS features", placement = "bottom", trigger = "hover"),
                               actionButton(inputId = "applyGlobalMS2filters", label = "Apply MS/MS filter", class="btn-success", width = "100%")
                           )
                    ),##column
                    column(width = 6,
                           div(style="float:right;width:100%",
                               bsTooltip(id = "clearGlobalMS2filters", title = "Press to clear the global MS/MS filter", placement = "bottom", trigger = "hover"),
                               actionButton(inputId = "clearGlobalMS2filters", label = "Clear MS/MS filter", class="btn-danger", width = "100%")
                           )
                    )##column
                  ),##row
                  hr(),
                  h4("Filtered MS\u00B9 features"),
                  bsTooltip(id = "globalMS2filteredPrecursors", title = "The number of MS\u00B9 features which MS/MS spectra comprise the given MS/MS features", placement = "bottom", trigger = "hover"),
                  verbatimTextOutput("globalMS2filteredPrecursors"),
                  conditionalPanel(
                    condition = "output.globalMS2filterValid",
                    bsTooltip(id = "downloadGlobalMS2filteredPrecursors", title = "Download a project file which is reduced to the filtered set of MS\u00B9 features", placement = "bottom", trigger = "hover"),
                    downloadButton('downloadGlobalMS2filteredPrecursors', 'Download reduced project file')
                  )
                )## well
              ),## conditional panel
              conditionalPanel(
                condition = "!output.showGUI",
                wellPanel(
                  h4("Please import a data file")
                )
              )## conditional panel
            ),## tab panel
            ##############################################################################################
            ##############################################################################################
            ## sample selection
            tabPanel(
              title = "Sample filter", 
              conditionalPanel(
                condition = "output.showGUI",
                wellPanel(
                  ##############################################################################################
                  ## sample table
                  DT::dataTableOutput("sampleTable"),
                  bsTooltip(id = "updateSampleTable", title = "Updates the order and the exclusion status of samples", placement = "bottom", trigger = "hover"),
                  actionButton(inputId = "updateSampleTable", label = "Apply sample order and exclusion status", class="btn-success")
                )##well
              ),## conditiojal panel
              conditionalPanel(
                condition = "!output.showGUI",
                wellPanel(
                  h4("Please import a data file")
                )## well panel
              )## conditional panel
            ),## tab panel
            #),
            ##############################################################################################
            ##############################################################################################
            ## PCA
            tabPanel(
              title = "PCA", 
              conditionalPanel(
                condition = "output.showGUI && output.globalMS2filterValid",
                wellPanel(
                  ##############################################################################################
                  ## HCA group and abundance filter
                  fluidRow(
                    column(width = 7,
                           div(style="float:left",
                               h4("MS\u00B9 abundance filter for PCA")
                           )
                    ),##column
                    column(width = 5,
                           div(style="float:right",
                               bsTooltip(id = "showPCAfilterOptions", title = "Display filter settings", placement = "bottom", trigger = "hover"),
                               checkboxInput(inputId = "showPCAfilterOptions", label = "Show filter settings", value = TRUE)
                           )
                    )##column
                  ),##row
                  conditionalPanel(
                    condition = "input.showPCAfilterOptions",
                    bsTooltip(id = "pcaFilter_average", title = "The average MS\u00B9 abundance should be greater or equal than this value", placement = "bottom", trigger = "hover"),
                    textInput(inputId = "pcaFilter_average", placeholder = 'E.g. 10000', label = "Average MS\u00B9 abundance"),
                    bsTooltip(id = "pcaFilter_lfc", title = "The log<sub>2</sub>-fold change [ log<sub>2</sub>( mean(group one) / mean(group two) ) ] between the average MS\u00B9 abundances should be greater/smaller or equal than this value", placement = "bottom", trigger = "hover"),
                    textInput(inputId = "pcaFilter_lfc", placeholder = 'E.g. 2 or -2', label = "MS\u00B9 log2-fold change"),
                    fluidRow(style="overflow-y:scroll; 
                                    max-height: 200px;",
                      column(width = 7,
                                 div(style="float:left;
                                            width:100%;",
                                     tags$div(title="Please select the set of sample groups",
                                              checkboxGroupInput(inputId = "pcaGroups", label = "Groups", choices = c(""))
                                     )
                                 )
                      ),##column
                      column(width = 5,
                        fluidRow(style = "vertical-align: top",
                          bsTooltip(id = "filterByPCAgroupSamples", title = "Display and select samples for PCA analysis", placement = "bottom", trigger = "hover"),
                          checkboxInput(inputId = "filterByPCAgroupSamples", label = "Select samples", value = FALSE)
                        ),
                        fluidRow(style = "vertical-align: top",
                          bsTooltip(id = "selectAllPCAGroups", title = "Select all groups", placement = "bottom", trigger = "hover"),
                          actionButton(inputId = "selectAllPCAGroups", label = "Select all", width = "100%"),
                          bsTooltip(id = "selectNoPCAGroups", title = "Deselect all groups", placement = "bottom", trigger = "hover"),
                          actionButton(inputId = "selectNoPCAGroups", label = "Deselect all", width = "100%"),
                          bsTooltip(id = "selectInvertedPCAGroups", title = "Invert the group selection", placement = "bottom", trigger = "hover"),
                          actionButton(inputId = "selectInvertedPCAGroups", label = "Invert", width = "100%")
                        )
                      )##column
                    ),##row
                    conditionalPanel(
                      condition = "input.filterByPCAgroupSamples",
                      fluidRow(style="overflow-y:scroll; 
                                    max-height: 200px;",
                               column(width = 12,
                               div(style="float:left;
                                            width:100%;",
                        tags$div(title="Please select the set of samples",
                                 checkboxGroupInput(inputId = "pcaSamples", label = "Samples", choices = c(""))
                        )))
                      )
                    ),
                    
                    #tags$div(title="Please select the set of sample groups",
                    #         checkboxGroupInput(inputId = "pcaGroups", label = "Groups", choices = c(""))
                    #),
                    
                    bsTooltip(id = "pcaFilterIncludeIgnoredPrecursors", title = "Include or filter out ignored MS\u00B9 features, i.e. MS\u00B9 features which have been annotated as \\'Ignore\\'", placement = "bottom", trigger = "hover"),
                    checkboxInput(inputId = "pcaFilterIncludeIgnoredPrecursors", label = "Include ignored MS\u00B9 features", value = FALSE),
                    ##############################################################################################
                    ## filter button
                    fluidRow(
                      column(width = 6,
                             div(style="float:left;width:100%",
                                 bsTooltip(id = "applyPcaFilters", title = "Press to determine the set of MS\u00B9 features which fulfill the given criteria", placement = "bottom", trigger = "hover"),
                                 actionButton(inputId = "applyPcaFilters", label = "Apply filter", class="btn-success", width = "100%")
                             )
                      ),##column
                      column(width = 6,
                             div(style="float:right;width:100%",
                                 bsTooltip(id = "clearPcaFilters", title = "Press to clear the MS\u00B9 abundance filter for PCA", placement = "bottom", trigger = "hover"),
                                 actionButton(inputId = "clearPcaFilters", label = "Clear filter", class="btn-danger", width = "100%")
                             )
                      )##column
                    )##row
                  ),## conditional panel
                  hr(),
                  h4("Filtered MS\u00B9 features"),
                  bsTooltip(id = "pcaFilteredPrecursors", title = "The number of MS\u00B9 features which fulfill the given criteria", placement = "bottom", trigger = "hover"),
                  verbatimTextOutput("pcaFilteredPrecursors"),
                  conditionalPanel(
                    condition = "output.pcaFilterValid",
                    bsTooltip(id = "downloadPcaFilteredPrecursors", title = "Download a project file which is reduced to the filtered set of MS\u00B9 features", placement = "bottom", trigger = "hover"),
                    downloadButton('downloadPcaFilteredPrecursors', 'Download reduced project file')
                  )##conditional
                ),##well
                conditionalPanel(
                  condition = "output.pcaFilterValid",
                  wellPanel(
                    bsTooltip(id = "ms1AnalysisMethod", title = "Please choose the method for the analysis of MS\u00B9 abundances", placement = "bottom", trigger = "hover"),
                    selectInput(multiple = FALSE, inputId = "ms1AnalysisMethod", label = "Method", selected = "PCA", choices = c(
                      "PCA (Principal Component Analysis)", 
                      "sPCA (Sparse Principal Component Analysis)",
                      "PLS-DA (Partial Least Squares Discriminant Analysis)", 
                      "sPLS-DA (Sparse Partial Least Squares Discriminant Analysis)"
                    ), selectize = FALSE),
                    ##############################################################################################
                    ## PCA properties
                    fluidRow(
                      column(width = 6,
                             div(style="float:left",
                                 h4("Method properties")
                             )
                      ),##column
                      column(width = 6,
                             div(style="float:right",
                                 bsTooltip(id = "showPCAadvancedOptions", title = "Display further settings for the selected method", placement = "bottom", trigger = "hover"),
                                 checkboxInput(inputId = "showPCAadvancedOptions", label = "Show advanced options", value = FALSE)
                             )
                      )##column
                    ),##row
                    conditionalPanel(
                      condition = "input.showPCAadvancedOptions",
                      bsTooltip(id = "pcaScaling", title = "Adjust the scaling of MS\u00B9 abundances for the selected method", placement = "bottom", trigger = "hover"),
                      selectInput(multiple = FALSE, inputId = "pcaScaling", label = "Scaling", selected = "Pareto", choices = c(
                        "None", 
                        "Mean center", 
                        "Autoscaling (unit variance)",
                        "Pareto"
                        #"Vector normalization", 
                      ), selectize = FALSE),
                      bsTooltip(id = "pcaLogTransform", title = "MS\u00B9 abundances for the selected method will be log<sub>2</sub> transformed", placement = "bottom", trigger = "hover"),
                      checkboxInput(inputId = "pcaLogTransform", label = "Log2 transformation", value = FALSE),
                      fluidRow(
                        column(
                          width = 6,
                          tags$div(title="Please select the first component",
                            selectInput(inputId = "pcaDimensionOne", label = "Component 1", choices = c("1", "2", "3", "4", "5"), selected = "1", selectize = FALSE)
                          )
                        ),
                        column(
                          width = 6,
                          tags$div(title="Please select the second component",
                            selectInput(inputId = "pcaDimensionTwo", label = "Component 2", choices = c("1", "2", "3", "4", "5"), selected = "2", selectize = FALSE)
                          )
                        )
                      )
                    ),
                    fluidRow(
                      column(width = 6,
                             bsTooltip(id = "drawPCAplots", title = "Display the scores and the loadings plot given the set of filtered MS\u00B9 features and settings of the selected method", placement = "bottom", trigger = "hover"),
                             actionButton(inputId = "drawPCAplots", label = "Perform analysis", class="btn-success", width = "100%")
                      ),##column
                      column(width = 6
                             ## nothing
                      )##column
                    )##row
                  )##well
                )## conditiojal panel
              ),## conditiojal panel
              conditionalPanel(
                condition = "!output.showGUI",
                wellPanel(
                  h4("Please import a data file")
                )## well panel
              ),## conditional panel
              conditionalPanel(
                condition = "output.showGUI && !output.globalMS2filterValid",
                wellPanel(
                  h4("Please apply a valid MS/MS filter")
                )## well panel
              )## conditional panel
            ),## tab panel
            ##############################################################################################
            ##############################################################################################
            ## HCA
            tabPanel(
              title = "HCA", 
              conditionalPanel(
                condition = "output.showGUI && output.globalMS2filterValid",
                wellPanel(
                  ##############################################################################################
                  ## HCA group and abundance filter
                  fluidRow(
                    column(width = 7,
                           div(style="float:left",
                               h4("MS\u00B9 abundance filter for HCA")
                           )
                    ),##column
                    column(width = 5,
                           div(style="float:right",
                               bsTooltip(id = "showHCAfilterOptions", title = "Display filter settings", placement = "bottom", trigger = "hover"),
                               checkboxInput(inputId = "showHCAfilterOptions", label = "Show filter settings", value = TRUE)
                           )
                    )##column
                  ),##row
                  conditionalPanel(
                    condition = "input.showHCAfilterOptions",
                    bsTooltip(id = "hcaFilter_average", title = "The average MS\u00B9 abundance should be greater or equal than this value", placement = "bottom", trigger = "hover"),
                    textInput(inputId = "hcaFilter_average", placeholder = 'E.g. 10000', label = "Average MS\u00B9 abundance"),
                    bsTooltip(id = "hcaFilter_lfc", title = "The log<sub>2</sub>-fold change [ log<sub>2</sub>( mean(group one) / mean(group two) ) ] between the average MS\u00B9 abundances should be greater/smaller or equal than this value", placement = "bottom", trigger = "hover"),
                    textInput(inputId = "hcaFilter_lfc", placeholder = 'E.g. 2 or -2', label = "MS\u00B9 log2-fold change"),
                    fluidRow(style = "overflow-y:scroll; 
                                      max-height: 200px",
                             #border: 1px solid #cccccc;
                      column(
                        width = 6,
                        tags$div(
                          title="Please select the first sample group",
                          radioButtons(inputId = "hcaFilterGroupOne", label = "Group 1", choices = c(""))
                        )
                      ),
                      column(
                        width = 6,
                        tags$div(
                          title="Please select the second sample group",
                          radioButtons(inputId = "hcaFilterGroupTwo", label = "Group 2", choices = c(""))
                        )
                      )
                    ),
                    bsTooltip(id = "hcaFilterIncludeIgnoredPrecursors", title = "Include or filter out ignored MS\u00B9 features, i.e. MS\u00B9 features which have been annotated as \\'Ignore\\'", placement = "bottom", trigger = "hover"),
                    checkboxInput(inputId = "hcaFilterIncludeIgnoredPrecursors", label = "Include ignored MS\u00B9 features", value = FALSE),
                    ##############################################################################################
                    ## filter button
                    fluidRow(
                      column(width = 6, 
                             div(style="float:left;width:100%",
                                 bsTooltip(id = "applyHcaFilters", title = "Press to determine the set of MS\u00B9 features which fulfill the given filter criteria", placement = "bottom", trigger = "hover"),
                                 actionButton(inputId = "applyHcaFilters", label = "Apply filter", class="btn-success", width = "100%")
                             )
                      ),##column
                      column(width = 6, 
                             div(style="float:right;width:100%",
                                 bsTooltip(id = "clearHcaFilters", title = "Press to clear the MS\u00B9 abundance filter for HCA", placement = "bottom", trigger = "hover"),
                                 actionButton(inputId = "clearHcaFilters", label = "Clear filter", class="btn-danger", width = "100%")
                             )
                      )##column
                    )##row
                  ),## conditional panel
                # ),##well panel
                # wellPanel(
                  hr(),
                  h4("Filtered MS\u00B9 features"),
                  bsTooltip(id = "hcaFilteredPrecursors", title = paste("The number of MS\u00B9 features which fulfill the given filter criteria. HCA analysis is only possible for less than",
                                                                        5000, #maximumNumberOfPrecursorsForHca,
                                                                        "MS\u00B9 features."),
                            placement = "bottom", trigger = "hover"),
                  verbatimTextOutput("hcaFilteredPrecursors"),
                  conditionalPanel(
                    condition = "output.hcaFilterValid",
                    bsTooltip(id = "downloadHcaFilteredPrecursors", title = "Download a project file which is reduced to the filtered set of MS\u00B9 features", placement = "bottom", trigger = "hover"),
                    downloadButton('downloadHcaFilteredPrecursors', 'Download reduced project file')
                  )##conditional
                ),##well panel
                conditionalPanel(
                  condition = "output.hcaFilterValid",
                  wellPanel(
                    ##############################################################################################
                    ## HCA properties
                    fluidRow(
                      column(width = 6,
                             div(style="float:left",
                                 h4("HCA properties")
                             )
                      ),##column
                      column(width = 6,
                             div(style="float:right",
                                 bsTooltip(id = "showHCAadvancedOptions", title = "Display further HCA settings", placement = "bottom", trigger = "hover"),
                                 checkboxInput(inputId = "showHCAadvancedOptions", label = "Show advanced options", value = FALSE)
                             )
                      )##column
                    ),##row
                    conditionalPanel(
                      condition = "input.showHCAadvancedOptions",
                      bsTooltip(id = "hcaDistanceFunction", title = "The distance function used for clustering", placement = "bottom", trigger = "hover"),
                      selectInput(multiple = FALSE, inputId = "hcaDistanceFunction", label = "Distance function", selected = "Jaccard (intensity-weighted)", choices = c(
                        "Jaccard",
                        "Jaccard (intensity-weighted)",
                        "Jaccard (fragment-count-weighted)",
                        "NDP (Normalized dot product)"
                      ), selectize = FALSE)
                      #bsTooltip(id = "hcaClusterMethod", title = "The method used for clustering", placement = "bottom", trigger = "hover"),
                      #selectInput(multiple = FALSE, inputId = "hcaClusterMethod", label = "Cluster method", selected = "ward.D", choices = c(
                      #  "single", 
                      #  "complete", 
                      #  "average", 
                      #  "mcquitty", 
                      #  "median", 
                      #  "centroid", 
                      #  "ward.D", 
                      #  "ward.D2"
                      #), selectize = FALSE)
                    ),
                    fluidRow(
                      column(width = 6,
                             bsTooltip(id = "drawHCAplots", title = "Display the HCA dendrogram given the set of filtered MS\u00B9 features and HCA settings", placement = "bottom", trigger = "hover"),
                             actionButton(inputId = "drawHCAplots", label = "Draw hierarchical cluster", class="btn-success", width = "100%")
                      ),##column
                      column(width = 6
                             
                      )##column
                    ),##row
                    conditionalPanel(
                      condition = "output.showGUI && output.plotHcaShown",
                      br(),
                      bsTooltip(id = "downloadDistanceMatrix", title = "Download the distance matrix of the currently displayed hierarchical cluster dendrogram", placement = "bottom", trigger = "hover"),
                      downloadButton('downloadDistanceMatrix', 'Download distance matrix')
                    )
                  )## well panel
                )## conditional panel
              ),## conditional panel
              conditionalPanel(
                condition = "!output.showGUI",
                wellPanel(
                  h4("Please import a data file")
                )## well panel
              ),## conditional panel
              conditionalPanel(
                condition = "output.showGUI && !output.globalMS2filterValid",
                wellPanel(
                  h4("Please apply a valid MS/MS filter")
                )## well panel
              )## conditional panel
            ),## tab panel
            ##############################################################################################
            ##############################################################################################
            ## search
            tabPanel(
              title = "Search",
              conditionalPanel(
                condition = "output.showGUI && (output.plotHcaShown || output.plotPcaShown)",
                #condition = "output.showGUI",
                wellPanel(
                  h4("Search mode"),
                  bsTooltip(id = "searchMS1orMS2", title = "Please choose the criterion for selecting MS\u00B9 features", placement = "bottom", trigger = "hover"),
                  radioButtons(inputId = "searchMS1orMS2", label = NULL, choices = c("MS1 feature m/z", "Fragment m/z")),
                  hr(),
                  conditionalPanel(
                    condition = "input.searchMS1orMS2 == 'MS1 feature m/z'",
                    fluidRow(
                      column(width = 6,
                             bsTooltip(id = "searchMS1mass", title = "The MS\u00B9 feature m/z should be similar to at least one of the given values (separated by \",\")", placement = "bottom", trigger = "hover"),
                             textInput(inputId = "searchMS1mass", placeholder = 'E.g. 592.1792', label = "MS\u00B9 feature m/z('s)")
                      ),##column
                      column(width = 6,
                             bsTooltip(id = "searchMS1massPpm", title = "The specified MS\u00B9 feature m/z allows this error in PPM (<b>p</b>arts <b>p</b>er <b>m</b>illion)", placement = "bottom", trigger = "hover"),
                             textInput(inputId = "searchMS1massPpm", placeholder = 'PPM number here', label = "PPM")
                      )##column
                    )##row
                  ),## conditional panel
                  conditionalPanel(
                    condition = "input.searchMS1orMS2 == 'Fragment m/z'",
                    fluidRow(
                      column(width = 11,
                             bsTooltip(id = "search_ms2_masses1", title = "The MS/MS spectra should include the following fragment / neutral loss mass(es) (separated by \",\")<p>E.g. \"96.969, -162.053\" for a compound with a phosphate - fragment (H<sub>2</sub>PO<sub>4</sub><sup>-</sup>) and a hexose - neutral loss (C<sub>6</sub>O<sub>5</sub>H<sub>10</sub>)", placement = "bottom", trigger = "hover"),
                             textInput(inputId = "search_ms2_masses1", placeholder = 'E.g. 161.0443', label = "MS/MS spectrum includes mass(es) #1")
                      ),
                      column(width = 1,
                             h4("or")
                      )
                    ),
                    fluidRow(
                      column(width = 11,
                             bsTooltip(id = "search_ms2_masses2", title = "The MS/MS spectra should include the following fragment / neutral loss mass(es) (separated by \",\")<p>E.g. \"96.969, -162.053\" for a compound with a phosphate - fragment (H<sub>2</sub>PO<sub>4</sub><sup>-</sup>) and a hexose - neutral loss (C<sub>6</sub>O<sub>5</sub>H<sub>10</sub>)", placement = "bottom", trigger = "hover"),
                             textInput(inputId = "search_ms2_masses2", placeholder = 'E.g. -88.01808', label = "MS/MS spectrum includes mass(es) #2")
                      ),
                      column(width = 1,
                             h4("or")
                      )
                    ),
                    fluidRow(
                      column(width = 11,
                             bsTooltip(id = "search_ms2_masses3", title = "The MS/MS spectra should include the following fragment / neutral loss mass(es) (separated by \",\")<p>E.g. \"96.969, -162.053\" for a compound with a phosphate - fragment (H<sub>2</sub>PO<sub>4</sub><sup>-</sup>) and a hexose - neutral loss (C<sub>6</sub>O<sub>5</sub>H<sub>10</sub>)", placement = "bottom", trigger = "hover"),
                             textInput(inputId = "search_ms2_masses3", placeholder = 'E.g. 96.969, -162.053', label = "MS/MS spectrum includes mass(es) #3")
                      ),
                      column(width = 1,
                             h4("")
                      )
                    ),
                    bsTooltip(id = "searchMS2massPpm", title = "The specified fragment m/z values allow this error in PPM (<b>p</b>arts <b>p</b>er <b>m</b>illion)", placement = "bottom", trigger = "hover"),
                    textInput(inputId = "searchMS2massPpm", placeholder = 'PPM number here', label = "PPM")
                  ),## conditional panel
                  bsTooltip(id = "searchIncludeIgnoredPrecursors", title = "Include or filter out ignored MS\u00B9 features, i.e. MS\u00B9 features which have been annotated as \\'Ignore\\'", placement = "bottom", trigger = "hover"),
                  checkboxInput(inputId = "searchIncludeIgnoredPrecursors", label = "Include ignored MS\u00B9 features", value = FALSE),
                  fluidRow(
                    column(width = 6,
                           div(style="float:left;width:100%",
                               bsTooltip(id = "applySearch", title = "Press to mark the set of MS\u00B9 features which fulfill the given criteria", placement = "bottom", trigger = "hover"),
                               actionButton(inputId = "applySearch", label = "Search", class="btn-success", width = "100%")
                           )
                    ),##column
                    column(width = 6,
                           div(style="float:right;width:100%",
                               bsTooltip(id = "clearSearch", title = "Press to clear the selected set of MS\u00B9 feature hits in HCA and PCA", placement = "bottom", trigger = "hover"),
                               actionButton(inputId = "clearSearch", label = "Clear search", class="btn-danger", width = "100%")
                           )
                    )##column
                  ),##row
                  hr(),
                  h4("MS\u00B9 feature hits"),
                  bsTooltip(id = "searchInfo", title = "The number of MS\u00B9 features which fulfill the given filter criteria", placement = "bottom", trigger = "hover"),
                  verbatimTextOutput("searchInfo"),
                  conditionalPanel(
                    condition = "output.searchFilterValid & output.filterSearchActive",
                    bsTooltip(id = "downloadSearchPrecursors", title = "Download a project file which is reduced to the searched set of MS\u00B9 features", placement = "bottom", trigger = "hover"),
                    downloadButton('downloadSearchPrecursors', 'Download reduced project file')
                  )##conditional
                )##well
              ),## conditional panel
              conditionalPanel(
                #condition = "!(output.analysisType == 'HCA' || output.analysisType == 'PCA')",
                condition = "!output.showGUI",
                wellPanel(
                  h4("Please import a data file")
                )## well
              ),## conditional panel
              conditionalPanel(
                condition = "output.showGUI && !(output.plotHcaShown || output.plotPcaShown)",
                wellPanel(
                  h4("Please perform HCA or PCA prior to search")
                )## well
              )## conditional panel
            ),## tab panel
            tabPanel(
              title = "Classifiers",
              conditionalPanel(
                condition = "output.showGUI",
                wellPanel(
                  h4("Classifier selection"),
                  bsTooltip(id = "classifierCount", title = "The number of available classifiers for the semi-automated metabolite family annotation of MS\u00B9 features", placement = "bottom", trigger = "hover"),
                  verbatimTextOutput(outputId = "classifierCount"),
                  DT::dataTableOutput("classifierSelectionTable"),
                  bsTooltip(id = "doAnnotation", title = "Press to automatically annotate metabolite families to spectra ", placement = "bottom", trigger = "hover"),
                  disabled(actionButton(inputId = "doAnnotation", label = "Perform scan", class="btn-success", width = "100%"))
                )
              ),
              conditionalPanel(
                condition = "!output.showGUI",
                wellPanel(
                  h4("Please import a data file")
                )## well panel
              )## conditional panel
            ),## tab panel
            tabPanel(
              title = "Annotations",
              conditionalPanel(
                condition = "output.showGUI",
                wellPanel(
                  h4("Metabolite family selection"),
                  bsTooltip(id = "familyCount2", title = "The number of available metabolite families which were annotated among the MS\u00B9 features", placement = "bottom", trigger = "hover"),
                  verbatimTextOutput(outputId = "familyCount2"),
                  DT::dataTableOutput("familySelectionTable"),
                  conditionalPanel(
                    condition = "output.metaboliteFamilySelected",
                    #condition = "length(input$familySelectionTable_rows_selected) == 1",
                    h4("Metabolite family properties"),
                    bsTooltip(id = "featureCountForFamily", title = "The number of MS\u00B9 features of the selected metabolite family", placement = "bottom", trigger = "hover"),
                    verbatimTextOutput(outputId = "featureCountForFamily"),
                    fluidRow(
                      column(width = 4,
                             bsTooltip(id = "selectMetaboliteFamily", title = "Press to select this metabolite family", placement = "bottom", trigger = "hover"),
                             actionButton(inputId = "selectMetaboliteFamily", label = "Select", class="btn-success", width = "100%")
                      ),##column
                      column(width = 4,
                             bsTooltip(id = "renameMetaboliteFamily", title = "Press to rename this metabolite family annotation", placement = "bottom", trigger = "hover"),
                             actionButton(inputId = "renameMetaboliteFamily", label = "Rename", class="btn-success", width = "100%")
                      ),##column
                      column(width = 4,
                             bsTooltip(id = "removeMetaboliteFamily", title = "Press to remove this metabolite family annotation", placement = "bottom", trigger = "hover"),
                             actionButton(inputId = "removeMetaboliteFamily", label = "Remove", class="btn-danger", width = "100%")
                      )##column
                    ),##row
                    conditionalPanel(
                      condition = "output.classifierLoaded",
                      bsTooltip(id = "metaboliteFamilyComparisonClass", title = "Please choose the class for comparison", placement = "bottom", trigger = "hover"),
                      selectInput(multiple = FALSE, inputId = "metaboliteFamilyComparisonClass", label = "Compare to class", selected = "[init]", choices = c("[init]"), selectize = FALSE)
                    ),
                    plotOutput(height = 250, 
                               outputId = "fragmentPlot2", 
                               #hover    = "fragmentPlot2_hover",
                               hover    = hoverOpts(
                                 id = "fragmentPlot2_hover",
                                 delay = 50, 
                                 delayType = "debounce"
                               ),
                               click    = "fragmentPlot2_click",
                               dblclick = "fragmentPlot2_dblclick",
                               #brush    = "fragmentPlot2_brush"
                               brush    = brushOpts(
                                 id = "fragmentPlot2_brush",
                                 resetOnNew = TRUE,
                                 direction = "x",
                                 delay = 00,
                                 delayType = "debounce"
                               )
                    ),
                    DT::dataTableOutput("ms1FeatureTableForAnnotation"),
                    fluidRow(
                      column(width = 6, style="width:50%",
                             div(style="float:left;width:100%",
                                 bsTooltip(id = "downloadMetaboliteFamilyConsensusSpectrum", title = "Download the consensus spectrum for the selected metabolite family", placement = "bottom", trigger = "hover"),
                                 downloadButton(outputId = "downloadMetaboliteFamilyConsensusSpectrum", label = "Download consensus spectrum"),
                                 tags$style(type='text/css', "#downloadMetaboliteFamilyConsensusSpectrum { width:100%}")
                             )
                      ),##column
                      column(width = 6, style="width:50%",
                             div(style="float:right;width:100%",
                                 bsTooltip(id = "downloadMetaboliteFamilyFilteredPrecursors", title = "Download a project file which is reduced to the filtered set of MS\u00B9 features", placement = "bottom", trigger = "hover"),
                                 downloadButton('downloadMetaboliteFamilyFilteredPrecursors', 'Download reduced project file'),
                                 tags$style(type='text/css', "#downloadMetaboliteFamilyFilteredPrecursors { width:100%}")
                             )
                      )##column
                    )##row
                  )##conditional
                )##well
              ),##conditional
              conditionalPanel(
                condition = "!output.showGUI",
                wellPanel(
                  h4("Please import a data file")
                )## well panel
              )## conditional panel
            ),## tab panel
            tabPanel(
              title = "Project", 
              conditionalPanel(
                condition = "output.showGUI",
                wellPanel(
                  h4("MetFamily project"),
                  fluidRow(
                    column(width = 6, div(style="float:left;width:100%",  
                                          h5("Project name")                           
                    )),##column
                    column(width = 6, div(style="float:right;width:100%", 
                                          bsTooltip(id = "projectName2", title = "The name of the project", placement = "bottom", trigger = "hover"),
                                          textInput(inputId = "projectName2", label = NULL, value = "", width = "100%")
                    ))##column
                  ),##row
                  fluidRow(
                    column(width = 6, div(style="float:left;width:100%",  
                                          h5("Project description")
                    )),##column
                    column(width = 6, div(style="float:right;width:100%", 
                                          bsTooltip(id = "projectDescription2", title = "Please update the description of this project as free text", placement = "bottom", trigger = "hover"),
                                          tags$style(type="text/css", "projectDescription2 {width:100%}"), 
                                          tags$textarea(id = 'projectDescription2', placeholder = 'Comments here', rows = 3, ""),
                                          bsTooltip(id = "updateProjectDescription", title = "Press to update the project description", placement = "bottom", trigger = "hover"),
                                          actionButton(inputId = "updateProjectDescription", label = "Update project description", class="btn-success", width = "100%")
                    ))##column
                  ),##row
                  fluidRow(
                    column(width = 6,
                           div(style="float:left",
                               h4("Data import parameters")
                           )
                    ),##column
                    column(width = 6,
                           div(style="float:right",
                               bsTooltip(id = "displayImportParameters", title = "Display parameters used for the initial data import", placement = "bottom", trigger = "hover"),
                               checkboxInput(inputId = "displayImportParameters", label = "Display import parameters", value = FALSE)
                           )
                    )##column
                  ),##row
                  conditionalPanel(
                    condition = "input.displayImportParameters",
                    h5("Fragment filter"),
                    fluidRow(
                      column(width = 6,
                             bsTooltip(id = "minimumIntensityOfMaximalMS2peak2", title = "A MS/MS spectrum is considered iff the MS/MS feature with maximum intensity is greater or equal than this value", placement = "bottom", trigger = "hover"),
                             textInput(inputId = "minimumIntensityOfMaximalMS2peak2", label = "Min. spectrum intensity", value = 2000)
                      ),##column
                      column(width = 6,
                             bsTooltip(id = "minimumProportionOfMS2peaks2", title = "A MS/MS feature is considered iff the intensity is greater or equal than the maximum intensity times this value", placement = "bottom", trigger = "hover"),
                             textInput(inputId = "minimumProportionOfMS2peaks2", label = "MS/MS peak proportion", value = 0.05)
                      )##column
                    ),##row
                    h5("Neutral losses"),
                    fluidRow(
                      column(width = 6,
                             bsTooltip(id = "neutralLossesPrecursorToFragments2", title = "Include neutral losses relative to the precursor ion, i.e. the m/z difference between the m/z of the precursor ion and the m/z of each fragment ion of the corresponding MS/MS spectrum", placement = "bottom", trigger = "hover"),
                             checkboxInput(inputId = "neutralLossesPrecursorToFragments2", label = "Fragment vs. precursor", value = TRUE)
                      ),##column
                      column(width = 6,
                             bsTooltip(id = "neutralLossesFragmentsToFragments2", title = "Include neutral losses amongst fragment ions, i.e. the m/z difference between the m/z values of all pairs of fragment ions within each MS/MS spectrum", placement = "bottom", trigger = "hover"),
                             checkboxInput(inputId = "neutralLossesFragmentsToFragments2", label = "Fragment vs. fragment", value = FALSE)
                      )##column
                    ),##row
                    h5("Fragment grouping"),
                    fluidRow(
                      column(width = 6,
                             bsTooltip(id = "mzDeviationAbsolute_grouping2", title = "A MS/MS feature is added to a fragment group if the absolute m/z difference is smaller or equal than this value", placement = "bottom", trigger = "hover"),
                             textInput(inputId = "mzDeviationAbsolute_grouping2", label = "m/z deviation (abs.)", value = 0.01)
                      ),##column
                      column(width = 6,
                             bsTooltip(id = "mzDeviationInPPM_grouping2", title = "A MS/MS feature is added to a fragment group if the absolute m/z difference is smaller or equal than the m/z times this value divided by 1,000,000 (<b>p</b>arts <b>p</b>er <b>m</b>illion)", placement = "bottom", trigger = "hover"),
                             textInput(inputId = "mzDeviationInPPM_grouping2", label = "m/z deviation (PPM)", value = 10)
                      )##column
                    ),##row
                    h4("Advanced parameters"),
                    h5("MS\u00B9 feature deisotoping"),
                    bsTooltip(id = "doPrecursorDeisotoping2", title = "If checked, the set of MS\u00B9 features is deisotoped", placement = "bottom", trigger = "hover"),
                    checkboxInput(inputId = "doPrecursorDeisotoping2", label = "MS\u00B9 feature deisotoping done", value = TRUE),
                    conditionalPanel(
                      condition = "input.doPrecursorDeisotoping2",
                      fluidRow(
                        column(width = 6,
                               bsTooltip(id = "mzDeviationAbsolute_precursorDeisotoping2", title = "A MS\u00B9 feature is considered an +1 isotopic peak if the absolute of the m/z difference to the (putative) monoisotopic peak minus 1.0033548378 (=<sup>13</sup>C - <sup>12</sup>C) is smaller or equal than this value (analog for the +2 isotopic peak)", placement = "bottom", trigger = "hover"),
                               textInput(inputId = "mzDeviationAbsolute_precursorDeisotoping2", label = "m/z deviation (abs.)", value = 0.01)
                        ),##column
                        column(width = 6,
                               bsTooltip(id = "mzDeviationInPPM_precursorDeisotoping2", title = "A MS\u00B9 feature is considered an +1 isotopic peak if the absolute of the m/z difference to the (putative) monoisotopic peak minus 1.0033548378 (=<sup>13</sup>C - <sup>12</sup>C) is smaller or equal than the m/z times this value divided by 1,000,000 (<b>p</b>arts <b>p</b>er <b>m</b>illion, analog for the +2 isotopic peak)", placement = "bottom", trigger = "hover"),
                               textInput(inputId = "mzDeviationInPPM_precursorDeisotoping2", label = "m/z deviation (PPM)", value = 10)
                        )##column
                      )##row
                    ),##conditional
                    bsTooltip(id = "maximumRtDifference2", title = "A MS\u00B9 feature is considered an isotopic peak if the absolute of the retention time difference to the (putative) monoisotopic peak is smaller or equal than this value (in minutes)", placement = "bottom", trigger = "hover"),
                    textInput(inputId = "maximumRtDifference2", label = "Retention time difference", value = 0.02),
                    h5("Fragment deisotoping"),
                    bsTooltip(id = "doMs2PeakGroupDeisotoping2", title = "If checked, the set of MS/MS features is deisotoped", placement = "bottom", trigger = "hover"),
                    checkboxInput(inputId = "doMs2PeakGroupDeisotoping2", label = "Fragment deisotoping done", value = TRUE),
                    conditionalPanel(
                      condition = "input.doMs2PeakGroupDeisotoping2",
                      fluidRow(
                        column(width = 6,
                               bsTooltip(id = "mzDeviationAbsolute_ms2PeakGroupDeisotoping2", title = "_A MS/MS feature is considered an +1 isotopic peak if the absolute of the m/z difference to the (putative) monoisotopic peak minus 1.0033548378 (=<sup>13</sup>C - <sup>12</sup>C) is smaller or equal than this value", placement = "bottom", trigger = "hover"),
                               textInput(inputId = "mzDeviationAbsolute_ms2PeakGroupDeisotoping2", label = "m/z deviation (abs.)", value = 0.01)
                        ),##column
                        column(width = 6,
                               bsTooltip(id = "mzDeviationInPPM_ms2PeakGroupDeisotoping2", title = "A MS/MS feature is considered an +1 isotopic peak if the absolute of the m/z difference to the (putative) monoisotopic peak minus 1.0033548378 (=<sup>13</sup>C - <sup>12</sup>C) is smaller or equal than the m/z times this value divided by 1,000,000 (<b>p</b>arts <b>p</b>er <b>m</b>illion)", placement = "bottom", trigger = "hover"),
                               textInput(inputId = "mzDeviationInPPM_ms2PeakGroupDeisotoping2", label = "m/z deviation (PPM)", value = 10)
                        )##column
                      )##row
                    )##conditional
                  ),##conditional
                  h4("Export"),
                  fluidRow(
                    column(width = 6, style="width:50%",
                           div(style="float:left;width:100%",
                               bsTooltip(id = "prepareAllPrecursors", title = "Download the full project file", placement = "bottom", trigger = "hover"),
                               actionButton("prepareAllPrecursors", "Project export", icon = icon("file-export", lib = "font-awesome"), style="width:100%"),
                               tags$style(type='text/css', "#downloadAllPrecursors { width:100%}")
                           )
                    ), #column
                    column(width = 6, style="width:50%",
                           div(style="float:right;width:100%",
                               bsTooltip(id = "downloadImportParameterSet", title = "Download a parameter file with the parameters which have been used for the initial data import", placement = "bottom", trigger = "hover"),
                               downloadButton(outputId = "downloadImportParameterSet", label = "Export import parameter set"),
                               tags$style(type='text/css', "#downloadImportParameterSet { width:100%}")
                           )
                    )##column
                  ),##row
                  br(),
                  fluidRow(
                    column(width = 6, style="width:50%",
                           div(style="float:left;width:100%",
                               bsTooltip(id = "downloadPcaImage", title = "Download the currently displayed PCA plots as image", placement = "bottom", trigger = "hover"),
                               downloadButton('downloadPcaImage', 'Export PCA as image'),
                               tags$style(type='text/css', "#downloadPcaImage { width:100%}")
                           )
                    ),##column
                    column(width = 6, style="width:50%",
                           div(style="float:right;width:100%",
                               bsTooltip(id = "downloadPcaImageType", title = "The user is able to download the PCA plot as image of different types: Portable Network Graphics (*.png) file, Scalable Vector Graphics (*.svg) file, Portable Document Format (*.pdf) file", placement = "bottom", trigger = "hover"),
                               radioButtons(inputId = "downloadPcaImageType", label = NULL, choices = c("png", "svg", "pdf"), selected = "png", inline = TRUE, width = "100%")
                           )
                    )##column
                  ),##row
                  br(),
                  fluidRow(
                    column(width = 6, style="width:50%",
                           div(style="float:left;width:100%",
                               bsTooltip(id = "downloadHcaImage", title = "Download the currently displayed HCA plots as image", placement = "bottom", trigger = "hover"),
                               downloadButton('downloadHcaImage', 'Export HCA as image'),
                               tags$style(type='text/css', "#downloadHcaImage { width:100%}")
                           )
                    ),##column
                    column(width = 6, style="width:50%",
                           div(style="float:right;width:100%",
                               bsTooltip(id = "downloadHcaImageType", title = "The user is able to download the HCA plot as image of different types: Portable Network Graphics (*.png) file, Scalable Vector Graphics (*.svg) file, Portable Document Format (*.pdf) file", placement = "bottom", trigger = "hover"),
                               radioButtons(inputId = "downloadHcaImageType", label = NULL, choices = c("png", "svg", "pdf"), selected = "png", inline = TRUE, width = "100%")
                           )
                    )##column
                  ),##row
                  br(),
                  fluidRow(
                    column(width = 6, style="width:50%",
                           div(style="float:left;width:100%",
                               bsTooltip(id = "downloadReport", title = "Download the currently displayed HCA plots and PCA plots as report", placement = "bottom", trigger = "hover"),
                               downloadButton('downloadReport', 'Export analysis report'),
                               tags$style(type='text/css', "#downloadReport { width:100%}")
                           )
                    ),##column
                    column(width = 6, style="width:50%",
                           div(style="float:right;width:100%"
                               ## nothing here
                           )
                    )##column
                  )##row
                )##well
              ),## conditional panel
              conditionalPanel(
                condition = "!output.showGUI",
                wellPanel(
                  h4("Please import a data file")
                )## well panel
              )## conditional panel
            )## tab panel
          )## tab set panel
        )## column
      ),##conditional
      ##############################################################################################
      ##############################################################################################
      ##############################################################################################
      ## plots
      #uiOutput("runRightColumn")
      source(file = "app_files/ui_rightColumn.R", local = TRUE)$value
    ),## tab
    ),
    ##########################################################################################
    ##########################################################################################
    ##########################################################################################
    ##########################################################################################
    ## tab about
    tabPanel(
      title = "About",
      ##############################################################################################
      ## intro
      wellPanel(
        h4(HTML("<b>MetFamily 1.0</b>")),
        fluidRow(
          column(width = 9,
                 helpText(
                   "The MetFamily web application is designed for the identification of regulated metabolite families. This is possible on the basis of metabolite profiles for a set of MS\u00B9 features as well as one MS/MS spectrum for each MS\u00B9 feature. Group-discriminating MS\u00B9 features are identified using a principal component analysis (PCA) of metabolite profiles and metabolite families are identified using a hierarchical cluster analysis (HCA) of MS/MS spectra. Regulated metabolite families are identified by considering group-discriminating MS\u00B9 features from corporate metabolite families."
                 )
          ),##column
          column(width = 3,
                 tags$a(imageOutput(outputId = "ipbImage", width = "100%", height = "100%"), href='http://www.ipb-halle.de/en/', target='_blank')
                 #HTML("<a href='http://www.ipb-halle.de/en/', target='_blank'><img src='logo_ipb_en.png' /></a>")
          )##column
        )## row
      ),## well panel
      wellPanel(
        h4(HTML("<b>Published in <a href='http://pubs.acs.org/doi/abs/10.1021/acs.analchem.6b01569', target='_blank'>Analytical Chemistry (ACS Publications)</a>:</b>")),
        br(),
        h5(HTML("<b>Discovering Regulated Metabolite Families in Untargeted Metabolomics Studies</b>")),
        p(HTML("Hendrik Treutler<sup>1</sup>, Hiroshi Tsugawa<sup>2</sup>, Andrea Porzel<sup>3</sup>, Karin Gorzolka<sup>1</sup>, Alain Tissier<sup>4</sup>, Steffen Neumann<sup>1</sup>, and Gerd Ulrich Balcke<sup>4*</sup>")), 
        p(HTML(paste(
          "<FONT SIZE=-1>",
          "<sup>1</sup>Leibniz Institute of Plant Biochemistry, Department of Stress and Developmental Biology, Weinberg 3, D-06120 Halle/Saale, Germany", "<br>",
          "<sup>2</sup>RIKEN Center for Sustainable Resource Science, Yokohama, Kanagawa 230-0045, Japan", "<br>",
          "<sup>3</sup>Leibniz Institute of Plant Biochemistry, Department of Bioorganic Chemistry, Weinberg 3, D-06120 Halle/Saale, Germany", "<br>",
          "<sup>4</sup>Leibniz Institute of Plant Biochemistry, Department of Cell and Metabolic Biology, Weinberg 3, D-06120 Halle/Saale, Germany", "<br>",
          "<sup>*</sup>Corresponding author: Gerd Ulrich Balcke <a href='mailto:Gerd.Balcke@ipb-halle.de?subject=MetFamily%20request'>Gerd.Balcke@ipb-halle.de</a>
          </FONT>", sep=""
        ))),
        br(),
        h5(HTML("<b>Abstract</b>")),
        p(HTML("The identification of metabolites by mass spectrometry constitutes a major bottleneck which considerably limits the throughput of metabolomics studies in biomedical or plant research. Here, we present a novel approach to analyze metabolomics data from untargeted, data-independent LC-MS/MS measurements. By integrated analysis of MS\u00B9 abundances and MS/MS spectra, the identification of regulated metabolite families is achieved. This approach offers a global view on metabolic regulation in comparative metabolomics. We implemented our approach in the web application “MetFamily”, which is freely available at http://msbi.ipb-halle.de/MetFamily/. MetFamily provides a dynamic link between the patterns based on MS\u00B9-signal intensity and the corresponding structural similarity at the MS/MS level. Structurally related metabolites are annotated as metabolite families based on a hierarchical cluster analysis of measured MS/MS spectra. Joint examination with principal component analysis of MS\u00B9 patterns, where this annotation is preserved in the loadings, facilitates the interpretation of comparative metabolomics data at the level of metabolite families. As a proof of concept, we identified two trichome-specific metabolite families from wild-type tomato Solanum habrochaites LA1777 in a fully unsupervised manner and validated our findings based on earlier publications and with NMR.")),
        br(),
        h5(HTML("<b>Cite</b>")),
        p(HTML(paste(
          "Hendrik Treutler, Hiroshi Tsugawa, Andrea Porzel, Karin Gorzolka, Alain Tissier, Steffen Neumann, and Gerd Ulrich U. Balcke.<br>",
          "Discovering Regulated Metabolite Families in Untargeted Metabolomics Studies.<br>",
          "Analytical chemistry, 88(16):8082-8090, August 2016.<br>",
          "<a href='https://dx.doi.org/10.1021/acs.analchem.6b01569', target='_blank'>doi:10.1021/acs.analchem.6b01569</a>", 
          sep = "")))
      ),## well panel
      wellPanel(
        h4(HTML("<b>Documentation</b>")),
        p(HTML("Please find a user guide for the usage of the MetFamily web application below. ")),
        bsTooltip(id = "downloadDocUserGuide", title = "Download the user guide for the MetFamily web application", placement = "bottom", trigger = "hover"),
        downloadButton('downloadDocUserGuide', 'Download user guide'),
        p(HTML("We provide a specification of the input file format. In the MetFamily publication we demonstrated the usage of MetFamily with UPLC-(-)ESI-SWATH-MS/MS data preprocessed with <a href='http://prime.psc.riken.jp/Metabolomics_Software/MS-DIAL/', target='_blank'>MS-DIAL</a>. In the input specification, however, we demonstrate the generation of these files with GC-EI-MS data processed with <a href='https://bioconductor.org/packages/release/bioc/html/xcms.html', target='_blank'>xcms</a> and <a href='https://bioconductor.org/packages/release/bioc/html/CAMERA.html', target='_blank'>CAMERA</a> We also analyzed idMSMS spectra and LC-MS/MS spectra from DDA in MetFamily.")),
        bsTooltip(id = "downloadDocInputSpecification", title = "Download the input specification of the MetFamily web application", placement = "bottom", trigger = "hover"),
        downloadButton('downloadDocInputSpecification', 'Download input specification')
      ),## well panel
      wellPanel(
        h4(HTML("<b>Feedback</b>")),
        p(HTML("The MetFamily web application is designed to support researchers in the interpretation of comparative metabolomics studies at the level of metabolite families. Please help to improve this tool by comments, bug reports, and feature requests. You can contact Dr. Gerd Balcke via <a href='mailto:Gerd.Balcke@ipb-halle.de?subject=MetFamily'>EMail</a> and <a href='https://github.com/Treutler/MetFamily/issues/new', target='_blank'>issues</a> on GitHub."))
      ),## well panel
      wellPanel(
        h4(HTML("<b>Session info</b>")),
        verbatimTextOutput(outputId = "rInfo")
      )## well panel
    )## tab
  )#,## navBar
  # Application footer
  #fluidRow(ipbfooter)
  #)## fluidPage
)## shinyUI

================
File: inst/MetFamily/version.R
================
## MetFamily properties

toolName       <- "MetFamily"
toolVersion    <- "1.0"    
metFamilyAppVersion <- "1.3.4"

packageVersion <- package.version("MetFamily")

================
File: man/calcPlotDendrogram_plotly.Rd
================
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Plots.R
\name{calcPlotDendrogram_plotly}
\alias{calcPlotDendrogram_plotly}
\title{Title}
\usage{
calcPlotDendrogram_plotly(
  dataList,
  filterObj,
  clusterDataList,
  distanceMeasure,
  showClusterLabels,
  hcaPrecursorLabels,
  selectionFragmentTreeNodeSet = NULL,
  selectionAnalysisTreeNodeSet = NULL,
  selectionSearchTreeNodeSet = NULL,
  selectedSelection,
  heatmapContent,
  heatmapOrdering,
  heatmapProportion
)
}
\arguments{
\item{dataList}{}

\item{filterObj}{}

\item{clusterDataList}{}

\item{distanceMeasure}{}

\item{showClusterLabels}{}

\item{hcaPrecursorLabels}{}

\item{selectionFragmentTreeNodeSet}{}

\item{selectionAnalysisTreeNodeSet}{}

\item{selectionSearchTreeNodeSet}{}

\item{selectedSelection}{}

\item{heatmapContent}{}

\item{heatmapOrdering}{}

\item{heatmapProportion}{}
}
\description{
Title
}

================
File: man/calcPlotHeatmapLegend.Rd
================
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Plots.R
\name{calcPlotHeatmapLegend}
\alias{calcPlotHeatmapLegend}
\title{Title}
\usage{
calcPlotHeatmapLegend(dataList)
}
\arguments{
\item{dataList}{}
}
\description{
Title
}

================
File: man/castListEntries.Rd
================
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/DataProcessing.R
\name{castListEntries}
\alias{castListEntries}
\title{Cast logical's and numeric's in a list or data.frame}
\usage{
castListEntries(list)
}
\arguments{
\item{list}{}
}
\value{
list of the same lenght with logical's and numeric's casted
}
\description{
Tries to cast a list entry (or column in a data.frame) to logical's, 
if that does not create any missing values, it is assumed 
to be a logical will be replaced by `as.logical()` conversion.
Similarly for numeric entries (or columns). Everything else remains strings
}

================
File: man/data.numericmatrix.Rd
================
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/DataProcessing.R
\name{data.numericmatrix}
\alias{data.numericmatrix}
\title{Convert data.frame columns to numeric}
\usage{
data.numericmatrix(x)
}
\arguments{
\item{x}{The data.frame to convert}
}
\value{
A matrix with all columns converted to numeric
}
\description{
The data.numericmatrix() function works similar to base::data.matrix()
before R-4.0.0 converting character columns to numeric without converting 
to factor first, thus returning the actual numeric values.
}
\examples{
data.numericmatrix(data.frame(a = c("1", "2", "3"), 
                              b = c("4", "5", "6")))

}

================
File: man/metaboliteFamilyVersusClass.Rd
================
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Annotation.R
\name{metaboliteFamilyVersusClass}
\alias{metaboliteFamilyVersusClass}
\title{Title}
\usage{
metaboliteFamilyVersusClass(
  dataList,
  precursorSet,
  classToSpectra_class,
  properties_class,
  classifierClass,
  mappingSpectraToClassDf,
  addClassifierConsensusSpectrum
)
}
\arguments{
\item{dataList}{}

\item{precursorSet}{}

\item{classToSpectra_class}{}

\item{properties_class}{}

\item{classifierClass}{}

\item{mappingSpectraToClassDf}{}

\item{addClassifierConsensusSpectrum}{}
}
\description{
Title
}

================
File: man/mzClustGeneric.Rd
================
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/FragmentMatrixFunctions.R
\name{mzClustGeneric}
\alias{mzClustGeneric}
\title{Alignment of high resolution mass spectra}
\usage{
mzClustGeneric(
  p,
  sampclass = NULL,
  mzppm = 20,
  mzabs = 0,
  minsamp = 1,
  minfrac = 0.5,
  progress = FALSE
)
}
\arguments{
\item{p}{}

\item{sampclass}{}

\item{mzppm}{}

\item{mzabs}{}

\item{minsamp}{}

\item{minfrac}{}

\item{progress}{}
}
\description{
adapted from R package xcms: xcms_1.44.0, package path: R/mzClust.R
Reference: 
Alignment of high resolution mass spectra: development of a heuristic approach for metabolomics
Metabolomics June 2006, Volume 2, Issue 2, pp 75-83
http://link.springer.com/article/10.1007%2Fs11306-006-0021-7
}

================
File: man/processMS1data.Rd
================
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/DataProcessing.R
\name{processMS1data}
\alias{processMS1data}
\title{Process MS-Dial-like MS1 data.frame}
\usage{
processMS1data(
  sampleNamesToExclude,
  numberOfMS1features,
  precursorLabels,
  grouXXXps,
  metaboliteProfileColumnNames,
  dataColumnIndecesFunctionFromGroupIndex,
  dataColumnsNameFunctionFromGroupIndex,
  dataColumnsNameFunctionFromGroupName,
  dataColumnsNameFunctionFromGroupNames,
  groupNameFunctionFromDataColumnName,
  tagsSector,
  metaboliteProfile,
  progress = FALSE
)
}
\arguments{
\item{sampleNamesToExclude}{}

\item{numberOfMS1features}{}

\item{precursorLabels}{}

\item{grouXXXps}{}

\item{metaboliteProfileColumnNames}{}

\item{dataColumnIndecesFunctionFromGroupIndex}{}

\item{dataColumnsNameFunctionFromGroupIndex}{}

\item{dataColumnsNameFunctionFromGroupName}{}

\item{dataColumnsNameFunctionFromGroupNames}{}

\item{groupNameFunctionFromDataColumnName}{}

\item{tagsSector}{}

\item{metaboliteProfile}{}

\item{progress}{}
}
\description{
Processing of MS-Dial-like MS1 data.frame. Includes calculation 
of MS1 data mean and log-fold-change (LFC) data
}

================
File: man/readClusterDataFromProjectFile.Rd
================
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/DataProcessing.R
\name{readClusterDataFromProjectFile}
\alias{readClusterDataFromProjectFile}
\title{Read MetFamily Project data saved by the export function}
\usage{
readClusterDataFromProjectFile(file, progress = FALSE)
}
\arguments{
\item{file}{Path to file to read}

\item{progress}{Whether to update a shiny Progress bar}
}
\value{
A big dataList.
}
\description{
Supports reading from plain and gzip'ed files
}
\seealso{
[readProjectData]
}

================
File: man/readProjectData.Rd
================
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/DataProcessing.R
\name{readProjectData}
\alias{readProjectData}
\title{Read MetFamily Project data saved by the export function}
\usage{
readProjectData(fileLines, progress = FALSE)
}
\arguments{
\item{fileLines}{Character vector with content of a project file}

\item{progress}{Whether to update a shiny Progress bar}
}
\value{
A big dataList.
}
\description{
Read MetFamily Project data saved by the export function
}
\seealso{
[processMS1data]
}

================
File: man/runMetFamily.Rd
================
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/runMetFamily.R
\name{runMetFamily}
\alias{runMetFamily}
\title{Start the web app in browser}
\usage{
runMetFamily()
}
\description{
Run the web app in browser
}
\examples{
\dontrun{
runMetFamily()
}
}
\author{
Hendrik Treutler, Steffen Neumann
}

================
File: R/Analysis.R
================
#########################################################################################
## constants
filterData <- function(dataList, grouXXXps, sampleSet, filterBySamples, filter_average, filter_lfc, filterList_ms2_masses, filter_ms2_ppm, filter_ms1_masses, filter_ms1_ppm, includeIgnoredPrecursors, progress = FALSE){
  ##########################################
  ## filter
  filter <- rep(x = TRUE, times = dataList$numberOfPrecursors)
  
  ## filter_average
  if(!is.null(filter_average)){
    #print("this is entering the line 11")
    #if(filterBySamples){
    #  filter <- filter & apply(X = as.data.frame(dataList$dataFrameMeasurements[, sapply(X = as.vector(grouXXXps), FUN = dataList$dataMeanColumnNameFunctionFromName)]), MARGIN = 1, FUN = mean) >= filter_average
    #} else {
      filter <- filter & apply(X = as.data.frame(dataList$dataFrameMeasurements[, sapply(X = as.vector(grouXXXps), FUN = dataList$dataMeanColumnNameFunctionFromName)]), MARGIN = 1, FUN = mean) >= filter_average
      #print(filter)
      #print(names(filter)[unname(filter)])
    #}
  }
  
  ## filter_lfc
  if(!is.null(filter_lfc)){
    if(filter_lfc != 0){
      if(length(grouXXXps) != 2){  stop("The number of grouXXXps for LFC is not equal to two!") }
      if(filter_lfc > 0)
        filter <- filter & dataList$dataFrameMeasurements[, dataList$lfcColumnNameFunctionFromName(grouXXXps[[1]], grouXXXps[[2]])] >= filter_lfc
      else
        filter <- filter & dataList$dataFrameMeasurements[, dataList$lfcColumnNameFunctionFromName(grouXXXps[[1]], grouXXXps[[2]])] <= filter_lfc
    }
  }
  
  ## filter_ms2_masses, filter_ms2_ppm
  if(!is.null(filterList_ms2_masses) & !is.null(filter_ms2_ppm) & length(filterList_ms2_masses) > 0){
    error <- abs(dataList$fragmentMasses) * filter_ms2_ppm / 1E6
    filterFragmentLists <- rep(x = FALSE, times = dataList$numberOfPrecursors)
    for(filter_ms2_masses in filterList_ms2_masses){
      filterTempFragmentList <- rep(x = TRUE, times = dataList$numberOfPrecursors)
      for(fragmentIndex in seq_len(length(filter_ms2_masses))){
        distances <- abs(dataList$fragmentMasses - filter_ms2_masses[[fragmentIndex]])
        filterTempFragment <- rep(x = FALSE, times = dataList$numberOfPrecursors)
        
        ## set of fragment columns which are conjunct by or
        columns <- which(distances <= error)
        #columns <- which.min(distances <= error)
        for(column in columns)
          filterTempFragment <- filterTempFragment | dataList$featureMatrix[, column] != 0
        
        ## set of fragemnt masses which are conjunct by and
        filterTempFragmentList <- filterTempFragmentList & filterTempFragment
      }
      
      ## set of mass lists which are conjunct by or
      filterFragmentLists <- filterFragmentLists | filterTempFragmentList
    }
    filter <- filter & filterFragmentLists
  }
  
  ## filter_ms1_masses, filter_ms1_ppm
  if(!is.null(filter_ms1_masses) & !is.null(filter_ms1_ppm) & length(filter_ms1_masses) > 0){
    precursorMasses <- as.numeric(dataList$dataFrameInfos$"m/z")
    error <- precursorMasses * filter_ms1_ppm / 1E6
    
    filterMS1masses <- rep(x = FALSE, times = dataList$numberOfPrecursors)
    for(precursorMassIndex in seq_len(length(filter_ms1_masses))){
      distances <- abs(precursorMasses - filter_ms1_masses[[precursorMassIndex]])
      filterPart <- distances <= error
      filterPart[is.na(filterPart)] <- FALSE
      filterMS1masses <- filterMS1masses | filterPart
    }
    filter <- filter & filterMS1masses
  }
  
  ## include ignored precursors
  if(!includeIgnoredPrecursors)
    filter <- filter & !dataList$annoArrayIsArtifact
  
  filter <- which(filter)
  
  resultObj <- list()
  resultObj$filter <- filter
  resultObj$numberOfPrecursors <- dataList$numberOfPrecursors
  resultObj$numberOfPrecursorsFiltered <- length(filter)
  if(is.null(grouXXXps)){
    resultObj$grouXXXps    <- list()
    resultObj$sampleSet <- list()
    resultObj$filterBySamples <- NA
  } else {
    resultObj$grouXXXps    <- grouXXXps
    resultObj$sampleSet <- sampleSet
    resultObj$filterBySamples <- filterBySamples
  }
  #resultObj$grouXXXps                   <- ifelse(test = is.null(grouXXXps),                   yes = NA, no = grouXXXps)
  resultObj$filter_average           <- ifelse(test = is.null(filter_average),           yes = 0, no = filter_average)
  resultObj$filter_lfc               <- ifelse(test = is.null(filter_lfc),               yes = 0, no = filter_lfc)
  if(is.null(filterList_ms2_masses)){
    resultObj$filterList_ms2_masses    <- list()
  } else {
    resultObj$filterList_ms2_masses    <- filterList_ms2_masses
  }
  #resultObj$filterList_ms2_masses    <- ifelse(test = is.null(filterList_ms2_masses),    yes = list(), no = filterList_ms2_masses)
  resultObj$filter_ms2_ppm           <- ifelse(test = is.null(filter_ms2_ppm),           yes = "", no = filter_ms2_ppm)
  if(is.null(filter_ms1_masses)){
    resultObj$filter_ms1_masses    <- list()
  } else {
    resultObj$filter_ms1_masses    <- filter_ms1_masses
  }
  #resultObj$filter_ms1_masses        <- ifelse(test = is.null(filter_ms1_masses),        yes = "", no = filter_ms1_masses)
  resultObj$filter_ms1_ppm           <- ifelse(test = is.null(filter_ms1_ppm),           yes = "", no = filter_ms1_ppm)
  resultObj$includeIgnoredPrecursors <- ifelse(test = is.null(includeIgnoredPrecursors), yes = NA, no = includeIgnoredPrecursors)
  
  return (resultObj)
}
calculateDistanceMatrix <- function(dataList, filter, distanceMeasure = "Jaccard", progress = FALSE){
  numberOfPrecursors <- length(filter)
  
  if(!is.na(progress))  if(progress)  incProgress(amount = 0, detail = paste("Distances 0 / ", numberOfPrecursors, sep = ""))
  ## compute distance matrix:
  lastOut <- proc.time()["user.self"]
  lastPrecursor <- 1
  
  distanceMatrix <- NULL
  switch(distanceMeasure,
         "Jaccard"={
           featureIndeces <- dataList$featureIndeces[filter]
           
           distanceMatrix <- matrix(nrow = numberOfPrecursors, ncol = numberOfPrecursors)
           for(i in seq_len(numberOfPrecursors)){
             time <- proc.time()["user.self"]
             if(time - lastOut > 1){
               lastOut <- time
               precursorProgress <- (i - lastPrecursor) / numberOfPrecursors
               lastPrecursor <- i
               if(!is.na(progress))  if(progress)  incProgress(amount = precursorProgress,     detail = paste("Distance ", i, " / ", numberOfPrecursors, sep = "")) else print(paste("Distance ", i, " / ", numberOfPrecursors, sep = ""))
             }
             #if(numberOfPrecursors >= 10 & ((i %% (as.integer(numberOfPrecursors/10))) == 0))
             #  if(progress)  incProgress(amount = 1 / 10, detail = paste("Distances ", i, " / ", numberOfPrecursors, sep = ""))
             for(j in seq_len(numberOfPrecursors)){
               if(i == j){
                 distanceMatrix[i, j] <- 0
                 next
               }
               
               #distanceMatrix[i, j] <- 1 - length(which(featureMatrixBinary[i, ] & featureMatrixBinary[j, ])) / length(which(featureMatrixBinary[i, ] | featureMatrixBinary[j, ]))
               #distanceMatrix[i, j] <- 1 - sum(featureMatrixBinary[i, ] & featureMatrixBinary[j, ]) / sum(featureMatrixBinary[i, ] | featureMatrixBinary[j, ])
               
               intersectionCount <- sum(featureIndeces[[i]] %in% featureIndeces[[j]])
               distanceMatrix[i, j] <- 1 - intersectionCount / (length(featureIndeces[[i]]) + length(featureIndeces[[j]]) - intersectionCount)
             }
           }
         },
         "Jaccard (intensity-weighted pure)"={
           featureIndeces <- dataList$featureIndeces[filter]
           featureMatrix <- dataList$featureMatrix[filter, ]
           
           distanceMatrix <- matrix(nrow = numberOfPrecursors, ncol = numberOfPrecursors)
           for(i in seq_len(numberOfPrecursors)){
             time <- proc.time()["user.self"]
             if(time - lastOut > 1){
               lastOut <- time
               precursorProgress <- (i - lastPrecursor) / numberOfPrecursors
               lastPrecursor <- i
               if(!is.na(progress))  if(progress)  incProgress(amount = precursorProgress,     detail = paste("Distance ", i, " / ", numberOfPrecursors, sep = "")) else print(paste("Distance ", i, " / ", numberOfPrecursors, sep = ""))
             }
             for(j in seq_len(numberOfPrecursors)){
               if(i == j){
                 distanceMatrix[i, j] <- 0
                 next
               }
               
               intersection <- intersect(x = featureIndeces[[i]], y = featureIndeces[[j]])
               
               onlyI <- setdiff(x = featureIndeces[[i]], y = intersection)
               onlyJ <- setdiff(x = featureIndeces[[j]], y = intersection)
               sumOnlyI <- sum(featureMatrix[i, onlyI])
               sumOnlyJ <- sum(featureMatrix[j, onlyJ])
               
               relevance  <- apply(X = as.matrix(featureMatrix[, intersection]), MARGIN = 2, FUN = function(x) {max(x[i], x[j])})
               similarity <- 1 - abs(featureMatrix[i, intersection] - featureMatrix[j, intersection]) / relevance
               intersectionSum <- sum(relevance * similarity)
               unionSum <- intersectionSum + sumOnlyI + sumOnlyJ
               
               distanceMatrix[i, j] <- 1 - intersectionSum / unionSum
             }
           }
         },
         "Jaccard (intensity-weighted map) exp"={
           ## intersection i and j: featureIndeces[[i]][featureIndeces[[i]] %in% featureIndeces[[j]]]
           ## diff i - j: featureIndeces[[i]][!featureIndeces[[i]] %in% featureIndeces[[j]]]
           ## diff j - i: featureIndeces[[j]][!featureIndeces[[j]] %in% featureIndeces[[i]]]
           ## union i or j: c(featureIndeces[[i]][!featureIndeces[[i]] %in% featureIndeces[[j]]], featureIndeces[[j]])
           featureIndeces <- dataList$featureIndeces[filter]
           featureMatrix <- dataList$featureMatrix[filter, ]
           featureMatrix[featureMatrix <  0.2 & featureMatrix >= 0.01] <- 0.01
           featureMatrix[featureMatrix <  0.4 & featureMatrix >= 0.20] <- 0.2
           featureMatrix[featureMatrix >= 0.4] <- 1
           featureMatrix <- as.matrix(featureMatrix)
           featureMatrixBinary <- dataList$featureMatrixBinary[filter, ]
           
           "%ni%" = Negate("%in%")
           
           distanceMatrix <- matrix(nrow = numberOfPrecursors, ncol = numberOfPrecursors)
           for(i in seq_len(numberOfPrecursors)){
             time <- proc.time()["user.self"]
             if(time - lastOut > 1){
               lastOut <- time
               precursorProgress <- (i - lastPrecursor) / numberOfPrecursors
               lastPrecursor <- i
               if(!is.na(progress))  if(progress)  incProgress(amount = precursorProgress,     detail = paste("Distance ", i, " / ", numberOfPrecursors, sep = "")) else print(paste("Distance ", i, " / ", numberOfPrecursors, sep = ""))
             }
             
             featureMatrixBinaryHere <- t(featureMatrixBinary)
             
             ## intersecting features
             intersections <- featureMatrixBinary[i, ] & featureMatrixBinaryHere
             onlyIs <- featureMatrixBinary[i, ] & (!featureMatrixBinaryHere)
             onlyJs <- featureMatrixBinaryHere  & (!featureMatrixBinary[i, ])
             
             onlyIs[is.na(onlyIs)] <- FALSE
             onlyJs[is.na(onlyJs)] <- FALSE
             
             sumOnlyIs  <- apply(X = onlyIs, MARGIN = 2, FUN = function(x){ sum(featureMatrix[i, ] & x) })
             #sumOnlyIs <- apply(X = onlyIs, MARGIN = 2, FUN = function(x){ sum(featureMatrix[i, x]) })
             featureMatrix2 <- featureMatrix
             featureMatrix2[!t(onlyJs)] <- 0
             sumOnlyJs <- apply(X = featureMatrix2, MARGIN = 1, FUN = sum )
             
             featureMatrix2 <- featureMatrix
             featureMatrix2[!t(intersections)] <- 0
             intersectionSums <- apply(X = featureMatrix2, MARGIN = 1, FUN = sum )
             
             unionSums <- intersectionSums + sumOnlyIs + sumOnlyJs
             distances <- 1 - intersectionSums / unionSums
             
             distanceMatrix[i, ] <- distances
           }
         },
         "Jaccard (intensity-weighted)"={
           ## map the fragment intensities to three intensity categories and compute distance from intensity categories of intersecting / all fragments
           ## 
           ## intersection i and j: featureIndeces[[i]][featureIndeces[[i]] %in% featureIndeces[[j]]]
           ## diff i - j: featureIndeces[[i]][!featureIndeces[[i]] %in% featureIndeces[[j]]]
           ## diff j - i: featureIndeces[[j]][!featureIndeces[[j]] %in% featureIndeces[[i]]]
           ## union i or j: c(featureIndeces[[i]][!featureIndeces[[i]] %in% featureIndeces[[j]]], featureIndeces[[j]])
           featureIndeces <- dataList$featureIndeces[filter]
           featureMatrix <- dataList$featureMatrix[filter, ]
           featureMatrix[featureMatrix <  0.2 & featureMatrix >= 0.01] <- 0.01
           featureMatrix[featureMatrix <  0.4 & featureMatrix >= 0.20] <- 0.2
           featureMatrix[featureMatrix >= 0.4] <- 1
           featureMatrix <- as.matrix(featureMatrix)
           # intensityMapping <- function(x){
           #   if(x == 0){
           #     ## x = 0
           #     return(0)
           #   } else if(x < 0.2){
           #     ## 0 <= x < 0.2
           #     return(0.01)
           #   } else if(x < 0.4){
           #     ## 0.2 <= x < 0.4
           #     return(0.2)
           #   } else {
           #     ## 0.4 <= x <= Inf
           #     return(1)
           #   }
           # }
           # intensityMapping <- Vectorize(FUN = intensityMapping, vectorize.args = "x")
           
           distanceMatrix <- matrix(nrow = numberOfPrecursors, ncol = numberOfPrecursors)
           for(i in seq_len(numberOfPrecursors)){
             time <- proc.time()["user.self"]
             if(time - lastOut > 1){
               lastOut <- time
               precursorProgress <- (i - lastPrecursor) / numberOfPrecursors
               lastPrecursor <- i
               if(!is.na(progress))  if(progress)  incProgress(amount = precursorProgress,     detail = paste("Distance ", i, " / ", numberOfPrecursors, sep = "")) else print(paste("Distance ", i, " / ", numberOfPrecursors, sep = ""))
             }
             for(j in seq_len(numberOfPrecursors)){
               if(i == j){
                 distanceMatrix[i, j] <- 0
                 next
               }
               
               ## intersecting features
               intersection <- featureIndeces[[i]][featureIndeces[[i]] %in% featureIndeces[[j]]]
               
               if(length(intersection) == 0){
                 ## max distance
                 distance <- 1#sumOnlyI + sumOnlyJ
               } else {
                 onlyI <- featureIndeces[[i]][!featureIndeces[[i]] %in% featureIndeces[[j]]]
                 onlyJ <- featureIndeces[[j]][!featureIndeces[[j]] %in% featureIndeces[[i]]]
                 
                 if(length(onlyI) == 0){
                   sumOnlyI <- 0
                 } else {
                   sumOnlyI <- sum(featureMatrix[i, onlyI, drop = FALSE])
                 }
                 if(length(onlyJ) == 0){
                   sumOnlyJ <- 0
                 } else {
                   sumOnlyJ <- sum(featureMatrix[j, onlyJ, drop = FALSE])
                 }
                 
                 #maxIntensity <- apply(X = as.matrix(featureMatrix[c(i, j), intersection, drop = FALSE]), MARGIN = 2, FUN = max)
                 maxIntensity <- apply(X = featureMatrix[c(i, j), intersection, drop = FALSE], MARGIN = 2, FUN = max)
                 #maxIntensity <- featureMatrix[i, intersection]
                 intersectionSum <- sum(maxIntensity)
                 unionSum <- intersectionSum + sumOnlyI + sumOnlyJ
                 distance <- 1 - intersectionSum / unionSum
               }
               
               distanceMatrix[i, j] <- distance
             }
           }
         },
         "Jaccard (intensity-weighted map) saveOld"={
           ## intersection i and j: featureIndeces[[i]][featureIndeces[[i]] %in% featureIndeces[[j]]]
           ## diff i - j: featureIndeces[[i]][!featureIndeces[[i]] %in% featureIndeces[[j]]]
           ## diff j - i: featureIndeces[[j]][!featureIndeces[[j]] %in% featureIndeces[[i]]]
           ## union i or j: c(featureIndeces[[i]][!featureIndeces[[i]] %in% featureIndeces[[j]]], featureIndeces[[j]])
           featureIndeces <- dataList$featureIndeces[filter]
           featureMatrix <- dataList$featureMatrix[filter, ]
           intensityMapping <- function(x){
             if(x == 0){
               ## x = 0
               return(0)
             } else if(x < 0.2){
               ## 0 <= x < 0.2
               return(0.01)
             } else if(x < 0.4){
               ## 0.2 <= x < 0.4
               return(0.2)
             } else {
               ## 0.4 <= x <= Inf
               return(1)
             }
           }
           intensityMapping <- Vectorize(FUN = intensityMapping, vectorize.args = "x")
           
           distanceMatrix <- matrix(nrow = numberOfPrecursors, ncol = numberOfPrecursors)
           for(i in seq_len(numberOfPrecursors)){
             time <- proc.time()["user.self"]
             if(time - lastOut > 1){
               lastOut <- time
               precursorProgress <- (i - lastPrecursor) / numberOfPrecursors
               lastPrecursor <- i
               if(!is.na(progress))  if(progress)  incProgress(amount = precursorProgress,     detail = paste("Distance ", i, " / ", numberOfPrecursors, sep = "")) else print(paste("Distance ", i, " / ", numberOfPrecursors, sep = ""))
             }
             for(j in seq_len(numberOfPrecursors)){
               if(i == j){
                 distanceMatrix[i, j] <- 0
                 next
               }
               
               intersection <- featureIndeces[[i]][featureIndeces[[i]] %in% featureIndeces[[j]]]
               
               if(length(intersection) == 0){
                 distance <- 1#sumOnlyI + sumOnlyJ
               } else {
                 onlyI <- featureIndeces[[i]][!featureIndeces[[i]] %in% featureIndeces[[j]]]
                 onlyJ <- featureIndeces[[j]][!featureIndeces[[j]] %in% featureIndeces[[i]]]
                 
                 if(length(onlyI) == 0){
                   sumOnlyI <- 0
                 } else {
                   sumOnlyI <- sum(sapply(X = featureMatrix[i, onlyI], FUN = intensityMapping))
                 }
                 if(length(onlyJ) == 0){
                   sumOnlyJ <- 0
                 } else {
                   sumOnlyJ <- sum(sapply(X = featureMatrix[j, onlyJ], FUN = intensityMapping))
                 }
                 
                 maxIntensity <- apply(X = as.matrix(featureMatrix[c(i, j), intersection]), MARGIN = 2, FUN = max)
                 intersectionSum <- sum(sapply(X = maxIntensity, FUN = intensityMapping))
                 unionSum <- intersectionSum + sumOnlyI + sumOnlyJ
                 distance <- 1 - intersectionSum / unionSum
               }
               
               distanceMatrix[i, j] <- distance
             }
           }
         },
         "Similarity (intensity-weighted)"={
           featureIndeces <- dataList$featureIndeces[filter]
           featureMatrix <- as.matrix(dataList$featureMatrix[filter, ])
           
           similarityMatrix <- matrix(nrow = numberOfPrecursors, ncol = numberOfPrecursors)
           for(i in seq_len(numberOfPrecursors)){
             time <- proc.time()["user.self"]
             if(time - lastOut > 1){
               lastOut <- time
               precursorProgress <- (i - lastPrecursor) / numberOfPrecursors
               lastPrecursor <- i
               if(!is.na(progress))  if(progress)  incProgress(amount = precursorProgress,     detail = paste("Distance ", i, " / ", numberOfPrecursors, sep = "")) else print(paste("Distance ", i, " / ", numberOfPrecursors, sep = ""))
             }
             for(j in seq_len(numberOfPrecursors)){
               if(i == j){
                 similarityMatrix[i, j] <- 0
                 next
               }
               
               intersection <- intersect(x = featureIndeces[[i]], y = featureIndeces[[j]])
               relevance  <- apply(X = as.matrix(featureMatrix[, intersection]), MARGIN = 2, FUN = function(x) {max(x[i], x[j])})
               similarity <- 1 - abs(featureMatrix[i, intersection] - featureMatrix[j, intersection]) / relevance
               intersectionSum <- sum(relevance * similarity)
               
               similarityMatrix[i, j] <- intersectionSum
             }
           }
           distanceMatrix <- max(similarityMatrix) - similarityMatrix
         },
         "Jaccard (intensity-fragment-count-weighted)"={
           featureIndeces <- dataList$featureIndeces[filter]
           featureMatrix <- as.matrix(dataList$featureMatrix[filter, ])
           fragmentFrequency <- dataList$fragmentFrequency
           
           distanceMatrix <- matrix(nrow = numberOfPrecursors, ncol = numberOfPrecursors)
           for(i in seq_len(numberOfPrecursors)){
             time <- proc.time()["user.self"]
             if(time - lastOut > 1){
               lastOut <- time
               precursorProgress <- (i - lastPrecursor) / numberOfPrecursors
               lastPrecursor <- i
               if(!is.na(progress))  if(progress)  incProgress(amount = precursorProgress,     detail = paste("Distance ", i, " / ", numberOfPrecursors, sep = "")) else print(paste("Distance ", i, " / ", numberOfPrecursors, sep = ""))
             }
             for(j in seq_len(numberOfPrecursors)){
               if(i == j){
                 distanceMatrix[i, j] <- 0
                 next
               }
               
               intersection <- intersect(x = featureIndeces[[i]], y = featureIndeces[[j]])
               
               onlyI <- setdiff(x = featureIndeces[[i]], y = intersection)
               onlyJ <- setdiff(x = featureIndeces[[j]], y = intersection)
               sumOnlyI <- sum(featureMatrix[i, onlyI] * fragmentFrequency[onlyI])
               sumOnlyJ <- sum(featureMatrix[j, onlyJ] * fragmentFrequency[onlyJ])
               
               relevance  <- apply(X = as.matrix(featureMatrix[c(i, j), intersection]), MARGIN = 2, FUN = max)
               similarity <- 1 - abs(featureMatrix[i, intersection] - featureMatrix[j, intersection]) / relevance
               relevance2 <- fragmentFrequency[intersection]
               intersectionSum <- sum(relevance * relevance2 * similarity)
               unionSum <- intersectionSum + sumOnlyI + sumOnlyJ
               
               distanceMatrix[i, j] <- 1 - intersectionSum / unionSum
             }
           }
         },
         "Similarity (intensity-fragment-count-weighted)"={
           featureIndeces <- dataList$featureIndeces[filter]
           featureMatrix <- as.matrix(dataList$featureMatrix[filter, ])
           fragmentFrequency <- dataList$fragmentFrequency
           
           similarityMatrix <- matrix(nrow = numberOfPrecursors, ncol = numberOfPrecursors)
           for(i in seq_len(numberOfPrecursors)){
             time <- proc.time()["user.self"]
             if(time - lastOut > 1){
               lastOut <- time
               precursorProgress <- (i - lastPrecursor) / numberOfPrecursors
               lastPrecursor <- i
               if(!is.na(progress))  if(progress)  incProgress(amount = precursorProgress,     detail = paste("Distance ", i, " / ", numberOfPrecursors, sep = "")) else print(paste("Distance ", i, " / ", numberOfPrecursors, sep = ""))
             }
             for(j in seq_len(numberOfPrecursors)){
               if(i == j){
                 similarityMatrix[i, j] <- 0
                 next
               }
               
               intersection <- intersect(x = featureIndeces[[i]], y = featureIndeces[[j]])
               relevance  <- apply(X = as.matrix(featureMatrix[, intersection]), MARGIN = 2, FUN = function(x) {max(x[i], x[j])})
               similarity <- 1 - abs(featureMatrix[i, intersection] - featureMatrix[j, intersection]) / relevance
               relevance2 <- fragmentFrequency[intersection]
               intersectionSum <- sum(relevance * relevance2 * similarity)
               
               similarityMatrix[i, j] <- intersectionSum
             }
           }
           distanceMatrix <- max(similarityMatrix) - similarityMatrix
         },
         "Jaccard (fragment-count-weighted)"={
           featureIndexMatrix <- dataList$featureIndexMatrix[filter, ]
           fragmentFrequency <- dataList$fragmentFrequency
           
           counter <<- 0
           distanceMatrix <- apply(X = featureIndexMatrix, MARGIN = 1, FUN = function(x)
           {  
             counter <<- counter + 1
             time <- proc.time()["user.self"]
             if(time - lastOut > 1){
               lastOut <- time
               precursorProgress <- (counter - lastPrecursor) / numberOfPrecursors
               lastPrecursor <- counter
               if(!is.na(progress))  if(progress)  incProgress(amount = precursorProgress,     detail = paste("Distance ", counter, " / ", numberOfPrecursors, sep = "")) else print(paste("Distance ", counter, " / ", numberOfPrecursors, sep = ""))
             }
             intersectionSum <- apply(X = featureIndexMatrix, MARGIN = 1, FUN = function(y){  sum(fragmentFrequency[x[x %in% y]], na.rm = TRUE)  })
             unionSum        <- apply(X = featureIndexMatrix, MARGIN = 1, FUN = function(y){  sum(fragmentFrequency[c(x[!x %in% y], y)], na.rm = TRUE)  })
             
             1 - intersectionSum / unionSum
           }
           )
         },
         "Manhatten"={
           featureIndeces <- dataList$featureIndeces[filter]
           featureMatrix <- as.matrix(dataList$featureMatrix[filter, ])
           
           ## Rasmussen 2008
           distanceMatrix <- matrix(nrow = numberOfPrecursors, ncol = numberOfPrecursors)
           for(i in seq_len(numberOfPrecursors)){
             time <- proc.time()["user.self"]
             if(time - lastOut > 1){
               lastOut <- time
               precursorProgress <- (i - lastPrecursor) / numberOfPrecursors
               lastPrecursor <- i
               if(!is.na(progress))  if(progress)  incProgress(amount = precursorProgress,     detail = paste("Distance ", i, " / ", numberOfPrecursors, sep = "")) else print(paste("Distance ", i, " / ", numberOfPrecursors, sep = ""))
             }
             for(j in seq_len(numberOfPrecursors)){
               if(i == j){
                 distanceMatrix[i, j] <- 0
                 next
               }
               
               intersection <- intersect(x = featureIndeces[[i]], y = featureIndeces[[j]])
               intersectionSum <- sum(abs(featureMatrix[i, intersection] - featureMatrix[j, intersection]))
               
               onlyI <- setdiff(x = featureIndeces[[i]], y = intersection)
               onlyJ <- setdiff(x = featureIndeces[[j]], y = intersection)
               sumOnlyI <- sum(featureMatrix[i, onlyI])
               sumOnlyJ <- sum(featureMatrix[j, onlyJ])
               
               distanceMatrix[i, j] <- intersectionSum + sumOnlyI + sumOnlyJ
             }
           }
         },
         "NDP (Normalized dot product)"={
           featureIndeces <- dataList$featureIndeces[filter]
           featureMatrix <- dataList$featureMatrix[filter, ]
           
           ## Gaquerel 2015: standard normalized dot product (NDP) / cosine correlation
           similarityMatrix <- matrix(nrow = numberOfPrecursors, ncol = numberOfPrecursors)
           for(i in seq_len(numberOfPrecursors)){
             time <- proc.time()["user.self"]
             if(time - lastOut > 1){
               lastOut <- time
               precursorProgress <- (i - lastPrecursor) / numberOfPrecursors
               lastPrecursor <- i
               if(!is.na(progress))  if(progress)  incProgress(amount = precursorProgress,     detail = paste("Distance ", i, " / ", numberOfPrecursors, sep = "")) else print(paste("Distance ", i, " / ", numberOfPrecursors, sep = ""))
             }
             for(j in seq_len(numberOfPrecursors)){
               if(i == j){
                 similarityMatrix[i, j] <- 0
                 next
               }
               
               intersection    <- featureIndeces[[i]][featureIndeces[[i]] %in% featureIndeces[[j]]]
               #intersection    <- intersect(x = featureIndeces[[i]], y = featureIndeces[[j]])
               intersectionSum <- sum(sqrt(featureMatrix[i, intersection]) * dataList$fragmentMasses[intersection]^2 * sqrt(featureMatrix[j, intersection]) * dataList$fragmentMasses[intersection]^2)^2
               iSum            <- sum((sqrt(featureMatrix[i, featureIndeces[[i]]]) * dataList$fragmentMasses[featureIndeces[[i]]]^2)^2)
               jSum            <- sum((sqrt(featureMatrix[j, featureIndeces[[j]]]) * dataList$fragmentMasses[featureIndeces[[j]]]^2)^2)
               
               similarityMatrix[i, j] <- intersectionSum / (iSum * jSum)
             }
           }
           distanceMatrix <- max(similarityMatrix) - similarityMatrix
         },
         stop(paste("Unknown distance (", distance, ")!", sep = ""))
  )
  
  rownames(distanceMatrix) <- dataList$precursorLabels[filter]
  colnames(distanceMatrix) <- dataList$precursorLabels[filter]
  
  returnObj <- list(
    distanceMatrix = distanceMatrix,
    filter = filter,
    distanceMeasure = distanceMeasure
  )
  
  return(returnObj)
}
calculateCluster <- function(dataList, filterObj, distanceMatrix, method, distanceMeasure, progress = FALSE){
  
  if(FALSE){
    dataList_ <<- dataList
    filterObj_ <<- filterObj
    distanceMatrix_ <<- distanceMatrix
    method_ <<- method
    distanceMeasure_ <<- distanceMeasure
  }
  if(FALSE){
    dataList <- dataList_
    filterObj <- filterObj_
    distanceMatrix <- distanceMatrix_
    method <- method_
    distanceMeasure <- distanceMeasure_
  }
  
  numberOfPrecursorsFiltered <- length(filterObj$filter)
  ##########################################
  ## compute gui stuff
  
  if(!is.na(progress))  if(progress)  incProgress(amount = 0, detail = "Clustering")
  ## compute and annotate cluster
  dist <- stats::as.dist(m = distanceMatrix)
  cluster <- hclust(d = dist, method = method)
  cluster$labels <- dataList$precursorLabels[filterObj$filter]
  numberOfInnerNodes <- numberOfPrecursorsFiltered - 1
  leafHeightSpacing <- 0.04
  
  ## optimal leaf ordering
  #opt <- order.optimal(dist = dist, merge = cluster$merge)
  #cluster$merge <- opt$merge
  #cluster$order <- opt$order
  
  ## compute (transitive) cluster members, cluster positions, and leaf heights
  if(!is.na(progress))  if(progress)  incProgress(amount = 0.3, detail = "Analyze cluster")
  
  resultObj <- analyzeTreeFromRoot(dataList, cluster = cluster, filterObj$filter)
  
  innerNodeHeightIncreases <- unlist(resultObj$innerNodeHeightIncreases)
  innerNodeMembersTreeClusters <- resultObj$innerNodeMembersTreeClusters
  innerNodeMembersTreeLeaves  <- resultObj$innerNodeMembersTreeLeaves
  innerNodeMembersPrecursors <- resultObj$innerNodeMembersPrecursors
  #innerNodeFeaturesBinary <- resultObj$innerNodeFeaturesBinary
  innerNodeFeaturesIntersection <- resultObj$innerNodeFeaturesIntersection
  innerNodeFeaturesUnion <- resultObj$innerNodeFeaturesUnion
  innerNodeFeaturesCountsMatrix <- resultObj$innerNodeFeaturesCountsMatrix
  innerNodeFeaturesPresent <- resultObj$innerNodeFeaturesPresent
  #innerNodeFeaturesMeanAbundance <- resultObj$innerNodeFeaturesMeanAbundance
  #innerNodeFeaturesIntersectionCounter <- resultObj$innerNodeFeaturesIntersectionCounter
  #innerNodeFeaturesUnionCounter <- resultObj$innerNodeFeaturesUnionCounter
  innerNodePosition <- resultObj$innerNodePosition
  leafHeights <- resultObj$leafHeights
  
  #innerNodeFeaturesCountsMatrix <- matrix(data = unlist(innerNodeFeaturesCounts), nrow = length(innerNodeFeaturesCounts))
  
  ## dendrogram leaf ends for normal plot
  #leafHeights <- leafHeights - leafHeightSpacing
  leafHeights <- rep(x = 0, times = length(leafHeights))
  
  ## compute x- and y-coordinates and point-labels
  poiCoordinatesX <- unlist(c(innerNodePosition, match(x = seq_len(numberOfPrecursorsFiltered), table = cluster$order)))
  poiCoordinatesY <- unlist(c(cluster$height, leafHeights))
  
  precursorFeatureCount <- dataList$featureCount[filterObj$filter]
  #innerNodeUnionlabels <- as.character(innerNodeFeaturesUnionCounter)
  #innerNodeUnionlabels[!innerNodeHeightIncreases] <- ""
  #innerNodeIntersectionlabels <- as.character(innerNodeFeaturesIntersectionCounter)
  #innerNodeIntersectionlabels[!innerNodeHeightIncreases] <- ""
  
  drawPoi <- unlist(c(
    innerNodeHeightIncreases, 
    rep(x = TRUE, times = length(filterObj$filter))
  ))
  #poiUnion <- unlist(c(
  #  innerNodeUnionlabels, 
  #  precursorFeatureCount
  #))
  #poiIntersection <- unlist(c(
  #  innerNodeIntersectionlabels, 
  #  precursorFeatureCount
  #  #vector(mode = "character", length = length(filterObj$filter))
  #))
  poiIntersectionSmooth <- c(innerNodeFeaturesPresent, precursorFeatureCount)
  poiLabels <- unlist(c(seq_len(numberOfInnerNodes), -(seq_len(numberOfPrecursorsFiltered))))
  
  ##########################################
  ## box
  if(!is.na(progress))  if(progress)  incProgress(amount = 0.5, detail = "Boxing")
  clusterDataList <- list()
  ## filter
  clusterDataList$filterObj <- filterObj
  clusterDataList$method <- method
  clusterDataList$distanceMeasure <- distanceMeasure
  #clusterDataList$distanceMatrix <- distanceMatrix
  clusterDataList$numberOfPrecursorsFiltered <- numberOfPrecursorsFiltered
  ## cluster
  
  clusterDataList$innerNodeMembersTreeLeaves <- innerNodeMembersTreeLeaves
  clusterDataList$innerNodeMembersTreeClusters <- innerNodeMembersTreeClusters
  clusterDataList$innerNodeMembersPrecursors <- innerNodeMembersPrecursors
  #clusterDataList$innerNodeFeaturesBinary <- innerNodeFeaturesBinary
  clusterDataList$innerNodeFeaturesIntersection <- innerNodeFeaturesIntersection
  clusterDataList$innerNodeFeaturesUnion <- innerNodeFeaturesUnion
  clusterDataList$innerNodeFeaturesCountsMatrix <- innerNodeFeaturesCountsMatrix
  #clusterDataList$innerNodeFeaturesPresent <- innerNodeFeaturesPresent
  #clusterDataList$innerNodeFeaturesMeanAbundance <- innerNodeFeaturesMeanAbundance
  #clusterDataList$innerNodeFeaturesIntersectionCounter <- innerNodeFeaturesIntersectionCounter
  #clusterDataList$innerNodeFeaturesUnionCounter <- innerNodeFeaturesUnionCounter
  clusterDataList$cluster <- cluster
  ## poi
  clusterDataList$numberOfPois    <- length(poiCoordinatesX)
  clusterDataList$poiCoordinatesX <- poiCoordinatesX
  clusterDataList$poiCoordinatesY <- poiCoordinatesY
  #clusterDataList$poiUnion        <- poiUnion
  #clusterDataList$poiIntersection <- poiIntersection
  clusterDataList$poiIntersectionSmooth <- poiIntersectionSmooth
  clusterDataList$poiLabels       <- poiLabels
  clusterDataList$drawPoi         <- drawPoi
  
  ##########################################
  ## calculate ms2 spectra
  if(!is.na(progress))  if(progress)  incProgress(amount = 0.1, detail = "Calculate spectrum information for leaves")
  ms2spectrumInfoForLeaves <<- list()
  for(leafIdx in seq_len(numberOfPrecursorsFiltered))
    ms2spectrumInfoForLeaves[[leafIdx]] <- getMS2spectrumInfoForPrecursorLeaf(dataList, clusterDataList, treeLabel = -leafIdx, outAdductWarning = FALSE)
  
  if(!is.na(progress))  if(progress)  incProgress(amount = 0.1, detail = "Calculate consensus spectra for clusters")
  ms2spectrumInfoForClusters <<- list()
  for(clusterIdx in seq_len(numberOfInnerNodes))
    ms2spectrumInfoForClusters[[clusterIdx]] <- getMS2spectrumInfoForCluster(dataList, clusterDataList, treeLabel = clusterIdx)
  
  ## calculate cluster discriminativity
  if(!is.na(progress))  if(progress)  incProgress(amount = 0.1, detail = "Calculate cluster discriminativity")
  #clusterDiscriminativity <- vector(mode = "numeric", length = numberOfInnerNodes)
  clusterDiscriminativity <- unlist(suppressWarnings(lapply(X = ms2spectrumInfoForClusters, FUN = function(x){x$clusterDiscriminativity})))
  clusterDiscriminativity <- c(clusterDiscriminativity, rep(x = 0, times = numberOfPrecursorsFiltered))
  
  clusterDataList$ms2spectrumInfoForLeaves    <- ms2spectrumInfoForLeaves
  clusterDataList$ms2spectrumInfoForClusters  <- ms2spectrumInfoForClusters
  clusterDataList$clusterDiscriminativity     <- clusterDiscriminativity
  
  if(!is.na(progress))  if(progress)  setProgress(1)
  
  ## 1 167 983 544
  ##   127 968 176
  ##   127 922 016
  ##   128 042 056
  ##    13 761 512
  #print(sort( sapply(ls(),function(x){object.size(get(x))})))
  
  return(clusterDataList)
}
preprocessDataForPca <- function(dataFrame, scaling, logTransform){
  
  if(logTransform){
    dataFrame[dataFrame < 1] <- 1
    dataFrame <- log2(dataFrame)
  }
  
  switch(scaling,
         "None"={
           ## do nothing
           dataFrame2 <- dataFrame
         },
         "Mean center"={
           ## subtract mean
           dataFrame2 <- as.data.frame(apply(X = dataFrame, MARGIN = 2, FUN = function(x){
             x - mean(x = x)
           }))
         },
         "Autoscaling (unit variance)"={
           ## subtract mean and divide by variance
           dataFrame2 <- as.data.frame(apply(X = dataFrame, MARGIN = 2, FUN = function(x){
             (x - mean(x = x)) / sd(x = x)
           }))
         },
         "Pareto"={
           ## subtract mean and divide by sqrt of variance
           dataFrame2 <- as.data.frame(apply(X = dataFrame, MARGIN = 2, FUN = function(x){
             #print(x)
             (x - mean(x = x)) / sqrt(sd(x = x))
           }))
           
           dataFrame2[is.na(dataFrame2)] <- 0
         },
         stop(paste("Unknown scaling (", scaling, ")!", sep = ""))
  )
  
  #dataFrame2[is.na(dataFrame2)] <- dataFrame[is.na(dataFrame2)]
  dataFrame2[is.na(dataFrame2)] <- 0
  
  return(dataFrame2)
}
minimumNumberOfComponents <- 5
performPca <- function(dataList, dataFrame2, ms1AnalysisMethod){
  
  print("######################################################################################")
  print(ms1AnalysisMethod)
  
  if(FALSE){
    dataFrame2_ <<- dataFrame2
    ms1AnalysisMethod_ <<- ms1AnalysisMethod
    dataList_ <<- dataList
  }
  if(FALSE){
    dataFrame2 <- dataFrame2_
    ms1AnalysisMethod <- ms1AnalysisMethod_
    dataList <- dataList_
  }
  
  
  ## TODO pcaMethods confidence intervals analog to MetaboAnalyst: pcaMethods:::simpleEllipse
  numberOfComponents <- min(minimumNumberOfComponents, nrow(dataFrame2))
  
  returnObj <- list()
  returnObj$ms1AnalysisMethod = ms1AnalysisMethod
  
  if(ncol(dataFrame2) < 3){
    ###########################################################
    ## no data or only one sample
    numberOfPrecursors <- dataList$numberOfPrecursors
    numberOfSamples    <- ncol(dataFrame2)
    returnObj$scores   <- matrix(nrow = numberOfSamples,    ncol = numberOfComponents, data = rep(x = 0, times = numberOfSamples    * numberOfComponents))
    returnObj$loadings <- matrix(nrow = numberOfPrecursors, ncol = numberOfComponents, data = rep(x = 0, times = numberOfPrecursors * numberOfComponents))
    returnObj$variance <- vector(mode = "numeric", length = numberOfComponents)
    return(returnObj)
  }
  
  ## choose library
  #ms1AnalysisMethod <- c(
  #  "stats",           # 1
  #  "FactoMineR",      # 2
  #  "pcaMethods",      # 3
  #  "mixOmics_pca",    # 4
  #  "mixOmics_spca",   # 5
  #  "mixOmics_plsda",  # 6
  #  "mixOmics_splsda"  # 7
  #)[[5]]
  
  switch(ms1AnalysisMethod,
         "PCA (Principal Component Analysis)"={
           #ms1AnalysisMethod <- "mixOmics_pca"
           ms1AnalysisMethod <- "pcaMethods"
         },
         "sPCA (Sparse Principal Component Analysis)"={
           ms1AnalysisMethod <- "mixOmics_spca"
         },
         "PLS-DA (Partial Least Squares Discriminant Analysis)"={
           ms1AnalysisMethod <- "mixOmics_plsda"
           #ms1AnalysisMethod <- "caret_plsda"
         },
         "sPLS-DA (Sparse Partial Least Squares Discriminant Analysis)"={
           ms1AnalysisMethod <- "mixOmics_splsda"
         },
         stop(paste("Unknown analysis method (", ms1AnalysisMethod, ")!", sep = ""))
  )
  
  print(paste("Analysis", ms1AnalysisMethod, sep = ": "))
  switch(ms1AnalysisMethod,
         "stats"={
           ## pca from "stats" package
           pca <- stats::prcomp(x = dataFrame2, retx = TRUE, center = FALSE, scale. = FALSE)
           returnObj$scores   <- pca$x
           returnObj$loadings <- pca$rotation
           returnObj$variance <- pca$sdev
         },
         "FactoMineR"={
           ## pca from "FactoMineR" package
           pca = FactoMineR::PCA(X = dataFrame2, graph = FALSE, scale.unit = FALSE, ncp = numberOfComponents)
           returnObj$scores   <- pca$ind$coord
           returnObj$loadings <- pca$var$coord
           returnObj$variance <- pca$eig$"percentage of variance"
         },
         "pcaMethods"={
           ## pca from "pcaMethods" package
           #pca <- pca(object = dataFrame2, method = "robustPca", nPcs = 2, scale = "none", center = FALSE, cv = "q2")
           pca <- pcaMethods::pca(object = dataFrame2, method = "svd", nPcs = numberOfComponents, scale = "none", center = FALSE)
           returnObj$scores   <- pca@scores
           returnObj$loadings <- pca@loadings
           returnObj$variance <- pca@sDev
           
           returnObj$R2 <- pca@R2
           #returnObj$Q2 <- Q2(object = pca, fold=2)
           returnObj$Q2 <- tryCatch(
             {
               #Q2(object = pca, fold=2)
               Q2(object = pca, verbose = FALSE)
             },
             error=function(cond) {
               rep(x = "N/A", times = numberOfComponents)
             }
           )
         },
         "mixOmics_pca"={
           ## pca from "mixOmics" package
           pca = mixOmics::pca(X = dataFrame2, ncomp = numberOfComponents, center = FALSE, scale = FALSE)
           returnObj$scores   <- pca$variates[[1]]
           returnObj$loadings <- pca$loadings[[1]]
           returnObj$variance <- pca$explained_variance
           #returnObj$R2 <- 
           #returnObj$Q2 <- 
         },
         "mixOmics_spca"={
           ## pca from "mixOmics" package
           pca = mixOmics::spca(X = dataFrame2, ncomp = numberOfComponents, center = FALSE, scale = FALSE)
           returnObj$scores   <- pca$variates[[1]]
           returnObj$loadings <- pca$loadings[[1]]
           returnObj$variance <- pca$explained_variance
           #returnObj$R2 <- 
           #returnObj$Q2 <- 
           
           #performance <- perf(pca, validation = "loo", progressBar = FALSE)
           #val <- perf(pca, criterion = c("R2", "Q2"))
           
         },
         "mixOmics_plsda"={
           ## plsda "mixOmics" package
           groupLabels  <- unlist(lapply(X = rownames(dataFrame2), FUN = function(x){dataList$groupNameFunctionFromDataColumnName(dataColumnName = x, sampleNamesToExclude = dataList$excludedSamples(dataList$groupSampleDataFrame))}))
           pca = mixOmics::plsda(X = dataFrame2, Y = groupLabels, ncomp = numberOfComponents, scale = FALSE)
           
           if(any(pca$explained_variance$X < 0.01)){
             maxComp <- max(which(pca$explained_variance$X >= 0.01))
             numberOfComponents <- maxComp
             
             pca = mixOmics::plsda(X = dataFrame2, Y = groupLabels, ncomp = numberOfComponents, scale = FALSE)
           }
           
           returnObj$scores   <- pca$variates[[1]]
           returnObj$loadings <- pca$loadings[[1]]
           returnObj$variance <- pca$explained_variance$X
           
           #performance <- perf(pca, validation = "loo", progressBar = FALSE)
           #performance$choice.ncomp
           
           if(FALSE){## R2 and Q2?
             performance <- perf(pca, validation = "Mfold", folds = 2, progressBar = FALSE, tol = 1e-20)
             performance <- perf(pca, validation = "loo", progressBar = FALSE, tol = 1e-20)
             
             pca = mixOmics::pca(X = dataFrame2, ncomp = numberOfComponents, center = FALSE, scale = FALSE)
             loadings <- pca$loadings[[1]]
             sumOfLoadings <- apply(X = loadings, MARGIN = 1, FUN = sum)
             toRemove <- which(abs(sumOfLoadings) < 0.0001)
             
             dataFrame3 <- dataFrame2[-toRemove, ]
             pca = mixOmics::plsda(X = dataFrame3, Y = groupLabels, ncomp = numberOfComponents, scale = FALSE)
             
             
             
             randomMatrix <- replicate(n = ncol(dataFrame2), runif(n = nrow(dataFrame2), min = -10000, max = 10000))
             dataFrame3 <- dataFrame2 + randomMatrix
             
             pca = mixOmics::plsda(X = dataFrame3, Y = groupLabels, ncomp = numberOfComponents, scale = FALSE)
             returnObj$scores   <- pca$variates[[1]]
             returnObj$loadings <- pca$loadings[[1]]
             returnObj$variance <- pca$explained_variance
             
             performance <- perf(pca, validation = "Mfold", folds = 2, progressBar = FALSE, tol = 1e-20)
             performance <- perf(pca, validation = "loo", progressBar = FALSE)
             perf(pca, validation = "loo", progressBar = FALSE)
           }
           
           #returnObj$R2 <- performance$R2
           #returnObj$Q2 <- performance$Q2
         },
         "mixOmics_splsda"={
           ## splsda from "mixOmics" package TODO
           groupLabels  <- unlist(lapply(X = rownames(dataFrame2), FUN = function(x){dataList$groupNameFunctionFromDataColumnName(dataColumnName = x, sampleNamesToExclude = dataList$excludedSamples(dataList$groupSampleDataFrame))}))
           caret_splsda = mixOmics::splsda(X = dataFrame2, Y = groupLabels, ncomp = numberOfComponents, scale = FALSE)
           returnObj$scores   <- caret_splsda$variates[[1]]
           returnObj$loadings <- caret_splsda$loadings[[1]]
           returnObj$variance <- caret_splsda$explained_variance$X
         },
         "caret_plsda"={
           groupLabels  <- unlist(lapply(X = rownames(dataFrame2), FUN = function(x){dataList$groupNameFunctionFromDataColumnName(dataColumnName = x, sampleNamesToExclude = dataList$excludedSamples(dataList$groupSampleDataFrame))}))
           caret_plsda <- caret::plsda(x = dataFrame2, y = as.factor(groupLabels), ncomp = numberOfComponents, probMethod = "softmax")
           
           returnObj$scores   <- caret_plsda$scores
           returnObj$loadings <- caret_plsda$loadings
           returnObj$variance <- caret_plsda$Xvar / sum(caret_plsda$Xvar)
           returnObj$accurracyContribution <- leaveOneOutCrossValidation_plsda(dataFrame2, groupLabels, numberOfComponents)
         },
         stop(paste("Unknown analysis method (", ms1AnalysisMethod, ")!", sep = ""))
  )
  
  #str(returnObj)
  
  ## valid data
  #$ scores  : num [1:19, 1:5] -355 807 808 -2720 748 ...
  #..- attr(*, "dimnames")=List of 2
  #.. ..$ : chr [1:19] "A1_1" "A1_2" "A1_3" "A1_4" ...
  #.. ..$ : chr [1:5] "Dim.1" "Dim.2" "Dim.3" "Dim.4" ...
  #$ loadings: num [1:358, 1:5] 1.07 1.11 12.3 -2.21 36.6 ...
  #..- attr(*, "dimnames")=List of 2
  #.. ..$ : chr [1:358] "  105.0700 /   161.85" "  122.0968 /   162.04" "  125.9873 /     48.28" "  129.0557 / 1019.34" ...
  #.. ..$ : chr [1:5] "Dim.1" "Dim.2" "Dim.3" "Dim.4" ...
  #$ variance: num [1:18] 35.96 21.67 11.66 8.15 4.56 ...
  #
  ## artificial data two grouXXXps
  #$ scores  : num [1:2, 1] 0 0
  #..- attr(*, "dimnames")=List of 2
  #.. ..$ : chr [1:2] "A_1" "B_2"
  #.. ..$ : chr "Dim.1"
  #$ loadings: Named num [1:455] 0 0 0 0 0 0 0 0 0 0 ...
  #..- attr(*, "names")= chr [1:455] "  52.1 / 18.74" "  53.0 /   9.13" "  55.1 / 19.60" "  56.1 / 12.91" ...
  #$ variance: num NaN
  #
  ## artificial data one group
  #$ scores  : num [1:455, 1] 2.89e-15 2.89e-15 2.89e-15 2.89e-15 2.89e-15 ...
  #..- attr(*, "dimnames")=List of 2
  #.. ..$ : chr [1:455] "  52.1 / 18.74" "  53.0 /   9.13" "  55.1 / 19.60" "  56.1 / 12.91" ...
  #.. ..$ : chr "Dim.1"
  #$ loadings: num 2.89e-15
  #$ variance: num 100
  #
  #str(returnObj)
  
  if(any(is.na(returnObj$variance), length(returnObj$variance) == 1)){
    ## in case of artificial data
    numberOfPrecursors <- dataList$numberOfPrecursors
    #numberOfSamples    <- nrow(returnObj$scores)
    numberOfSamples    <- ncol(dataFrame2)
    returnObj$scores   <- matrix(nrow = numberOfSamples, ncol = numberOfComponents)
    returnObj$loadings <- matrix(nrow = numberOfPrecursors, ncol = numberOfComponents)
    returnObj$variance <- vector(mode = "numeric", length = numberOfComponents)
  }
  return(returnObj)
}
leaveOneOutCrossValidation_plsda <- function(dataFrame2, groupLabels, numberOfComponents){
  ## leave-one-out-cross-validation
  maxNumberOfComponents_train <- min(numberOfComponents, nrow(dataFrame2) - 1 - 1)
  numberOfPositivePredictions_comp <- numeric(length = maxNumberOfComponents_train)
  for(sampleIdx in seq_along(groupLabels)){
    dataFrame2_train <- dataFrame2[-sampleIdx, ]
    groupLabels_train <- groupLabels[-sampleIdx]
    dataFrame2_test <- dataFrame2[sampleIdx, , drop=FALSE]
    groupLabels_test <- groupLabels[sampleIdx]
    
    for(numberOfComponents_train in seq_len(maxNumberOfComponents_train)){
      caret_plsda_train <- caret::plsda(
        x = dataFrame2_train, 
        y = as.factor(groupLabels_train), 
        ncomp = numberOfComponents_train, 
        probMethod = "softmax"
      )
      
      groupLabels_predict <- as.character(predict(caret_plsda_train, dataFrame2_test))
      numberOfPositivePredictions_comp[[numberOfComponents_train]] <- numberOfPositivePredictions_comp[[numberOfComponents_train]] + (groupLabels_predict == groupLabels_test)
    }
  }
  accurracy_comp <- numberOfPositivePredictions_comp / nrow(dataFrame2)
  accurracyContribution_comp <- numeric(length = maxNumberOfComponents_train + 1)
  accurracyContribution_comp[[1]] <- accurracy_comp[[1]]
  accurracyContribution_comp[2:maxNumberOfComponents_train] <- accurracy_comp[2:maxNumberOfComponents_train] - accurracy_comp[1:(maxNumberOfComponents_train-1)]
  accurracyContribution_comp[[maxNumberOfComponents_train + 1]] <- NA
  
  return(accurracyContribution_comp)
}
calculatePCA <- function(dataList, filterObj, ms1AnalysisMethod, scaling, logTransform){
  if(FALSE){
    dataList_ <<- dataList
    filterObj_ <<- filterObj
    ms1AnalysisMethod_ <<- ms1AnalysisMethod
    scaling_ <<- scaling
    logTransform_ <<- logTransform
  }
  if(FALSE){
    dataList <<- dataList_
    filterObj <<- filterObj_
    ms1AnalysisMethod <<- ms1AnalysisMethod_
    scaling <<- scaling_
    logTransform <<- logTransform_
  }
  
  ## data selection
  if(filterObj$filterBySamples){
    dataFrame <- dataList$dataFrameMeasurements[filterObj$filter, filterObj$sampleSet]
  } else {
    dataFrame <- dataList$dataFrameMeasurements[filterObj$filter, dataList$dataColumnsNameFunctionFromGroupNames(grouXXXps = filterObj$grouXXXps, sampleNamesToExclude = dataList$excludedSamples(dataList$groupSampleDataFrame))]
  }
  dataFrame <- t(dataFrame)
  
  ## data scaling
  dataFrame2 <- preprocessDataForPca(dataFrame, scaling, logTransform)
  
  ## data analysis
  returnObj <- performPca(dataList, dataFrame2, ms1AnalysisMethod)
  returnObj$filterObj = filterObj
  returnObj$scaling = scaling
  returnObj$logTransform = logTransform
  
  return(returnObj)
}

================
File: R/Annotation.R
================
# List of 19
# $ classifierName         : chr "library=MoNA-export-LC-MS_-_MSMS_-_Negative.msp_Class=ChemOnt_SubstanceClass_AltSC=TRUE_method=ColSums_smoothIntensities=FALSE"
# $ numberOfSpectra        : int 1355
# $ numberOfPositiveSpectra: int 20
# $ numberOfNegativeSpectra: int 1335
# $ algorithm              :List of 5
# $ class                  : chr "Organic compounds; Alkaloids and derivatives"
# $ fragmentMasses         : num [1:12207] -970 -969 -965 -965 -963 ...
# $ classOfClass           : chr "ChemOnt_SubstanceClass"
# $ classifier             : Named num [1:12207] -0.000749 -0.000749 -0.000749 -0.000749 -0.000749 ...
# ..- attr(*, "names")= chr [1:12207] "-970.4801" "-969.496033333333" "-964.5493" "-964.513" ...
# $ frequentFragments      : Named num [1:29] 0.571 0.286 0.214 0.214 0.214 ...
# ..- attr(*, "names")= chr [1:29] "-15.0237479936883" "-16.0318143323429" "122.036402912621" "-0.000562633278350665" ...
# $ characteristicFragments: Named num [1:28] 0.539 0.275 0.203 0.203 0.143 ...
# ..- attr(*, "names")= chr [1:28] "-15.0237479936883" "-16.0318143323429" "122.036402912621" "-57.0267914509474" ...
# $ quantiles              : num [1:1001] 0 0.001 0.002 0.003 0.004 0.005 0.006 0.007 0.008 0.009 ...
# $ quantilesValuesPositive: num [1:1001] -0.207 -0.207 -0.207 -0.207 -0.207 ...
# $ quantilesValuesNegative: num [1:1001] -0.374 -0.302 -0.283 -0.256 -0.249 ...
# $ positiveScores         : num [1:60] -0.20664 -0.01071 -0.00964 -0.00964 0.04742 ...
# $ negativeScores         : num [1:4010] -0.374 -0.321 -0.309 -0.302 -0.297 ...
# $ AUC                    : num 0.912
# $ TPR_for_FPR_of_5Percent: num 0.667
# $ TNR_for_FNR_of_5Percent: num 0

## filePath <- "/home/htreutle/Data/SubstanceClasses/Classifier_ROC_Analysis/old_colSums/2018-04-16_09:14:12_2018-02-13_09:14:10_pos_21908_MoNA-export-LC-MS-MS_Spectra.msp_Classifier.RData"
## propertiesList <- list($library= "2018-02-13_09:14:10_pos_21908_MoNA-export-LC-MS-MS_Spectra.msp", maximumNumberOfScores= "10000", removeRareFragments= "FALSE", mergeDuplicatedSpectra= "TRUE", takeSpectraWithMaximumNumberOfPeaks= "FALSE", classOfClass= "ChemOnt|AllClasses", minimumNumberOfPosSpectraPerClass= "10", minimumNumberOfNegSpectraPerClass= "10", numberOfDataSetDecompositions= "10", proportionTraining= "0.7", unitResolution= "FALSE", methodName= "ColSumsPos", paramsString= "smoothIntensities=FALSE", algoName= "method=ColSumsPos; smoothIntensities=FALSE")
## featureMatrix <- dataList$featureMatrix
## parameterSet <- dataList$importParameterSet
doAnnotation <- function(filePath, propertiesList, featureMatrix, parameterSet, classesWhiteList = NULL, progress = FALSE){
  if(TRUE){
    filePath_ <<- filePath
    propertiesList_ <<- propertiesList
    featureMatrix_ <<- featureMatrix
    parameterSet_ <<- parameterSet
    classesWhiteList_ <<- classesWhiteList
  }
  if(FALSE){
    filePath <- filePath_
    propertiesList <- propertiesList_
    featureMatrix <- featureMatrix_
    parameterSet <- parameterSet_
    classesWhiteList = classesWhiteList_
    progress <- FALSE
  }
  
  if(progress)  incProgress(amount = 0, detail = "Init") else print("Init")
  ################################################
  ## given
  fragmentMasses <- as.numeric(colnames(featureMatrix))
  fragmentMasses_test <- fragmentMasses
  numberOfSpectra <- nrow(featureMatrix)
  
  ################################################
  ## classifier
  fdrThreshold <- 0.05
  
  ## load classifier
  if(progress)  incProgress(amount = 0, detail = "Loading classifier") else print("Loading classifier")
  classifiers_class <- NULL
  load(file = filePath) # --> classifiers_class
  #"classifierName"          "numberOfSpectra"         "numberOfPositiveSpectra" "numberOfNegativeSpectra"
  #"algorithm"               "class"                   "fragmentMasses"          "classOfClass"           
  #"classifier"              "frequentFragments"       "characteristicFragments" "quantiles"              
  #"quantilesValuesPositive" "quantilesValuesNegative" "positiveScores"          "negativeScores"         
  #"AUC"                     "TPR_for_FPR_of_5Percent" "TNR_for_FNR_of_5Percent"
  
  ## get classifier function
  method <- propertiesList$algoName
  algorithms <- getAlgorithms()
  algoNames <- unlist(lapply(X = algorithms, FUN = function(x){x$algoName}))
  trainingAlgorithm <- algorithms[[which(algoNames == method)]]
  #trainingAlgorithm <- classifiers_class[[1]]$algorithm
  smoothIntensities <- trainingAlgorithm$params$smoothIntensities
  
  ##################################################
  ## mapping of fragments
  if(progress)  incProgress(amount = 0.1, detail = "Aligning classifier") else print("Aligning classifier")
  fragmentMasses_classifier <- classifiers_class[[1]]$fragmentMasses
  
  #############################################################
  ## mapping fragmentMasses_test to fragmentMasses_classifier
  unitResolution <- as.logical(propertiesList$unitResolution)
  if(unitResolution){
    ## Unit resolution
    fragmentMassesRounded        <- round(fragmentMasses_test)
    duplicatedFragmentMasses_bool <- duplicated(fragmentMassesRounded)
    duplicatedFragmentMasses <- unique(fragmentMassesRounded[duplicatedFragmentMasses_bool])
    #fragmentMassesNew        <- unique(fragmentMassesRounded)
    fragmentMassesNew        <- fragmentMassesRounded[!duplicatedFragmentMasses_bool]
    
    fragmentIndecesToRemove <- vector(mode = "integer", length = 0)
    
    #uniqueFragmentMasses_Indeces  <- which(!duplicatedFragmentMasses_bool)
    #fragmentMassesMapping <- list()
    #fragmentMassesMappingOverhead <- vector(mode = "numeric", length = length(duplicatedFragmentMasses))
    
    for(idx in seq_along(duplicatedFragmentMasses)){
      #if(all(length(duplicatedFragmentMasses)>=10, (idx %% (as.integer(length(duplicatedFragmentMasses)/10))) == 0, progress))
      #  incProgress(amount = 0., detail = paste("Aligning classifier ", idx, " / ", length(duplicatedFragmentMasses), sep = ""))
      
      indeces <- which(fragmentMassesRounded == duplicatedFragmentMasses[[idx]])
      indexRepresentant <- indeces[[1]]
      indecesToRemove   <- indeces[-1]
      
      #fragmentMassesMapping        [[idx]] <- fragmentMasses[indeces]
      #fragmentMassesMappingOverhead[[idx]] <- length(fragmentIndecesToRemove)
      
      featureMatrix[, indexRepresentant] <- Matrix::rowSums(x = featureMatrix[, indeces])
      fragmentIndecesToRemove <- c(fragmentIndecesToRemove, indecesToRemove)
    }
    
    if(length(fragmentIndecesToRemove) > 0){
      featureMatrix       <- featureMatrix[, -fragmentIndecesToRemove]
      fragmentMasses_test <- fragmentMassesNew
      #numberOfMS2PeakGroups <- length(fragmentMasses_test)
      featureMatrix@Dimnames[[2]] <- fragmentMasses_test
      #spectraCount_fragment <- Matrix::colSums(featureMatrix != 0)
    }
    
    mappedFragmentIndeces_source <- which(fragmentMasses_test       %in% fragmentMasses_classifier)
    mappedFragmentIndeces_target <- which(fragmentMasses_classifier %in% fragmentMasses_test      )
    
    fragmentMassesMapped_bool  <- fragmentMassesRounded %in% fragmentMasses_classifier[mappedFragmentIndeces_target]
    fragmentMassesMappedSource <- fragmentMasses       [fragmentMassesMapped_bool]
    fragmentMassesMappedTarget <- fragmentMassesRounded[fragmentMassesMapped_bool]
    
    ## TODO add index vector for mapping of ClassMasses to aligned ClassMasses
    mappingSpectraToClassDf <- data.frame(
      "SpectraMasses" = fragmentMassesMappedSource,
      "ClassMasses"   = fragmentMassesMappedTarget
    )
  } else {
    ## TODO GC-EI vs unitResolution ???
    mzAbs <- parameterSet$mzDeviationAbsolute_grouping
    mzPPM <- parameterSet$mzDeviationInPPM_grouping
    
    mapping_fm_test <- as.integer(rep(x = NA, times = length(fragmentMasses_test)))
    for(fragmentIdx in seq_along(fragmentMasses_test)){
      ## intentionally equals mzAbs in case of neutral losses (with negative values)
      massError <- max(fragmentMasses_test[[fragmentIdx]] * mzPPM / 1E6, mzAbs)
      
      ## mapping and selection of best hit
      hits <- abs(fragmentMasses_test[[fragmentIdx]] - fragmentMasses_classifier) <= massError
      if(sum(hits) == 0)
        next
      mapping_fm_test[[fragmentIdx]] <- which.min(abs(fragmentMasses_test[[fragmentIdx]] - fragmentMasses_classifier))[[1]]
    }
    
    #numberOfMappedFragments <- sum(!is.na(mapping_fm_test))
    mappedFragmentIndeces_target <- mapping_fm_test[!is.na(mapping_fm_test)]
    mappedFragmentIndeces_source <- which(!is.na(mapping_fm_test))
    
    rm(mapping_fm_test)
    
    mappingSpectraToClassDf <- data.frame(
      "SpectraMasses"      = fragmentMasses           [mappedFragmentIndeces_source],
      "ClassMasses"        = fragmentMasses_classifier[mappedFragmentIndeces_target],
      "SpectraMassIndeces" = mappedFragmentIndeces_source,
      "ClassMassIndeces"   = mappedFragmentIndeces_target#,
      #"fragmentMasses"            = fragmentMasses,
      #"fragmentMasses_classifier" = fragmentMasses_classifier
    )
  }
  if(progress)  incProgress(amount = 0, detail = paste("Aligned ", length(mappingSpectraToClassDf$SpectraMasses), "vs", length(fragmentMasses), "/", length(fragmentMasses_classifier), "fragments / NLs")) else print(paste("Aligned ", length(mappingSpectraToClassDf$SpectraMasses), "vs", length(fragmentMasses), "/", length(fragmentMasses_classifier), "fragments / NLs"))
  
  ## map test spectra fragments to classifier spectra fragments
  featureMatrix2 <- sparseMatrix(dims = c(numberOfSpectra, length(fragmentMasses_classifier)), i={}, j={}) * 1 ## ngCMatrix --> dgCMatrix
  featureMatrix2[, mappedFragmentIndeces_target] <- featureMatrix[, mappedFragmentIndeces_source]
  featureMatrix2@Dimnames[[1]] <- rownames(featureMatrix)
  featureMatrix2@Dimnames[[2]] <- fragmentMasses_classifier[mappedFragmentIndeces_target]
  featureMatrix <- featureMatrix2
  rm(featureMatrix2)
  
  #############################################################
  ## classification
  if(progress)  incProgress(amount = 0.1, detail = "Classification") else print("Classification")
  
  classifierClasses <- unlist(lapply(X = classifiers_class, FUN = function(x){x$class}))
  numberOfClasses <- length(classifierClasses)
  classes <- classifierClasses
  matrix <- featureMatrix
  
  if(!is.null(classesWhiteList)){
    classes <- intersect(x = classes, classesWhiteList)
  }
  if(progress)  incProgress(amount = 0, detail = paste("Searching for", length(classes), "/", length(classifierClasses), "classes")) else print(paste("Searching for", length(classes), "/", length(classifierClasses), "classes"))
  
  if(!smoothIntensities){
    matrix@x  [matrix@x   != 0] <- 1
  }
  #results__class      = list()
  #results__spectrum_class <- array(data = list(), dim = c(numberOfSpectra))
  results__class_spectrum <- array(data = list(), dim = c(numberOfClasses))
  
  lastOut <- proc.time()["user.self"]
  lastIdx <- 1
  
  #classIdx <- 1
  for(classIdx in seq_along(classes)){
    ## progress
    time <- proc.time()["user.self"]
    if(time - lastOut > 1){
      lastOut <- time
      precursorProgress <- (classIdx - lastIdx) / numberOfClasses * 0.7
      lastIdx <- classIdx
      if(progress)  incProgress(amount = precursorProgress,     detail = paste("Classification:", classIdx, "/", numberOfClasses)) else print(paste("Classification:", classIdx, "/", numberOfClasses))
    }
    
    class <- classes[[classIdx]]
    
    ###########################################
    ## classify it
    classifier <- classifiers_class[[which(classifierClasses==class)]]
    
    methodFunctions   <- trainingAlgorithm$method
    #methodName        <- trainingAlgorithm$methodName
    #parameters_train  <- trainingAlgorithm$params
    #paramsString      <- trainingAlgorithm$paramsString
    #algoName          <- trainingAlgorithm$algoName
    
    if(is.null(classifier$fragmentMassSelection)){
      fragmentMassSelection <- rep(x = TRUE, times = ncol(matrix))
    } else {
      fragmentMassSelection <- mappingSpectraToClassDf$ClassMassIndeces %in% classifier$fragmentMassSelection
    }
    
    parameters_test <- list()
    parameters_test$matrix_test <- matrix[, fragmentMassSelection]
    parameters_test$classifier  <- classifier$classifier
    
    ########################## do
    startTime <- Sys.time()
    predicted_scores <- tryCatch(expr = {
        do.call(what = methodFunctions$classify, args = parameters_test)
      }, error = function(e) {
        #error <- e
        print(paste("####################"))
        print(paste("####################", e))
        print(paste("####################"))
        return(NULL)
      }
    )
    endTime <- Sys.time()
    time <- difftime(endTime, startTime, units = "secs")[[1]]
    
    ## select by fdr
    #epsilon     <- .Machine$double.eps ^ 0.5 ## 1.490116e-08 ## .Machine$double.eps = 2.220446e-16
    #quantileIdx <- which(classifier$quantiles == (1 - fdrThreshold))
    #quantileIdx <- which(mapply(FUN = function(x, y) {isTRUE(all.equal(x, y))}, classifier$quantiles, 1 - fdrThreshold))
    quantileIdx <- which(sapply(X = classifier$quantiles, FUN = function(quantile) {isTRUE(all.equal(quantile, 1 - fdrThreshold))}))
    if(length(quantileIdx) == 0)  stop(paste("Quantile for fdrThreshold", fdrThreshold, "not there"))
    if(length(quantileIdx) >  1)  stop(paste("Quantile for fdrThreshold", fdrThreshold, "ambiguous"))
    scoreThreshold <- classifier$quantilesValuesNegative[[quantileIdx]]
    
    spectrumIdsPredicted <- which(predicted_scores >= scoreThreshold)
    results__class_spectrum[[classIdx]] <- sapply(X = spectrumIdsPredicted, FUN = function(spectrumId){
      pValue <- 1 - classifier$quantiles[[max(which(
        classifier$quantilesValuesNegative <= predicted_scores[[spectrumId]]
      ))]]
      return(pValue)
    })
    names(results__class_spectrum[[classIdx]]) <- as.character(spectrumIdsPredicted)
  }## substance class
  
  #plot(sapply(1:numberOfSpectra, function(x){length(results__spectrum_class[[x]])}))
  #plot(sapply(1:numberOfClasses, function(x){length(results__class_spectrum[[x]])}))
  #cbind(substr(classes,1,175),sapply(1:numberOfClasses, function(x){length(results__class_spectrum[[x]])}))
  #
  #plot(sapply(1:numberOfClasses, function(x){min(results__class_spectrum[[x]])}))
  
  classToSpectra_class <- lapply(X = results__class_spectrum, FUN = function(x){
    if(length(x)==0){      return(NULL)
    } else {             return(sort(x))
    }
  })
  names(classToSpectra_class) <- classes
  
  
  # List of 13
  # + $ classifierName         : chr "library=MoNA-export-LC-MS_-_MSMS_-_Negative.msp_Class=ChemOnt_SubstanceClass_AltSC=TRUE_method=ColSums_smoothIntensities=FALSE"
  # + $ numberOfSpectra        : int 1355
  # + $ numberOfPositiveSpectra: int 22
  # + $ numberOfNegativeSpectra: int 1333
  # + $ class                  : chr "Organic compounds; Organic acids and derivatives; Carboxylic acids and derivatives; Amino acids, peptides, and "| __truncated__
  # + $ fragmentMasses         : num [1:12207] -970 -969 -965 -965 -963 ...
  # - $ fragmentMassSelection  : indeces
  # + $ classOfClass           : chr "ChemOnt_SubstanceClass"
  # - $ maximumNumberOfScores               : int 10000
  # - $ removeRareFragments                 : logi FALSE
  # - $ mergeDuplicatedSpectra              : logi TRUE
  # - $ takeSpectraWithMaximumNumberOfPeaks : logi FALSE
  # - $ minimumNumberOfPosSpectraPerClass   : int 10
  # - $ minimumNumberOfNegSpectraPerClass   : int 10
  # - $ numberOfDataSetDecompositions       : int 10
  # - $ proportionTraining                  : num 0.7
  # - $ unitResolution                      : logi FALSE
  # + $ AUC                                 : num 0.956
  # + $ AUC_PR                              : num 0.755               ########################### new ###########################
  # + $ TPR_for_FPR_of_5Percent             : num 0.841
  # - $ TNR_for_FNR_of_5Percent             : num 0.715
  # - $ classifier                          :List of 20
  # - ..$ method      : chr "binda"
  # - ..$ modelInfo   :List of 14
  # - ..$ modelType   : chr "Classification"
  # - ..$ results     :'data.frame':	15 obs. of  9 variables:
  # - ...
  # + $ frequentFragments                   : Named num [1:538] 0.328 0.314 0.299 0.277 0.212 ...
  # - ..- attr(*, "names")= chr [1:538] "151.003240136054" "255.03036741573" "285.041143269231" "284.032276344086" ...
  # + $ characteristicFragments             : Named num [1:492] 0.311 0.305 0.295 0.271 0.203 ...
  # - ..- attr(*, "names")= chr [1:492] "151.003240136054" "255.03036741573" "285.041143269231" "284.032276344086" ...
  # - $ minimumFrequency                    : num 0.01
  # - $ frequentFragmentsMeanIntensity      : Named num [1:538] 0.362 0.309 0.647 0.528 0.243 ...
  # - ..- attr(*, "names")= chr [1:538] "151.003240136054" "255.03036741573" "285.041143269231" "284.032276344086" ...
  # - $ characteristicFragmentsMeanIntensity: Named num [1:492] 0.362 0.309 0.647 0.528 0.243 ...
  # - ..- attr(*, "names")= chr [1:492] "151.003240136054" "255.03036741573" "285.041143269231" "284.032276344086" ...
  # - $ importantFragments                  : Named num [1:35] 100 97.8 94.6 86 81.7 ...
  # - ..- attr(*, "names")= chr [1:35] "151.003240136054" "255.03036741573" "285.041143269231" "284.032276344086" ...
  # - $ quantiles                           : num [1:1001] 0 0.001 0.002 0.003 0.004 0.005 0.006 0.007 0.008 0.009 ...
  # - $ quantilesValuesPositive             : num [1:1001] 1.8e-06 1.8e-06 1.8e-06 1.8e-06 1.8e-06 5.2e-06 5.2e-06 5.2e-06 9.4e-06 9.4e-06 ...
  # - $ quantilesValuesNegative             : num [1:1001] 9.0e-07 9.0e-07 9.0e-07 1.8e-06 1.8e-06 1.8e-06 1.8e-06 1.8e-06 1.8e-06 1.8e-06 ...
  # - $ positiveScores                      : Named num [1:410] 1.80e-06 5.20e-06 9.40e-06 1.21e-05 1.57e-05 1.71e-05 1.77e-05 2.56e-05 2.59e-05 2.59e-05 ...
  # - ..- attr(*, "names")= chr [1:410] "5992" "6534" "5162" "6605" ...
  # - $ negativeScores                      : Named num [1:3960] 9.0e-07 9.0e-07 9.0e-07 9.0e-07 9.0e-07 9.0e-07 9.0e-07 9.0e-07 1.0e-06 1.8e-06 ...
  # - ..- attr(*, "names")= chr [1:3960] "3127" "5623" "5626" "5659" ...
  # + classifier$alternativeSubstanceClasses <- alternativeSubstanceClasses               ########################### new ###########################
  # + classifier$differentSubstanceClasses   <- differentSubstanceClasses                 ########################### new ###########################
  # + classifier$importantFragments <- importance                                         ########################### new ###########################
  # / $ algorithm
  # - ..$ method      :List of 2
  # + ..$ methodName  : chr "ColSums"
  # - ..$ params      :List of 3
  # + ..$ paramsString: chr "smoothIntensities=FALSE, classWeights=FALSE, modelName=binda"
  # + ..$ algoName    : chr "method=caret; smoothIntensities=FALSE, classWeights=FALSE, modelName=binda"
  
  properties_class <- lapply(X = classifiers_class, FUN = function(x){
    c(
    x[c(
      "classifierName",          #: chr "library=MoNA-export-LC-MS_-_MSMS_-_Negative.msp_Class=ChemOnt_SubstanceClass_AltSC=TRUE_method=ColSums_smoothIntensities=FALSE"
      "numberOfSpectra",         #: int 1355
      "numberOfPositiveSpectra", #: int 20
      "numberOfNegativeSpectra", #: int 1335
      #algorithm               #:List of 5
      "class",                   #: chr "Organic compounds; Alkaloids and derivatives"
      "fragmentMasses",          #: num [1:12207] -970 -969 -965 -965 -963 ...
      "classOfClass",            #: chr "ChemOnt_SubstanceClass"
      "frequentFragments",       #: Named num [1:29] 0.571 0.286 0.214 0.214 0.214 ...
      "characteristicFragments", #: Named num [1:28] 0.539 0.275 0.203 0.203 0.143 ...
      "importantFragments",      #
      "alternativeSubstanceClasses", #: chr [1:12]
      "differentSubstanceClasses",   #: chr [1:8]
      "AUC",                      #: num 0.912
      "AUC_PR",                   #: num 0.xxx
      "TPR_for_FPR_of_5Percent" #: num 0.667
    )],
    x[["algorithm"]]["algoName"],
    x[["algorithm"]]["methodName"],
    x[["algorithm"]]["paramsString"]
    )
  })
  
  remove <- sapply(classToSpectra_class, is.null)
  classToSpectra_class <- classToSpectra_class[!remove]
  properties_class     <- properties_class    [!remove]
  
  ## classToSpectra_class[[10]]
  # Named num [1:3] 0.032 0.041 0.042
  # - attr(*, "names")= chr [1:3] "2228" "2049" "2109"
  
  ## properties_class[[1]]
  # List of 13
  # $ classifierName         : chr "library=MoNA-export-LC-MS_-_MSMS_-_Negative.msp_Class=ChemOnt_SubstanceClass_AltSC=TRUE_method=ColSums_smoothIntensities=FALSE"
  # $ numberOfSpectra        : int 1355
  # $ numberOfPositiveSpectra: int 29
  # $ numberOfNegativeSpectra: int 1326
  # $ class                  : chr "Organic compounds; Benzenoids; Benzene and substituted derivatives; Anilides"
  # $ fragmentMasses         : num [1:1668] -970 -969 -965 -963 -960 -959 -958 -956 -955 -954 ...
  # $ classOfClass           : chr "ChemOnt_SubstanceClass"
  # $ frequentFragments      : Named num [1:298] 0.276 0.241 0.207 0.207 0.207 ...
  # ..- attr(*, "names")= chr [1:298] "121" "144" "146" "134" ...
  # $ characteristicFragments: Named num [1:248] 0.218 0.217 0.193 0.177 0.167 ...
  # ..- attr(*, "names")= chr [1:248] "144" "121" "77" "146" ...
  # $ AUC                    : num 0.832
  # $ algoName               : chr "method=ColSums; smoothIntensities=FALSE"
  # $ methodName             : chr "ColSums"
  # $ paramsString           : chr "smoothIntensities=FALSE"
  
  
  resultObj <- list(
    "classToSpectra_class" = classToSpectra_class,
    "properties_class" = properties_class,
    "mappingSpectraToClassDf" = mappingSpectraToClassDf
  )
  return(resultObj)
}
getAlgorithms <- function(){
  methods <- list(
    ## scores
    "CosinusDistance"  = predict_CosinusDistance,
    "ColSums"          = colSums_classifier,
    "ColSumsPos"       = colSumsPos_classifier,
    "Prod"             = predict_Prod,
    "Jaccard"          = predict_Jaccard,
    "JaccardWeighted"  = predict_JaccardWeighted,
    ## classes
    #"LDA"              = predict_LDA,
    "Correlation"      = predict_Correlation#,
    #"RDA"              = predict_RDA,
    #"SVM"              = predict_SVM#,
    #"SOM"              = predict_SOM,
    #"XYF"              = predict_XYF,
    #"NeuralNet"        = predict_NeuralNet
  )
  
  params <- list(
    ## scores
    "CosinusDistance"  = list(
      list(ratio=FALSE, smoothIntensities=FALSE),
      list(ratio=FALSE, smoothIntensities=TRUE),
      list(ratio=TRUE, smoothIntensities=FALSE),
      list(ratio=TRUE, smoothIntensities=TRUE)
    ),
    "ColSums"          = list(
      list(smoothIntensities=FALSE),
      list(smoothIntensities=TRUE)
    ),
    "ColSumsPos"          = list(
      list(smoothIntensities=FALSE),
      list(smoothIntensities=TRUE)
    ),
    "Prod"             = list(
      list(ratio=FALSE, smoothIntensities=FALSE),
      list(ratio=FALSE, smoothIntensities=TRUE),
      list(ratio=TRUE, smoothIntensities=FALSE),
      list(ratio=TRUE, smoothIntensities=TRUE)
    ),
    "Jaccard"          = list(
      list(ratio=FALSE, smoothIntensities=FALSE),
      list(ratio=FALSE, smoothIntensities=TRUE),
      list(ratio=TRUE, smoothIntensities=FALSE),
      list(ratio=TRUE, smoothIntensities=TRUE)
    ),
    "JaccardWeighted"  = list(
      list(ratio=FALSE, smoothIntensities=FALSE),
      list(ratio=FALSE, smoothIntensities=TRUE),
      list(ratio=TRUE, smoothIntensities=FALSE),
      list(ratio=TRUE, smoothIntensities=TRUE)
    ),
    ## classes
    #"LDA"              = list(
    #  list(ratio=FALSE),
    #  list(ratio=TRUE)
    #),
    "Correlation"      = list(
      list(corMethod = c("pearson", "kendall", "spearman")[[1]], linkage = c("single", "average", "centroid")[[1]], ratio=FALSE, smoothIntensities=FALSE),
      list(corMethod = c("pearson", "kendall", "spearman")[[1]], linkage = c("single", "average", "centroid")[[1]], ratio=FALSE, smoothIntensities=TRUE),
      list(corMethod = c("pearson", "kendall", "spearman")[[1]], linkage = c("single", "average", "centroid")[[1]], ratio=TRUE, smoothIntensities=FALSE),
      list(corMethod = c("pearson", "kendall", "spearman")[[1]], linkage = c("single", "average", "centroid")[[1]], ratio=TRUE, smoothIntensities=TRUE),
      list(corMethod = c("pearson", "kendall", "spearman")[[1]], linkage = c("single", "average", "centroid")[[2]], ratio=FALSE, smoothIntensities=FALSE),
      list(corMethod = c("pearson", "kendall", "spearman")[[1]], linkage = c("single", "average", "centroid")[[2]], ratio=FALSE, smoothIntensities=TRUE),
      list(corMethod = c("pearson", "kendall", "spearman")[[1]], linkage = c("single", "average", "centroid")[[2]], ratio=TRUE, smoothIntensities=FALSE),
      list(corMethod = c("pearson", "kendall", "spearman")[[1]], linkage = c("single", "average", "centroid")[[2]], ratio=TRUE, smoothIntensities=TRUE),
      list(corMethod = c("pearson", "kendall", "spearman")[[1]], linkage = c("single", "average", "centroid")[[3]], ratio=FALSE, smoothIntensities=FALSE),
      list(corMethod = c("pearson", "kendall", "spearman")[[1]], linkage = c("single", "average", "centroid")[[3]], ratio=FALSE, smoothIntensities=TRUE),
      list(corMethod = c("pearson", "kendall", "spearman")[[1]], linkage = c("single", "average", "centroid")[[3]], ratio=TRUE, smoothIntensities=FALSE),
      list(corMethod = c("pearson", "kendall", "spearman")[[1]], linkage = c("single", "average", "centroid")[[3]], ratio=TRUE, smoothIntensities=TRUE),
      #list(corMethod = c("pearson", "kendall", "spearman")[[2]], linkage = c("single", "average", "centroid")[[1]], ratio=FALSE, smoothIntensities=FALSE),
      #list(corMethod = c("pearson", "kendall", "spearman")[[2]], linkage = c("single", "average", "centroid")[[1]], ratio=FALSE, smoothIntensities=TRUE),
      #list(corMethod = c("pearson", "kendall", "spearman")[[2]], linkage = c("single", "average", "centroid")[[1]], ratio=TRUE, smoothIntensities=FALSE),
      #list(corMethod = c("pearson", "kendall", "spearman")[[2]], linkage = c("single", "average", "centroid")[[1]], ratio=TRUE, smoothIntensities=TRUE),
      #list(corMethod = c("pearson", "kendall", "spearman")[[2]], linkage = c("single", "average", "centroid")[[1]], ratio=FALSE, smoothIntensities=FALSE),
      #list(corMethod = c("pearson", "kendall", "spearman")[[2]], linkage = c("single", "average", "centroid")[[1]], ratio=FALSE, smoothIntensities=TRUE),
      #list(corMethod = c("pearson", "kendall", "spearman")[[2]], linkage = c("single", "average", "centroid")[[1]], ratio=TRUE, smoothIntensities=FALSE),
      #list(corMethod = c("pearson", "kendall", "spearman")[[2]], linkage = c("single", "average", "centroid")[[1]], ratio=TRUE, smoothIntensities=TRUE),
      #list(corMethod = c("pearson", "kendall", "spearman")[[2]], linkage = c("single", "average", "centroid")[[1]], ratio=FALSE, smoothIntensities=FALSE),
      #list(corMethod = c("pearson", "kendall", "spearman")[[2]], linkage = c("single", "average", "centroid")[[1]], ratio=FALSE, smoothIntensities=TRUE),
      #list(corMethod = c("pearson", "kendall", "spearman")[[2]], linkage = c("single", "average", "centroid")[[1]], ratio=TRUE, smoothIntensities=FALSE),
      #list(corMethod = c("pearson", "kendall", "spearman")[[2]], linkage = c("single", "average", "centroid")[[1]], ratio=TRUE, smoothIntensities=TRUE),
      list(corMethod = c("pearson", "kendall", "spearman")[[3]], linkage = c("single", "average", "centroid")[[1]], ratio=FALSE, smoothIntensities=FALSE),
      list(corMethod = c("pearson", "kendall", "spearman")[[3]], linkage = c("single", "average", "centroid")[[1]], ratio=FALSE, smoothIntensities=TRUE),
      list(corMethod = c("pearson", "kendall", "spearman")[[3]], linkage = c("single", "average", "centroid")[[1]], ratio=TRUE, smoothIntensities=FALSE),
      list(corMethod = c("pearson", "kendall", "spearman")[[3]], linkage = c("single", "average", "centroid")[[1]], ratio=TRUE, smoothIntensities=TRUE),
      list(corMethod = c("pearson", "kendall", "spearman")[[3]], linkage = c("single", "average", "centroid")[[2]], ratio=FALSE, smoothIntensities=FALSE),
      list(corMethod = c("pearson", "kendall", "spearman")[[3]], linkage = c("single", "average", "centroid")[[2]], ratio=FALSE, smoothIntensities=TRUE),
      list(corMethod = c("pearson", "kendall", "spearman")[[3]], linkage = c("single", "average", "centroid")[[2]], ratio=TRUE, smoothIntensities=FALSE),
      list(corMethod = c("pearson", "kendall", "spearman")[[3]], linkage = c("single", "average", "centroid")[[2]], ratio=TRUE, smoothIntensities=TRUE),
      list(corMethod = c("pearson", "kendall", "spearman")[[3]], linkage = c("single", "average", "centroid")[[3]], ratio=FALSE, smoothIntensities=FALSE),
      list(corMethod = c("pearson", "kendall", "spearman")[[3]], linkage = c("single", "average", "centroid")[[3]], ratio=FALSE, smoothIntensities=TRUE),
      list(corMethod = c("pearson", "kendall", "spearman")[[3]], linkage = c("single", "average", "centroid")[[3]], ratio=TRUE, smoothIntensities=FALSE),
      list(corMethod = c("pearson", "kendall", "spearman")[[3]], linkage = c("single", "average", "centroid")[[3]], ratio=TRUE, smoothIntensities=TRUE)
    )#,
    #"RDA"              = list(
    #  list()
    #),
    #"SVM"              = list(
    #  list(ratio=FALSE, smoothIntensities=FALSE),
    #  list(ratio=TRUE,  smoothIntensities=FALSE),
    #  list(ratio=FALSE, smoothIntensities=TRUE),
    #  list(ratio=TRUE,  smoothIntensities=TRUE)
    #)
    #"SOM"              = list(
    #  list()
    #),
    #"XYF"              = list(
    #  list()
    #),
    #"NeuralNet"        = list(
    #  list()
    #)
  )
  
  algorithms <- list()
  for(methodIdx in seq_along(methods)){
    methodName <- names(methods)[[methodIdx]]
    paramsLists <- params[[methodName]]
    for(paramsListIdx in seq_along(paramsLists)){
      paramsList <- paramsLists[[paramsListIdx]]
      paramsString <- paste(names(paramsList), paramsList[names(paramsList)], sep = "=", collapse = ", ")
      algoName <- paste("method=", methodName, "; ", paramsString, "", sep = "")
      
      algorithms[[length(algorithms) + 1]] <- list(
        "method" = methods[[methodIdx]],
        "methodName" = methodName,
        "params" = paramsList,
        "paramsString" = paramsString,
        "algoName" = algoName
      )
    }
  }
  
  return(algorithms)
}
getAvailableClassifiers_old <- function(resultFolderForClassifiers){
  classifierFilePaths <- list.files(path = resultFolderForClassifiers, recursive = FALSE, pattern = "^.*.RData$", include.dirs = FALSE, full.names = TRUE)
  classifierFiles     <- basename(classifierFilePaths)
  
  pattern <- paste(
    "^Classifier_",
    
    "library=", "(?<library>.+)", "_",
    "Class=", "(?<type>.+)", "_",
    "AltSC=", "(?<altSubstClass>TRUE|FALSE)", "_", 
    "method=", "(?<methodName>.+)", "_",
    "(?<parameters>.+)", "_",
    "NumClasses=", "(?<classes>\\d+)", 
    
    ".RData$", 
    sep = ""
  )
  
  result <- regExExtraction(pattern, classifierFiles)
  
  if(length(classifierFiles) > 0){
    numberOfProperties <- length(names(result[[1]]))
    propertyNames <- names(result[[1]])
    
    df <- data.frame(
      t(matrix(data = unlist(result), nrow = numberOfProperties)),
      stringsAsFactors = FALSE
    )
    
    ## annotate
    rownames(df) <- classifierFilePaths
    colnames(df) <- propertyNames
    
    ## reorder columns
    df <- df[, c(1,6,2,3,4,5)]
  } else {
    return(
      data.frame(matrix(nrow=0, ncol=6))
    )
  }
  return(df)
}

getClassifierProperties <- function(propertiesFile){
  lines <- readLines(con = propertiesFile)
  linesSplitted <- strsplit(x = lines, split = " = ")
  
  tags   <- unlist(lapply(X = linesSplitted, FUN = function(x){x[[1]]}))
  values <- unlist(lapply(X = linesSplitted, FUN = function(x){x[[2]]}))
  propertiesList <- as.list(values)
  names(propertiesList) <- tags
  
  return(propertiesList)
}
## resultFolderForClassifiers <- "/home/htreutle/Code/Java/MetFam/inst/data/classifiers"
## resultFolderForClassifiers <- "/home/htreutle/Code/Java/MetFam/inst/data/classifier"
getAvailableClassifiers <- function(resultFolderForClassifiers){
  
  resultFolderForClassifiers <- gsub(x = resultFolderForClassifiers, pattern = "app/data/classifier", replacement = "inst/data/classifier")
  
  classifierFilePaths <- list.files(path = resultFolderForClassifiers, recursive = FALSE, pattern = "^.*_Classifier.RData$", include.dirs = FALSE, full.names = TRUE)
  classifierFiles     <- basename(classifierFilePaths)
  resultFiles         <- gsub(x = classifierFiles, pattern = "_Classifier.RData$", replacement = "_Results.tsv")
  propertiesFiles     <- gsub(x = classifierFiles, pattern = "_Classifier.RData$", replacement = "_Properties.txt")
  
  propertiesListsList <- list()
  theseClassifiers <- rep(x = TRUE, times = length(classifierFilePaths))
  for(idx in seq_along(propertiesFiles)){
    propertiesFile <- paste(resultFolderForClassifiers, "/", propertiesFiles[[idx]], sep = "")
    propertiesList <- getClassifierProperties(propertiesFile)
    propertiesListsList[[length(propertiesListsList)+1]] <- propertiesList
  }
  
  classifierFilePaths <- classifierFilePaths[theseClassifiers]
  classifierFiles     <- classifierFiles    [theseClassifiers]
  resultFiles         <- resultFiles        [theseClassifiers]
  propertiesFiles     <- propertiesFiles    [theseClassifiers]
  
  if(length(classifierFiles) > 0){
    numberOfProperties <- length(propertiesListsList[[1]])
    propertyNames <- names(propertiesListsList[[1]])
    
    df <- data.frame(
      t(matrix(data = unlist(propertiesListsList), nrow = numberOfProperties)),
      stringsAsFactors = FALSE
    )
    
    ## annotate
    rownames(df) <- classifierFilePaths
    colnames(df) <- propertyNames
    
    libraryNames <- gsub(x = df$library, pattern = "^\\d\\d\\d\\d\\-\\d\\d\\-\\d\\d_\\d\\d:\\d\\d:\\d\\d_", replacement = "")
    libraryNames <- gsub(x = libraryNames, pattern = "\\.[a-zA-Z]{3,4}$", replacement = "")
    df[, "library"]    <- libraryNames
    #df[, "Class"]      <- ifelse(test = df$processSubstanceClasses, yes = rep(x = "SubstanceClass", times = nrow(df)), no = rep(x = "Substituent", times = nrow(df)))
    df[, "Class"]      <- df$classOfClass
    df[, "Resolution"] <- ifelse(test = df$unitResolution, yes = rep(x = "Low", times = nrow(df)), no = rep(x = "High", times = nrow(df)))
    df[, "Classifier"] <- df[, "methodName"]
    df[, "FilePath"]   <- classifierFilePaths
    ## methodName
    
    ## reorder columns
    dfShow       <- df[, c("library", "Class", "Resolution", "Classifier")]
    dfProperties <- df
  } else {
    dfShow       <- data.frame(matrix(nrow=0, ncol= 4))
    dfProperties <- data.frame(matrix(nrow=0, ncol=18))
  }
  
  resultObj <- list()
  resultObj$availableClassifiersDf           <- dfShow
  resultObj$availableClassifiersDfProperties <- dfProperties
  
  return(resultObj)
}

evaluatePutativeMetaboliteFamiliesOfPrecursorSet <- function(dataList, precursorSet, classToSpectra_class){
  if(FALSE){
    dataList_ <<- dataList
    precursorSet_ <<- precursorSet
    classToSpectra_class_ <<- classToSpectra_class
  }
  if(FALSE){
    dataList <<- dataList_
    precursorSet <<- precursorSet_
    classToSpectra_class <<- classToSpectra_class_
  }
  
  ## fetch hits of interest
  classesAll  <- character()
  featuresAll <- integer()
  pValuesAll  <- numeric()
  
  for(classIdx in seq_along(classToSpectra_class)){
    featuresHere <- names(classToSpectra_class[[classIdx]])
    indeces <- which(featuresHere %in% precursorSet)
    if(length(indeces) > 0){
      classes  <- rep(x = names(classToSpectra_class)[[classIdx]], times = length(indeces))
      features <- featuresHere[indeces]
      pValues  <- unname(classToSpectra_class[[classIdx]])[indeces]
      classesAll  <- c(classesAll, classes)
      featuresAll <- c(featuresAll, features)
      pValuesAll  <- c(pValuesAll, pValues)
    }
  }
  detailDf <- data.frame("MS1_feature"=featuresAll, "Class"=classesAll, "pValue"=pValuesAll, stringsAsFactors = FALSE)
  
  if(nrow(detailDf) == 0){
    return(list("overviewDf" = data.frame("Class"=character(), "pValue"=numeric(), "ProportionInPercent" = numeric(), stringsAsFactors = FALSE), "detailDf" = detailDf))
  }
  if(length(precursorSet) == 1){
    ## single precursor
    overviewDf <- cbind(detailDf$Class, detailDf$pValue, rep(x = 100, times = nrow(detailDf)))
    colnames(overviewDf) <- c("Class", "pValue", "ProportionInPercent")
    overviewDf <- as.data.frame(x = overviewDf, stringsAsFactors = FALSE)
    #printPutativeMetaboliteFamilies <- paste(detailDf$Class, " (pValue=", detailDf$pValue, ")", sep = "")
  } else {
    ## multiple precursors: do statistics
    potentialMetaboliteFamilies <- unique(detailDf$Class)
    potentialMetaboliteFamiliesWithSuperClasses <- sort(unique(unlist(
      lapply(X = strsplit(x = potentialMetaboliteFamilies, split = "; "), FUN = function(x){
        x <- x[x != "NA"]
        class <- sapply(X = seq_len(length(x)), FUN = function(y){
          paste(x[1:y], collapse = "; ")
        })
        return(class)
      })
    )))
    precursorHits <- unname(sapply(X = potentialMetaboliteFamiliesWithSuperClasses, FUN = function(class){
      classHits <- grepl(pattern = paste("^", class, sep = ""), x = detailDf$Class)
      count <- length(unique(detailDf$MS1_feature[classHits]))
      return(count)
    }))
    retainClass <- precursorHits >= (length(precursorSet)/2)
    #retainClass <- precursorHits >= 0
    
    if(sum(retainClass) == 0)
      #return(data.frame("Class"=character(), "pValue"=numeric(), "ProportionInPercent" = numeric(), stringsAsFactors = FALSE))
      return(list("overviewDf" = data.frame("Class"=character(), "pValue"=numeric(), "ProportionInPercent" = numeric(), stringsAsFactors = FALSE), "detailDf" = detailDf))
    
    potentialMetaboliteFamiliesWithSuperClasses <- potentialMetaboliteFamiliesWithSuperClasses[retainClass]
    precursorHits <- precursorHits[retainClass]
    
    ## remove classes without relevance
    detailDf <- detailDf[detailDf$Class %in% potentialMetaboliteFamiliesWithSuperClasses, ]
    
    proportionPercent <- precursorHits / length(precursorSet) * 100
    medianPValue <- unlist(unname(sapply(X = potentialMetaboliteFamiliesWithSuperClasses, FUN = function(class){
      classHits <- grepl(pattern = paste("^", class, sep = ""), x = detailDf$Class)
      value <- median(detailDf$pValue[classHits])
      return(value)
    })))
    
    overviewDf <- data.frame(
      "Class" = potentialMetaboliteFamiliesWithSuperClasses, 
      "pValue" = medianPValue,
      "ProportionInPercent" = format(x = proportionPercent, digits=3, nsmall=1), 
      stringsAsFactors = FALSE
    )
    
    #printPutativeMetaboliteFamilies <- paste(overviewDf$Proportion, "% ", overviewDf$Class, sep = "")
  }
  
  returnObj <- list(
    "overviewDf" = overviewDf,
    "detailDf"   = detailDf
  )
  #return(printPutativeMetaboliteFamilies)
  return(returnObj)
}
evaluatePutativeMetaboliteFamiliesOfPrecursorSet_old <- function(dataList, precursorSet, classToSpectra_class){
  if(FALSE){
    dataList_ <<- dataList
    precursorSet_ <<- precursorSet
    classToSpectra_class_ <<- classToSpectra_class
  }
  if(FALSE){
    dataList <<- dataList_
    precursorSet <<- precursorSet_
    classToSpectra_class <<- classToSpectra_class_
  }
  
  ## hits: list of 
  hitLists <- list()
  for(precursorIndex in precursorSet){
    hitLists[[length(hitLists)+1]] <- list()
    for(classIdx in seq_along(classToSpectra_class)){
      if(!(precursorIndex %in% names(classToSpectra_class[[classIdx]])))
        next
      
      idx <- which(names(classToSpectra_class[[classIdx]]) == precursorIndex)
      hitLists[[length(hitLists)]][[length(hitLists[[length(hitLists)]])+1]] <- c(
        "Class"  = names(classToSpectra_class)[[classIdx]],
        "pValue" = unname(classToSpectra_class[[classIdx]])[[idx]]
      )
    }
  }
  
  if(is.null(unlist(hitLists))){
    return("")
  }
  if(length(precursorSet) == 1){
    ## single precursor
    df <- data.frame(t(matrix(data = unlist(hitLists[[1]]), nrow = 2)), stringsAsFactors = F)
    colnames(df) <- c("Class", "pValue")
    printPutativeMetaboliteFamilies <- paste(df$Class, " (pValue=", df$pValue, ")", sep = "")
  } else {
    ## multiple precursors: do statistics
    
    potentialMetaboliteFamilies <- unlist(hitLists)
    potentialMetaboliteFamilies <- potentialMetaboliteFamilies[seq(from = 1, to = length(potentialMetaboliteFamilies), by = 2)]
    potentialMetaboliteFamilies <- unique(potentialMetaboliteFamilies)
    potentialMetaboliteFamiliesWithSuperClasses <- sort(unique(unlist(
      lapply(X = strsplit(x = potentialMetaboliteFamilies, split = "; "), FUN = function(x){
        x <- x[x != "NA"]
        sapply(X = seq_len(length(x)), FUN = function(y){
          paste(x[1:y], collapse = "; ")
        })
      })
    )))
    precursorHitHits <- unname(sapply(X = potentialMetaboliteFamiliesWithSuperClasses, FUN = function(class){
      count <- sum(unlist(lapply(X = hitLists, FUN = function(y){
        classes <- unlist(lapply(X = y, FUN = function(z){z[[1]]}))
        any(grepl(pattern = paste("^", class, sep = ""), x = classes))
      })))
    }))
    retainClass <- rep(x = FALSE, times = length(potentialMetaboliteFamiliesWithSuperClasses))
    for(idx in seq_along(potentialMetaboliteFamiliesWithSuperClasses)){
      these <- grepl(pattern = paste("^", potentialMetaboliteFamiliesWithSuperClasses[[idx]], sep = ""), x = potentialMetaboliteFamiliesWithSuperClasses[-idx])
      if(all(precursorHitHits[-idx][these] < precursorHitHits[[idx]]))
        retainClass[[idx]] <- TRUE
    }
    
    ## at least 50 % of the precursors must be hits of each class
    retainClass <- retainClass & precursorHitHits >= (length(precursorSet)/2)
    
    potentialMetaboliteFamiliesWithSuperClasses <- potentialMetaboliteFamiliesWithSuperClasses[retainClass]
    precursorHitHits <- precursorHitHits[retainClass]
    proportionPercent <- precursorHitHits / length(precursorSet) * 100
    
    df <- data.frame(
      "Class" = potentialMetaboliteFamiliesWithSuperClasses, 
      "Proportion" = format(x = proportionPercent, digits=3, nsmall=1), 
      #"pValue" = 
      stringsAsFactors = F
    )
    
    printPutativeMetaboliteFamilies <- paste(df$Proportion, "% ", df$Class, sep = "")
  }
  return(printPutativeMetaboliteFamilies)
}



#' Title
#'
#' @param dataList 
#' @param precursorSet 
#' @param classToSpectra_class 
#' @param properties_class 
#' @param classifierClass 
#' @param mappingSpectraToClassDf 
#' @param addClassifierConsensusSpectrum 
#'
#' @return
#' @export
#' @importFrom grDevices colorRampPalette
#' 
#'
#' @examples
metaboliteFamilyVersusClass <- function(dataList, precursorSet, classToSpectra_class, properties_class, classifierClass, mappingSpectraToClassDf, addClassifierConsensusSpectrum){
  returnObj <- getSpectrumStatistics(dataList = dataList, precursorSet = precursorSet)
  masses_spec <- returnObj$fragmentMasses
  fragmentCounts_spec <- returnObj$fragmentCounts
  frequency_spec <- fragmentCounts_spec / length(precursorSet)
  
  if(all(addClassifierConsensusSpectrum, classifierClass %in% names(classToSpectra_class))){
    ## Plot spectrum vs consensus spectrum
    classIdx <- which(classifierClass == names(classToSpectra_class))
    classProperties         <- properties_class[[classIdx]]
    frequentFragments       <- classProperties$frequentFragments
    characteristicFragments <- classProperties$characteristicFragments
    
    ## class statistics for class plot
    returnObj <- preprocessClassPlot(frequentFragments, characteristicFragments)
    masses_class    <- returnObj$masses_class
    frequency_class <- returnObj$frequency_class
    #colors_class    <- returnObj$colors_class
    
    ## match spec to class
    returnObj <- preprocessSpectrumVsClassPlot(dataList, precursorSet, masses_class, mappingSpectraToClassDf, "Counts")
    masses_spec <- returnObj$masses_spec
    frequency_spec <- returnObj$intensity_spec
    colors_spec <- returnObj$colors_spec
    numberOfMatchingMasses <- returnObj$numberOfMatchingMasses
    matchingMassRowIndeces <- returnObj$matchingMassRowIndeces
    frequency_spec <- frequency_spec / length(precursorSet)
    
    colors_class    <- rep(x = "grey", times = length(masses_class))
    colors_class[masses_class %in% mappingSpectraToClassDf$ClassMasses[matchingMassRowIndeces]] <- "black"
  } else {
    colors_spec <- rep(x = "black", times = length(masses_spec))
    masses_class    <- NULL
    frequency_class <- NULL
    colors_class    <- NULL
  }
  
  returnObj <- list(
      masses_spec     = masses_spec, 
      intensity_spec  = frequency_spec, 
      colors_spec     = colors_spec, 
      masses_class    = masses_class, 
      frequency_class = frequency_class, 
      colors_class    = colors_class
  )
  return(returnObj)
}
preprocessClassPlot <- function(frequentFragments, characteristicFragments){
  frequentMasses       <- as.numeric(names(frequentFragments)) 
  characteristicMasses <- as.numeric(names(characteristicFragments))
  
  masses_class <- unique(c(frequentMasses, characteristicMasses))
  frequency_class <- rep(x = 0.01, times = length(masses_class))
  frequency_class[match(x = frequentMasses, table = masses_class)] <- unname(frequentFragments)
  
  characteristics_class <- rep(x = 0., times = length(masses_class))
  characteristics_class[match(x = characteristicMasses, table = masses_class)] <- unname(characteristicFragments)
  classDataColorMapFragmentData  <- makecmap(
    x = c(0, 1), n = 100, 
    colFn = colorRampPalette(c('grey', 'black'))
  )
  colors_class <- cmap(x = characteristics_class, map = classDataColorMapFragmentData)
  
  returnObj <- list(
    masses_class = masses_class,
    frequency_class = frequency_class,
    colors_class = colors_class
  )
  return(returnObj)
}
preprocessSpectrumVsClassPlot <- function(dataList, precursorIndeces, masses_class, mappingSpectraToClassDf, yType){
  if(length(precursorIndeces) == 1){
    resultObj   <- getMS2spectrumInfoForPrecursor(dataList = dataList, precursorIndex = precursorIndeces)
    masses_spec <- resultObj$fragmentMasses
    switch(yType, 
           "Counts"={
             intensity_spec <- rep(x = 1, times = length(masses_spec))
           },
           "Intensity"={
             intensity_spec <- resultObj$fragmentAbundances
           },
           {
             stop(paste("Unknown yType", yType))
           }
    )
  } else {
    returnObj   <- getSpectrumStatistics(dataList = dataList, precursorSet = precursorIndeces)
    masses_spec <- returnObj$fragmentMasses
    switch(yType, 
           "Counts"={
             intensity_spec <- returnObj$fragmentCounts
           },
           "Intensity"={
             intensity_spec <- resultObj$fragmentAbundances
           },
           {
             stop(paste("Unknown yType", yType))
           }
    )
  }
  
  tolerance <- .Machine$double.eps ^ 0.5 ## default in function all.equal
  
  
  matchingMassRowIndeces <- which(
    as.character(mappingSpectraToClassDf$SpectraMasses) %in% as.character(masses_spec) &
    as.character(mappingSpectraToClassDf$ClassMasses  ) %in% as.character(masses_class)
  )
  #matchingMassRowIndeces <- which(
  #  apply(X = outer(X = mappingSpectraToClassDf$SpectraMasses, Y = masses_spec , FUN = "-"), MARGIN = 1, FUN = function(x){any(abs(x) <= tolerance)}) &
  #  apply(X = outer(X = mappingSpectraToClassDf$ClassMasses  , Y = masses_class, FUN = "-"), MARGIN = 1, FUN = function(x){any(abs(x) <= tolerance)})
  #)
  
  #matchingMassRowIndeces <- which(
  #  mappingSpectraToClassDf$SpectraMasses %in% masses_spec & 
  #  mappingSpectraToClassDf$ClassMasses   %in% masses_class
  
  specIndeces  <- match(x = mappingSpectraToClassDf$SpectraMasses[matchingMassRowIndeces], table = masses_spec )
  #classIndeces <- match(x = mappingSpectraToClassDf$ClassMasses  [matchingMassRowIndeces], table = masses_class)
  
  colors_spec <- rep(x = "grey", times = length(masses_spec))
  #colors_spec[specIndeces] <- colors_class[classIndeces]
  colors_spec[specIndeces] <- "black"
  
  numberOfMatchingMasses <- length(matchingMassRowIndeces)
  
  returnObj <- list(
    masses_spec = masses_spec,
    intensity_spec = intensity_spec,
    colors_spec = colors_spec,
    numberOfMatchingMasses = numberOfMatchingMasses,
    matchingMassRowIndeces = matchingMassRowIndeces
  )
  return(returnObj)
}

================
File: R/Classifiers.R
================
colSumsPos_classifier <- list(
  train = function(matrix_train, classes_pm_train){
    posRows <- classes_pm_train=="+"
    colSumPos <- Matrix::colSums(x = matrix_train[ posRows, ])
    colSumNeg <- Matrix::colSums(x = matrix_train[!posRows, ])
    
    colSums_PosNeg <- (colSumPos / sum( posRows)) - (colSumNeg / sum(!posRows))
    colSums_PosNeg[colSums_PosNeg < 0] <- 0
    #names(colSums_PosNeg) <- colnames(matrix_train)
    
    ## storage
    colSums_PosNeg <- unname(colSums_PosNeg)
    
    return(colSums_PosNeg)
  },
  classify = function(classifier, matrix_test){
    ## convert matrix format
    dgTMatrix <- as(matrix_test, "dgTMatrix")
    matrixRows <- dgTMatrix@i
    matrixCols <- dgTMatrix@j
    matrixVals <- dgTMatrix@x
    stMatrix_test <- simple_triplet_matrix(
      i    = matrixRows + 1, 
      j    = matrixCols + 1, 
      v    = matrixVals, 
      nrow = nrow(matrix_test), 
      ncol = ncol(matrix_test)
    )
    
    ## score test matrix row by row
    scores <- rowapply_simple_triplet_matrix(x = stMatrix_test, FUN = function(x){
      sum(x * classifier)
    })
    
    return(scores)
  }
)

predict_ColSums <- function(matrix_train, classes_pm_train, matrix_test, classes_pm_test){
  posRows <- classes_pm_train=="+"
  #colSumPos <- apply(X = matrix_train[ posRows, ], MARGIN = 2, FUN = sum)
  #colSumNeg <- apply(X = matrix_train[!posRows, ], MARGIN = 2, FUN = sum)
  colSumPos <- Matrix::colSums(x = matrix_train[ posRows, ])
  colSumNeg <- Matrix::colSums(x = matrix_train[!posRows, ])
  
  colSums <- (colSumPos / sum( posRows)) - (colSumNeg / sum(!posRows))
  
  if(FALSE){
    ## top ten
    names(colSums) <- colnames(matrix_train)
    tail(x = sort(colSums), n = 10)
  }
  
  #scores <- apply(X = matrix_test, MARGIN = 1, FUN = function(x){
  #  sum(x * colSums)
  #})
  
  dgTMatrix <- as(matrix_test, "dgTMatrix")
  matrixRows <- dgTMatrix@i
  matrixCols <- dgTMatrix@j
  matrixVals <- dgTMatrix@x
  stMatrix <- simple_triplet_matrix(i = matrixRows + 1, j = matrixCols + 1, v = matrixVals, nrow=nrow(matrix_test), ncol=ncol(matrix_test))
  
  scores <- rowapply_simple_triplet_matrix(x = stMatrix, FUN = function(x){
    sum(x * colSums)
  })
  
  return(scores)
}
predict_CosinusDistance <- function(matrix_train, classes_pm_train, matrix_test, classes_pm_test, ratio){
  ## sum(a*b) / (sqrt(sum(a*a)) * sqrt(sum(b*b)))
  posRows <- classes_pm_train=="+"
  colSumPos <- apply(X = matrix_train[ posRows, ], MARGIN = 2, FUN = sum)
  colSumNeg <- apply(X = matrix_train[!posRows, ], MARGIN = 2, FUN = sum)
  
  scores_pos <- apply(X = matrix_test, MARGIN = 1, FUN = function(x){
    sum(x * colSumPos) / (sqrt(sum(x * x)) * sqrt(sum(colSumPos * colSumPos)))
  })
  scores_neg <- apply(X = matrix_test, MARGIN = 1, FUN = function(x){
    sum(x * colSumNeg) / (sqrt(sum(x * x)) * sqrt(sum(colSumNeg * colSumNeg)))
  })
  
  if(!ratio){
    scores <- scores_pos
  } else {
    scores <- scores_pos / scores_neg
  }
  
  return(scores)
}
predict_Prod <- function(matrix_train, classes_pm_train, matrix_test, classes_pm_test, ratio){
  ## sum(a*norm(b))
  
  posRows <- classes_pm_train=="+"
  colSumPos <- apply(X = matrix_train[ posRows, ], MARGIN = 2, FUN = sum)
  colSumNeg <- apply(X = matrix_train[!posRows, ], MARGIN = 2, FUN = sum)
  
  colSumPos <- colSumPos / sum(colSumPos)
  colSumNeg <- colSumNeg / sum(colSumNeg)
  
  scores_pos <- apply(X = matrix_test, MARGIN = 1, FUN = function(x){
    sum(x * colSumPos)
  })
  scores_neg <- apply(X = matrix_test, MARGIN = 1, FUN = function(x){
    sum(x * colSumNeg)
  })
  
  if(!ratio){
    scores <- scores_pos
  } else {
    scores <- scores_pos / scores_neg
  }
  
  return(scores)
}
predict_Jaccard <- function(matrix_train, classes_pm_train, matrix_test, classes_pm_test, ratio){
  ## sum(intersection(a,b))/sum(union(a,b))
  
  posRows <- classes_pm_train=="+"
  colSumPos <- apply(X = matrix_train[ posRows, ], MARGIN = 2, FUN = sum)
  colSumNeg <- apply(X = matrix_train[!posRows, ], MARGIN = 2, FUN = sum)
  
  scores_pos <- apply(X = matrix_test, MARGIN = 1, FUN = function(x){
    intersection <- colSumPos > 0 & x > 0
    union        <- colSumPos > 0 | x > 0
    sum(intersection) / sum(union)
  })
  scores_neg <- apply(X = matrix_test, MARGIN = 1, FUN = function(x){
    intersection <- colSumNeg > 0 & x > 0
    union        <- colSumNeg > 0 | x > 0
    sum(intersection) / sum(union)
  })
  
  if(!ratio){
    scores <- scores_pos
  } else {
    scores <- scores_pos / scores_neg
  }
  
  return(scores)
}
predict_JaccardWeighted <- function(matrix_train, classes_pm_train, matrix_test, classes_pm_test, ratio){
  ## sum(intersection(aW,bW))/sum(union(aW,bW))
  
  posRows <- classes_pm_train=="+"
  colSumPos <- apply(X = matrix_train[ posRows, ], MARGIN = 2, FUN = sum)
  colSumNeg <- apply(X = matrix_train[!posRows, ], MARGIN = 2, FUN = sum)
  
  scores_pos <- apply(X = matrix_test, MARGIN = 1, FUN = function(x){
    intersection <- colSumPos > 0 & x > 0
    union        <- colSumPos > 0 | x > 0
    sum(colSumPos[intersection]) / sum(colSumPos[union])
  })
  scores_neg <- apply(X = matrix_test, MARGIN = 1, FUN = function(x){
    intersection <- colSumNeg > 0 & x > 0
    union        <- colSumNeg > 0 | x > 0
    sum(colSumNeg[intersection]) / sum(colSumNeg[union])
  })
  
  if(!ratio){
    scores <- scores_pos
  } else {
    scores <- scores_pos / scores_neg
  }
  
  return(scores)
}

predict_Correlation <- function(matrix_train, classes_pm_train, matrix_test, classes_pm_test, ratio, corMethod = c("pearson", "kendall", "spearman"), linkage = c("single", "average", "centroid")){
  if(corMethod == "kendall")
    stop("Operation not supported")
  
  correlations <- cor(x = t(as.matrix(matrix_test)), y = t(as.matrix(matrix_train)), method = corMethod)
  
  posItems <- classes_pm_train=="+"
  negItems <- classes_pm_train=="-"
  switch(linkage,
         "single"={
           ## single linkage
           scoresPosNeg <- apply(X = correlations, MARGIN = 1, FUN = function(x){
             if(all(is.na(x)))
               return(c("+" = 0, "-" = 1))
             else{
               maxPos <- max(x[posItems], na.rm = TRUE)
               maxNeg <- max(x[negItems], na.rm = TRUE)
               return(c("+" = maxPos, "-" = maxNeg))
             }
           })
         },
         "average"={
           ## average linkage
           scoresPosNeg <- apply(X = correlations, MARGIN = 1, FUN = function(x){
             if(all(is.na(x)))
               return(c("+" = 0, "-" = 1))
             else{
               meanPos <- mean(posItems, na.rm = TRUE)
               meanNeg <- mean(negItems, na.rm = TRUE)
               return(c("+" = meanPos, "-" = meanNeg))
             }
           })
         },
         "centroid"={
           ## centroid linkage
           distPlus  <- as.matrix(dist(matrix_train[posItems, ]))
           #distMinus <- as.matrix(dist(matrix_train[negItems, ]))
           centroidPlus  <- which.min(apply(X = distPlus , MARGIN = 1, FUN = sum))
           #centroidMinus <- which.min(apply(X = distMinus, MARGIN = 1, FUN = sum))
           centroidPlus  <- which(posItems)[[centroidPlus]]
           #centroidMinus <- which(negItems)[[centroidMinus]]
           
           scoresPosNeg <- apply(X = correlations, MARGIN = 1, FUN = function(x){
             if(all(is.na(x)))
               return(c("+" = 0, "-" = 1))
             else{
               centroidPos <- x[[centroidPlus]]
               meanNeg <- mean(x[negItems], na.rm = TRUE)
               return(c("+" = centroidPos, "-" = meanNeg))
             }
           })
         },
         stop(paste("Unknown linkage (", linkage, ")!", sep = ""))
  )
  
  scores_pos <- scoresPosNeg["+", ]
  scores_neg <- scoresPosNeg["-", ]
  
  if(!ratio){
    scores <- scores_pos
  } else {
    scores <- scores_pos / scores_neg
  }
  
  return(scores)
  #return(predicted_classes_pm)
}

colSums_classifier <- list(
  train = function(matrix_train, classes_pm_train){
    posRows <- classes_pm_train=="+"
    colSumPos <- Matrix::colSums(x = matrix_train[ posRows, ])
    colSumNeg <- Matrix::colSums(x = matrix_train[!posRows, ])
    
    colSums_PosNeg <- (colSumPos / sum( posRows)) - (colSumNeg / sum(!posRows))
    #names(colSums_PosNeg) <- colnames(matrix_train)
    
    return(colSums_PosNeg)
  },
  classify = function(classifier, matrix_test){
    ## convert matrix format
    dgTMatrix <- as(matrix_test, "dgTMatrix")
    matrixRows <- dgTMatrix@i
    matrixCols <- dgTMatrix@j
    matrixVals <- dgTMatrix@x
    stMatrix_test <- simple_triplet_matrix(
      i    = matrixRows + 1, 
      j    = matrixCols + 1, 
      v    = matrixVals, 
      nrow = nrow(matrix_test), 
      ncol = ncol(matrix_test)
    )
    
    ## score test matrix
    scores <- rowapply_simple_triplet_matrix(x = stMatrix_test, FUN = function(x){
      sum(x * classifier)
    })
    
    return(scores)
  }
)

================
File: R/DataProcessing.R
================
#' Convert data.frame columns to numeric
#'
#' The data.numericmatrix() function works similar to base::data.matrix()
#' before R-4.0.0 converting character columns to numeric without converting 
#' to factor first, thus returning the actual numeric values.
#' 
#' @param x The data.frame to convert
#'
#' @return A matrix with all columns converted to numeric
#' @export
#'
#' @examples
#' data.numericmatrix(data.frame(a = c("1", "2", "3"), 
#'                               b = c("4", "5", "6")))
#' 
data.numericmatrix <- function(x) {
  for (i in 1:ncol(x)) {
    if (is.character(x[, i])) {
      x[, i] <- as.numeric(as.character(x[, i]))
    }
  }
  as.matrix(x)
}


#########################################################################################
## annotate and process matrix
sparseMatrixToString <- function(matrixRows, matrixCols, matrixVals, parameterSet){
  matrixRows <- c(matrixRows, 1)
  matrixCols <- c(matrixCols, 1)
  matrixVals <- c(matrixVals, serializeParameterSet(parameterSet))
  
  ## TODO performance 25s
  ## convert matrix to dataframe
  numberOfRows    <- max(matrixRows)
  numberOfColumns <- max(matrixCols)
  
  lines <- vector(mode = "character", length = numberOfRows)
  for(rowIdx in seq_len(numberOfRows)){
    indeces <- matrixRows == rowIdx
    tokens  <- vector(mode = "character", length = numberOfColumns)
    tokens[matrixCols[indeces]] <- matrixVals[indeces]
    lines[[rowIdx]] <- paste(tokens, collapse = "\t")
  }
  
  return(lines)
}

#' Read MetFamily Project data saved by the export function
#'
#' Supports reading from plain and gzip'ed files
#' 
#' @param file Path to file to read
#' @param progress Whether to update a shiny Progress bar
#'
#' @return A big dataList. 
#' 
#' @seealso [readProjectData]
#' @export
#'
#' @examples
readClusterDataFromProjectFile <- function(file, progress = FALSE)
{
  if(!is.na(progress))  
    if(progress)  
      setProgress(value = 0, detail = "Parsing") 
  else 
    print("Parsing")
  
  extension <- file_ext(file)
  
  if(extension == "gz") {
    file <- gzfile(file, "r")
  } else {
    file <- file(file, "r")
  }
  
  suppressWarnings(
    fileLines <- readLines(con = file)
  )
  base::close(con = file)

  dataList <- readProjectData(fileLines = fileLines, progress = progress, qfeatures = qfeatures)
  fileLines <- NULL
  
  return(dataList)
}


#' Read MetFamily Project data saved by the export function
#'
#' @param fileLines Character vector with content of a project file
#' @param progress Whether to update a shiny Progress bar
#'
#' @return A big dataList. 
#' 
#' @seealso [processMS1data]
#' @export
#'
#' @examples
readProjectData <- function(fileLines, progress = FALSE, qfeatures = NULL)
{
  allowedTags <- c("ID")
  allowedTagPrefixes <- c("AnnotationColors=")
  
  ##################################################################################################
  ## parse data
  if(!is.na(progress))  
    if(progress)  
      incProgress(amount = 0.1, detail = "Preprocessing") 
  else 
    print("Preprocessing")
  
  numberOfRows <- length(fileLines)
  numberOfMS1features <- as.integer(numberOfRows - 3)
  
  ## header
  line1Tokens <- strsplit(x = fileLines[[1]], split = "\t")[[1]]
  line2Tokens <- strsplit(x = fileLines[[2]], split = "\t")[[1]]
  line3Tokens <- strsplit(x = fileLines[[3]], split = "\t")[[1]]
  
  ## metabolite profile vs fragmentMatrix
  numberOfColumns <- length(line1Tokens)
  line1TokensOffset <- 2
  fragmentMatrixStart <- min(which(line1Tokens[(1 + line1TokensOffset):numberOfColumns] != "")) + line1TokensOffset
  numberOfMetaboliteProfileColumns <- fragmentMatrixStart - 1
  numberOfFragmentGroups <- numberOfColumns - numberOfMetaboliteProfileColumns
  
  ## extract infos from header
  importParameters <- line1Tokens[[1]]
  if(nchar(importParameters) == 0){
    ## import parameterSet not there: backward compatibility - add if not there
    importParameters <- "ImportParameters={projectName=MetFamily project; projectDescription=; toolVersion=MetFamily 1.0; minimumIntensityOfMaximalMS2peak=2000; minimumProportionOfMS2peaks=0.05; mzDeviationAbsolute_grouping=0.01; mzDeviationInPPM_grouping=10; doPrecursorDeisotoping=TRUE; mzDeviationAbsolute_precursorDeisotoping=0.001; mzDeviationInPPM_precursorDeisotoping=10; maximumRtDifference=0.02; doMs2PeakGroupDeisotoping=FALSE; mzDeviationAbsolute_ms2PeakGroupDeisotoping=0.01; mzDeviationInPPM_ms2PeakGroupDeisotoping=10; proportionOfMatchingPeaks_ms2PeakGroupDeisotoping=0.9; mzDeviationAbsolute_mapping=0.01; minimumNumberOfMS2PeaksPerGroup=1; neutralLossesPrecursorToFragments=TRUE; neutralLossesFragmentsToFragments=FALSE}"
  }
  groupSampleDataFrameFieldValue <- line1Tokens[[2]]
  
  fragmentGroupsNumberOfFramgents <- as.integer(line1Tokens[fragmentMatrixStart:numberOfColumns])
  line1Tokens <- NULL
  
  tagsSector <- line2Tokens[seq_len(numberOfMetaboliteProfileColumns)]
  fragmentGroupsAverageIntensity <- as.numeric(line2Tokens[fragmentMatrixStart:numberOfColumns])
  line2Tokens <- NULL
  
  metaboliteProfileColumnNames <- line3Tokens[seq_len(numberOfMetaboliteProfileColumns)]
  fragmentGroupsAverageMass <- as.numeric(line3Tokens[fragmentMatrixStart:numberOfColumns])
  line3Tokens <- NULL
  
  if(any(duplicated(metaboliteProfileColumnNames)))
    stop(paste("Duplicated column names in the metabolite profile: ", 
               paste(sort(unique(metaboliteProfileColumnNames[duplicated(metaboliteProfileColumnNames)])), collapse = "; ")))
  
  #########################################################################
  ## extract metabolite profile and fragment matrix
  metaboliteProfile <- as.data.frame(matrix(nrow = numberOfMS1features, 
                                            ncol = numberOfMetaboliteProfileColumns))
  colnames(metaboliteProfile) <- metaboliteProfileColumnNames
  
  listMatrixRows <- list()
  listMatrixCols <- list()
  listMatrixVals <- list()
  
  lastOut <- proc.time()["user.self"]
  lastRow <- 1
  for(rowIdx in seq_len(numberOfMS1features)){
    time <- proc.time()["user.self"]
    if(time - lastOut > 1){
      lastOut <- time
      rowProgress <- (rowIdx - lastRow) / numberOfMS1features
      lastRow <- rowIdx
      if(!is.na(progress))  
        if(progress)  
          incProgress(amount = rowProgress*0.2,     
                      detail = paste("Preprocessing ", rowIdx, " / ", numberOfMS1features, sep = "")) 
      else 
        print(paste("Preprocessing ", rowIdx, " / ", numberOfMS1features, sep = ""))
    }
    
    lineIdx <- rowIdx + 3
    tokens <- str_split(string = fileLines[[lineIdx]], pattern = "\t")[[1]]
    
    ## metabolite profile
    metaboliteProfile[rowIdx, ] <- tokens[seq_len(numberOfMetaboliteProfileColumns)]
    
    ## fragment matrix
    tokens <- tokens[fragmentMatrixStart:numberOfColumns]
    nonEmpty <- tokens != ""
    indeces <- which(nonEmpty)
    numberOfEntries <- length(indeces)
    listMatrixRows[[rowIdx]] <- rep(x = rowIdx, times = numberOfEntries)
    listMatrixCols[[rowIdx]] <- indeces
    listMatrixVals[[rowIdx]] <- tokens[nonEmpty]
  }
  matrixRows <- as.integer(unlist(listMatrixRows))
  matrixCols <- as.integer(unlist(listMatrixCols))
  matrixVals <- as.numeric(unlist(listMatrixVals))
  listMatrixRows <- NULL
  listMatrixCols <- NULL

  
  ################################################################################
  #Start of importing  annotation part1 from two
  # Display the message and give the user the option to choose whether to upload the annotation file or not. 
  #If Y shows selection window for annotation file. if N ignores annotation process
  #message("Do you want to upload the annotation file? (Y/N)")
  #user_choice <- readline()
  
  ######debugging
  tryCatch(
    {
      rowData(qfeatures)
    },
    error = function(e) {
      message("Error: ", e$message)
      traceback()
    }
  )
  ######debugging
  
  if (!is.null(attr(rowData(qfeatures[[1]]), "annotation column"))) {
    
    # Extract the relevant data: Alignment ID and the annotation column from qfeatures
    annot_colname <- attr(rowData(qfeatures[[1]]), "annotation column")
    annotation_data <- rowData(qfeatures[[1]])[[annot_colname]]
    alignment_ids <- rowData(qfeatures[[1]])[["Alignment ID"]]
    
    # Find the matching indices between metaboliteProfile and annotation_data
    matching_indices <- match(metaboliteProfile[["Alignment_ID"]], alignment_ids)
    
    metaboliteProfile$Annotation[!is.na(matching_indices)] <- annotation_data[matching_indices[!is.na(matching_indices)]] 
   
  }
  
  #####################################################################################################################################
  #end of importing  annotation part1 from two
  
  listMatrixVals <- NULL
  
  ## header
  dataFrameHeader <- cbind(
    data.frame(rbind(
      c(importParameters, rep(x = "", times = numberOfMetaboliteProfileColumns - 1)),
      tagsSector,
      metaboliteProfileColumnNames), stringsAsFactors = FALSE),
    data.frame(rbind(
      fragmentGroupsNumberOfFramgents,
      fragmentGroupsAverageIntensity,
      fragmentGroupsAverageMass
    ), stringsAsFactors = FALSE)
  )
  headerLabels <- c("HeaderForFragmentCounts", 
                    "HeaderForGroupsAndFragmentIntensities", 
                    "Header")
  rownames(dataFrameHeader) <- headerLabels
  headerColumnNames <- c(metaboliteProfileColumnNames, fragmentGroupsAverageMass)
  colnames(dataFrameHeader) <- headerColumnNames
  
  ## import parameterSet
  importParameterSet <- deserializeParameterSet(importParameters)
  
  ## insert annotation column if not there
  annotationColorsName <- "AnnotationColors"
  annotationColorsMapInitValue <- paste(annotationColorsName, "={}", sep = "")
  annotationColumnName <- "Annotation"
  if(!any(metaboliteProfileColumnNames == annotationColumnName, na.rm = TRUE)){
    ## annotation column backward compatibility - insert if not there
    target <- 2
    
    if(target == 0 | target == numberOfMetaboliteProfileColumns)
      stop("Cannot insert column!")
    
    metaboliteProfile <- cbind(
      metaboliteProfile[,seq_len(target),drop=F], 
      as.data.frame(x = rep(x = "", times = numberOfMS1features), stringsAsFactors = FALSE), 
      metaboliteProfile[, (target+1):numberOfMetaboliteProfileColumns, drop=FALSE]
    )
    dataFrameHeader <- cbind(
      dataFrameHeader[,seq_len(target),drop=F], 
      as.data.frame(x = rep(x = "", times = numberOfMS1features), stringsAsFactors = FALSE), 
      dataFrameHeader[, (target+1):numberOfColumns, drop=FALSE]
    )
    numberOfMetaboliteProfileColumns <- numberOfMetaboliteProfileColumns + 1
    metaboliteProfileColumnNames <- c(metaboliteProfileColumnNames[seq_len(target)], 
                                      annotationColumnName, 
                                      metaboliteProfileColumnNames[(target+1):numberOfMetaboliteProfileColumns])
    colnames(metaboliteProfile) <- metaboliteProfileColumnNames
    headerColumnNames <- c(metaboliteProfileColumnNames, fragmentGroupsAverageMass)
    colnames(dataFrameHeader) <- headerColumnNames
    
    dataFrameHeader[2, target + 1] <- annotationColorsMapInitValue
    dataFrameHeader[3, target + 1] <- annotationColumnName
  }

  ## STN: Disabled. 
  if (!is.null(attr(rowData(qfeatures[[1]]), "annotation column"))) {
  #Start of importing annotation part2 from two
  ################################################################################
   #adding HEX color codes from external annotations to the annotationColorsMapInitValue of dataFrameHeader

      # Copy the selected column by user, Remove duplicates and exclude the first row
    uniqueAnnotations <- unique(unlist(strsplit(metaboliteProfile$Annotation, ",")))
    uniqueAnnotations <- paste0(uniqueAnnotations, "=")
    # Add a random string from the hex color list to each element of uniqueAnnotions
    # strings_list <- c("#000000", "#FFFFFF", "#FF0000", "#00FF00", "#0000FF", "#FFFF00", "#FF00FF", "#00FFFF", "#800000", "#008000", "#000080", "#808000", "#800080", "#008080", "#808080", "#C0C0C0", "#FFA500", "#FFC0CB", "#FFD700", "#A52A2A")
    # uniqueAnnotations <- paste0(uniqueAnnotations, sample(strings_list, length(uniqueAnnotations), replace = TRUE))
    allowedCols <- c("blue", "red", "yellow", "green", "brown", "deepskyblue", "orange", "deeppink", "aquamarine", "burlywood", "cadetblue", "coral", "cornflowerblue", "cyan", "firebrick", "goldenrod", "indianred", "khaki", "magenta", "maroon", "beige", "moccasin", "olivedrab", "orangered", "orchid", "paleturquoise3", "rosybrown", "salmon", "seagreen3", "skyblue", "steelblue", "#BF360C", "#33691E", "#311B92", "#880E4F", "#1A237E", "#006064", "#004D40", "#FF6F00", "#E65100")
    uniqueAnnotations <- paste0(uniqueAnnotations, sample(allowedCols, length(uniqueAnnotations), replace = TRUE))
    # Format uniqueAnnotations into a single line with comma-separated values
    uniqueAnnotations1 <- paste(uniqueAnnotations, collapse = ", ")
    #uniqueAnnotationsHexs <- paste("AnnotationColors={", paste(uniqueAnnotations1, collapse = ","), "}")# this line introduces a space after the first Item of the object, therefore, replaced with the following to remove the space
    uniqueAnnotationsHexs <- gsub("AnnotationColors=\\{\\s+", "AnnotationColors={", paste("AnnotationColors={", paste(uniqueAnnotations1, collapse = ","), "}"))
    # Assuming dataFrameHeader is your data frame
    dataFrameHeader$Annotation[2] <- uniqueAnnotationsHexs
  
################################################################################
#End of importing  annotation part2 from two
  }
  
  annotationColumnIndex <- which(metaboliteProfileColumnNames == annotationColumnName)
  annotationColorsValue <- dataFrameHeader[2, annotationColumnIndex]
  
  dataFrameMS1Header <- dataFrameHeader[, seq_len(numberOfMetaboliteProfileColumns)]
  
  ##################################################################################################
  ## MS1 feature IDs
  
  ## mz/rt is aligned by '.'
  mzs <- metaboliteProfile[, "m/z"]
  rts <- metaboliteProfile[, "RT"]
  
  ## add .0 if necessary
  for(i in seq_len(numberOfMS1features))
    if(length(grep(x = mzs[[i]], pattern = ".*\\..*")) == 0)
      mzs[[i]] <- paste(mzs[[i]], ".0", sep = "")
  for(i in seq_len(numberOfMS1features))
    if(length(grep(x = rts[[i]], pattern = ".*\\..*")) == 0)
      rts[[i]] <- paste(rts[[i]], ".0", sep = "")
  
  regexResult <- gregexpr(pattern = "^(?<before>\\d+)\\.(?<after>\\d+)$", text = mzs, perl = TRUE)
  mzStartsBefore  <- unlist(lapply(X = regexResult, FUN = function(x){attr(x = x, which = "capture.start")[[1]]}))
  mzStartsAfter   <- unlist(lapply(X = regexResult, FUN = function(x){attr(x = x, which = "capture.start")[[2]]}))
  mzLengthsBefore <- unlist(lapply(X = regexResult, FUN = function(x){attr(x = x, which = "capture.length")[[1]]}))
  mzLengthsAfter  <- unlist(lapply(X = regexResult, FUN = function(x){attr(x = x, which = "capture.length")[[2]]}))
  
  mzMaxBefore <- max(mzLengthsBefore)
  mzMaxAfter  <- max(mzLengthsAfter )
  
  regexResult <- gregexpr(pattern = "^(?<before>\\d+)\\.(?<after>\\d+)$", text = rts, perl = TRUE)
  rtStartsBefore  <- unlist(lapply(X = regexResult, FUN = function(x){attr(x = x, which = "capture.start")[[1]]}))
  rtStartsAfter   <- unlist(lapply(X = regexResult, FUN = function(x){attr(x = x, which = "capture.start")[[2]]}))
  rtLengthsBefore <- unlist(lapply(X = regexResult, FUN = function(x){attr(x = x, which = "capture.length")[[1]]}))
  rtLengthsAfter  <- unlist(lapply(X = regexResult, FUN = function(x){attr(x = x, which = "capture.length")[[2]]}))
  
  rtMaxBefore <- max(rtLengthsBefore)
  rtMaxAfter  <- max(rtLengthsAfter )
  
  
  maximumNumberOfDecimalPlacesForMz <- 3
  maximumNumberOfDecimalPlacesForRt <- 2
  
  for(idx in seq_along(mzs)){
    mzStartBefore  <- mzStartsBefore [[idx]]
    mzStartAfter   <- mzStartsAfter  [[idx]]
    mzLengthBefore <- mzLengthsBefore[[idx]]
    mzLengthAfter  <- mzLengthsAfter [[idx]]
    
    rtStartBefore  <- rtStartsBefore [[idx]]
    rtStartAfter   <- rtStartsAfter  [[idx]]
    rtLengthBefore <- rtLengthsBefore[[idx]]
    rtLengthAfter  <- rtLengthsAfter [[idx]]
    
    mzBefore <- substr(start = mzStartBefore, stop = mzStartBefore + mzLengthBefore - 1, x = mzs[[idx]])
    mzAfter  <- substr(start = mzStartAfter,  stop = mzStartAfter  + mzLengthAfter  - 1, x = mzs[[idx]])
    
    rtBefore <- substr(start = rtStartBefore, stop = rtStartBefore + rtLengthBefore - 1, x = rts[[idx]])
    rtAfter  <- substr(start = rtStartAfter,  stop = rtStartAfter  + rtLengthAfter  - 1, x = rts[[idx]])
    
    if(nchar(mzBefore) < mzMaxBefore) 
      mzBefore <- paste(
        paste(rep(x = "  ", times = mzMaxBefore - nchar(mzBefore)), collapse = ""),
        mzBefore,
        sep = ""
      )
    if(nchar(mzAfter) > maximumNumberOfDecimalPlacesForMz)
      mzAfter <- substr(x = mzAfter, start = 1, stop = maximumNumberOfDecimalPlacesForMz)
    if(nchar(mzAfter) < maximumNumberOfDecimalPlacesForMz)
      mzAfter <- paste(
        mzAfter,
        paste(rep(x = "0", times = maximumNumberOfDecimalPlacesForMz - nchar(mzAfter)), collapse = ""),
        sep = ""
      )
    
    if(nchar(rtBefore) < rtMaxBefore) 
      rtBefore <- paste(
        paste(rep(x = "  ", times = rtMaxBefore - nchar(rtBefore)), collapse = ""),
        rtBefore,
        sep = ""
      )
    if(nchar(rtAfter) > maximumNumberOfDecimalPlacesForRt)
      rtAfter <- substr(x = rtAfter, start = 1, stop = maximumNumberOfDecimalPlacesForRt)
    if(nchar(rtAfter) < maximumNumberOfDecimalPlacesForRt)
      rtAfter <- paste(
        rtAfter,
        paste(rep(x = "0", times = maximumNumberOfDecimalPlacesForRt - nchar(rtAfter)), collapse = ""),
        sep = ""
      )
    
    mzs[[idx]] <- paste(mzBefore, mzAfter, sep = ".")
    rts[[idx]] <- paste(rtBefore, rtAfter, sep = ".")
  }
  precursorLabels <- paste(mzs, rts, sep = " / ")
  
  ## remove duplicated MS1 features
  duplicated <- which(duplicated(precursorLabels))
  numberOfDuplicated <- length(duplicated)
  if(numberOfDuplicated > 0){
    precursorLabels <- precursorLabels[-duplicated]
    metaboliteProfile <- metaboliteProfile[-duplicated, ]
    numberOfMS1features <- numberOfMS1features - numberOfDuplicated
    for(duplicatedRowIdxIdx in seq_along(duplicated)){
      duplicatedRowIdx <- duplicated[[duplicatedRowIdxIdx]]
      
      ## remove row from matrix
      indeces1 <- which(matrixRows == duplicatedRowIdx)
      if(length(indeces1) == 0)
        next
      
      matrixRows <- matrixRows[-indeces1]
      matrixCols <- matrixCols[-indeces1]
      matrixVals <- matrixVals[-indeces1]
      
      ## update subsequent matrix rows
      indeces2 <- which(matrixRows > duplicatedRowIdx)
      matrixRows[indeces2] <- matrixRows[indeces2] - 1
      
      ## update subsequent duplicated rows
      indeces3 <- which(duplicated > duplicatedRowIdx)
      duplicated[indeces3] <- duplicated[indeces3] - 1
    }
  }
  rownames(metaboliteProfile) <- precursorLabels
  
  #############################################################################################
  ## process features
  if(!is.na(progress))  if(progress)  incProgress(amount = 0.1, detail = "Features") else print("Features")
  
  ## get features
  featureIndeces <- list()
  featureCount <- vector(mode = "numeric", length = numberOfMS1features)
  
  for(i in seq_len(numberOfMS1features)){
    indecesHere <- which(matrixRows == i)
    featureIndecesHere <- matrixCols[indecesHere]
    numberOfFeatures <- length(featureIndecesHere)
    
    featureIndeces[[i]] <- featureIndecesHere
    featureCount[[i]] <- numberOfFeatures
  }
  
  if(!is.na(progress))  if(progress)  incProgress(amount = 0.1, detail = "Feature postprocessing") else print("Feature postprocessing")
  
  ## ms2 plot data
  ms2PlotDataNumberOfFragments <- fragmentGroupsNumberOfFramgents
  ms2PlotDataAverageAbundance  <- fragmentGroupsAverageIntensity
  ms2PlotDataFragmentMasses    <- fragmentGroupsAverageMass
  maxNumberOfFragments <- max(ms2PlotDataNumberOfFragments)
  ms2PlotDataColorMapFragmentData  <- makecmap(
    x = c(0, maxNumberOfFragments), n = 100, 
    colFn = colorRampPalette(c('grey', 'black'))
  )
  
  ## featureMatrix and annotation
  featureMatrix <- sparseMatrix(i = matrixRows, j = matrixCols, x = matrixVals)
  matrixRows <- NULL
  matrixCols <- NULL
  matrixVals <- NULL
  
  rownames(featureMatrix) <- precursorLabels
  colnames(featureMatrix) <- fragmentGroupsAverageMass
  
  ## featureIndexMatrix
  featureIndexMatrix <- matrix(nrow = numberOfMS1features, ncol = max(sapply(X = featureIndeces, FUN = length)))
  rownames(featureIndexMatrix) <- precursorLabels
  for(i in seq_len(numberOfMS1features))
    featureIndexMatrix[i, seq_len(length(featureIndeces[[i]]))] <- featureIndeces[[i]]
  
  minimumMass <- min(fragmentGroupsAverageMass)
  maximumMass <- max(fragmentGroupsAverageMass)
  
  ##################################################################################################
  ## process sample measurements
  
  ## sample columns
  sampleColumns <- tagsSector != ""
  for(allowedTag in allowedTags)
    sampleColumns[grep(x = tagsSector, pattern = paste("^", allowedTag, "$", sep = ""))] <- FALSE
  for(allowedTagPrefix in allowedTagPrefixes)
    sampleColumns[grep(x = tagsSector, pattern = paste("^", allowedTagPrefix, sep = ""))] <- FALSE
  sampleColumns <- which(sampleColumns)
  sampleColumnsStartEnd <- c(min(sampleColumns), max(sampleColumns))
  
  grouXXXps <- unique(tagsSector[sampleColumns])
  numberOfGroups <- length(grouXXXps)
  
  sampleNamesToExclude <- NULL
  
  
  dataColumnIndecesFunctionFromGroupIndex <- function(groupIdx, sampleNamesToExclude = NULL){
    which(tagsSector == grouXXXps[[groupIdx]] & !(metaboliteProfileColumnNames %in% sampleNamesToExclude))
  }
  dataColumnsNameFunctionFromGroupIndex <- function(groupIdx, sampleNamesToExclude = NULL){
    sampleNames = metaboliteProfileColumnNames[dataColumnIndecesFunctionFromGroupIndex(groupIdx = groupIdx, sampleNamesToExclude = sampleNamesToExclude)]
    return(sampleNames)
  }
  dataColumnsNameFunctionFromGroupName <- function(group, sampleNamesToExclude = NULL){
    dataColumnsNameFunctionFromGroupIndex(groupIdx = match(x = group, table = grouXXXps), sampleNamesToExclude = sampleNamesToExclude)
  }
  dataColumnsNameFunctionFromGroupNames <- function(grouXXXps, sampleNamesToExclude = NULL){
    unlist(lapply(X = grouXXXps, FUN = function(x){dataColumnsNameFunctionFromGroupName(group = x, sampleNamesToExclude = sampleNamesToExclude)}))
  }
  groupNameFunctionFromDataColumnName <- function(dataColumnName, sampleNamesToExclude = NULL){
    groupIdx <- which(unlist(lapply(X = grouXXXps, FUN = function(x){
      dataColumnNames <- dataColumnsNameFunctionFromGroupName(group = x, sampleNamesToExclude = sampleNamesToExclude)
      any(dataColumnNames == dataColumnName)
    })))
    grouXXXps[[groupIdx]]
  }
  lfcColumnNameFunctionFromString <- function(columnName){
    tokens <- strsplit(x = columnName, split = "_vs_")[[1]]
    groupOne <- strsplit(x = tokens[[1]], split = "LFC_")[[1]][[2]]
    groupTwo <- tokens[length(tokens)]
    return(c(groupOne, groupTwo))
  }
  dataMeanColumnNameFunctionFromString <- function(columnName){
    group <- substr(x = columnName, start = 1, stop = nchar(columnName) - nchar("_mean"))
    return(group)
  }
  
  ## manage group and samples: order and exclusion
  groupNames  <- tagsSector[sampleColumns]
  sampleNames <- metaboliteProfileColumnNames[sampleColumns]
  
  if(nchar(groupSampleDataFrameFieldValue) == 0){
    ## not there: backward compatibility - add if not there
    groupSampleDataFrame <- data.frame(stringsAsFactors = FALSE, 
                                       "Group"   = groupNames,
                                       "Sample"  = sampleNames,
                                       "Order"   = seq_along(sampleNames),
                                       "Exclude" = rep(x = FALSE, times = length(sampleNames))
    )
  } else {
    groupSampleDataFrame <- deserializeSampleSelectionAndOrder(groupSampleDataFrameFieldValue)
  }
  dataFrameMS1Header[[1,2]] <- serializeSampleSelectionAndOrder(groupSampleDataFrame)
  
  returnObj <- processMS1data(
    sampleNamesToExclude=sampleNamesToExclude, numberOfMS1features=numberOfMS1features, precursorLabels=precursorLabels, 
    grouXXXps=grouXXXps, metaboliteProfileColumnNames=metaboliteProfileColumnNames, tagsSector = tagsSector, 
    dataColumnIndecesFunctionFromGroupIndex=dataColumnIndecesFunctionFromGroupIndex, dataColumnsNameFunctionFromGroupIndex=dataColumnsNameFunctionFromGroupIndex, dataColumnsNameFunctionFromGroupName=dataColumnsNameFunctionFromGroupName, dataColumnsNameFunctionFromGroupNames=dataColumnsNameFunctionFromGroupNames, groupNameFunctionFromDataColumnName=groupNameFunctionFromDataColumnName,
    metaboliteProfile=metaboliteProfile, progress=progress
  )
  
  ## name functions
  dataMeanColumnNameFunctionFromIndex <- returnObj$dataMeanColumnNameFunctionFromIndex
  dataMeanColumnNameFunctionFromName  <- returnObj$dataMeanColumnNameFunctionFromName
  lfcColumnNameFunctionFromIndex      <- returnObj$lfcColumnNameFunctionFromIndex
  lfcColumnNameFunctionFromName       <- returnObj$lfcColumnNameFunctionFromName
  groupNameFromGroupIndex             <- returnObj$groupNameFromGroupIndex
  groupIdxFromGroupName               <- returnObj$groupIdxFromGroupName
  ## data and names
  dataFrameMeasurements               <- returnObj$dataFrameMeasurements
  ## colors
  colorMatrixDataFrame                <- returnObj$colorMatrixDataFrame
  colorMapAbsoluteData                <- returnObj$colorMapAbsoluteData
  colorMapLogFoldChange               <- returnObj$colorMapLogFoldChange
  columnGroupLabels                   <- returnObj$columnGroupLabels
  ## constants
  meanAllMax       <- returnObj$meanAllMax
  logFoldChangeMax <- returnObj$logFoldChangeMax
  logAbsMax        <- returnObj$logAbsMax
  
  #########################################################################################
  ## precursor annotation fields
  if(!is.na(progress))  if(progress)  incProgress(amount = 0.1, detail = "Feature annotations") else print("Feature annotations")
  annotationValueIgnore <- "Ignore"
  annotationColorIgnore <- "red"
  
  ## present annotations
  annotations    <- vector(mode='list', length=numberOfMS1features)
  annoVals <- metaboliteProfile[, annotationColumnName]
  for(i in seq_len(numberOfMS1features)){
    if(nchar(annoVals[[i]]) > 0){
      annotations[[i]] <- as.list(unlist(strsplit(x = annoVals[[i]], split = ", ")))
    }
    else{
      annotations[[i]] <- list()
    }
  }
  
  annoArrayOfLists    <- vector(mode='list', length=numberOfMS1features)
  annoArrayIsArtifact <- vector(mode='logical', length=numberOfMS1features)
  for(i in seq_len(numberOfMS1features)){
    ignoreCheck <- annotations[[i]] == annotationValueIgnore
    ignoreThere <- any(ignoreCheck)
    
    if(ignoreThere){
      idx <- which(ignoreCheck)
      annotations[[i]] <- annotations[[i]][-idx]
    }
    annoArrayOfLists[[i]]    <- annotations[[i]]
    annoArrayIsArtifact[[i]] <- ignoreThere
  }
  
  ## present annos with colors
  annotationColorsMapValue <- substr(
    x = annotationColorsValue, 
    start = nchar(paste(annotationColorsName, "={", sep = "")) + 1, 
    stop = nchar(annotationColorsValue) - nchar("}")
  )
  
  if(nchar(annotationColorsMapValue) > 0){

    annotationColorsMapValuePairs <- unlist(strsplit(x = annotationColorsMapValue, split = ", "))
    annotationColorsMapValues <- unlist(strsplit(x = annotationColorsMapValuePairs, split = "="))
    annotationColorsMapKeys   <- annotationColorsMapValues[seq(from = 1, to = length(annotationColorsMapValues), by = 2)]
    annotationColorsMapValues <- annotationColorsMapValues[seq(from = 2, to = length(annotationColorsMapValues), by = 2)]
  } else {
    annotationColorsMapKeys <- NULL
    annotationColorsMapValues <- NULL
  }
  
  annoPresentAnnotationsList <- list()
  annoPresentColorsList <- list()
  annoPresentAnnotationsList[[1]] <- annotationValueIgnore
  annoPresentColorsList[[1]] <- annotationColorIgnore
  if(length(annotationColorsMapKeys) > 0)
    for(i in seq_len(length(annotationColorsMapKeys))){
      annoPresentAnnotationsList[[1 + i]] <- annotationColorsMapKeys[[i]]
      annoPresentColorsList     [[1 + i]] <- annotationColorsMapValues[[i]]
    }
  
  ## check consistency
  if(!all(unique(unlist(annoArrayOfLists)) %in% unlist(annoPresentAnnotationsList))){
    missing <- unique(unlist(annoArrayOfLists))[!(unique(unlist(annoArrayOfLists)) %in% unlist(annoPresentAnnotationsList))]
    stop(paste("Annotation(s)", paste(missing, collapse = "; "), "missing in present annotations list"))
  }
  if(!all(unlist(annoPresentAnnotationsList) %in% unique(c(annotationValueIgnore, unlist(annoArrayOfLists))))){
    missing <- unlist(annoPresentAnnotationsList)[!(unlist(annoPresentAnnotationsList) %in% unique(c(annotationValueIgnore, unlist(annoArrayOfLists))))]
    stop(paste("Present annotation(s)", paste(missing, collapse = "; "), "missing in annotations"))
  }
  
  ##################################################################################################
  ## box
  if(!is.na(progress))  if(progress)  incProgress(amount = 0.1, detail = "Boxing") else print("Boxing")
  dataList <- list()
  ## data
  dataList$dataFrameHeader <- dataFrameHeader
  dataList$dataFrameMS1Header <- dataFrameMS1Header
  dataList$dataFrameInfos <- metaboliteProfile
  dataList$importParameterSet <- importParameterSet
  dataList$numberOfPrecursors <- numberOfMS1features
  dataList$numberOfDuplicatedPrecursors <- numberOfDuplicated
  dataList$grouXXXps <- grouXXXps
  dataList$columnGroupLabels <- columnGroupLabels
  dataList$groupSampleDataFrame <- groupSampleDataFrame
  dataList$metaboliteProfileColumnNames <- metaboliteProfileColumnNames
  dataList$tagsSector <- tagsSector
  ## data: fragments
  dataList$fragmentMasses <- fragmentGroupsAverageMass
  dataList$fragmentFrequency <- fragmentGroupsNumberOfFramgents
  dataList$fragmentAbundance <- fragmentGroupsAverageIntensity
  dataList$minimumMass <- minimumMass
  dataList$maximumMass <- maximumMass
  dataList$precursorLabels <- precursorLabels
  ## data: abundancies
  dataList$dataFrameMeasurements <- dataFrameMeasurements
  dataList$meanAllMax <- meanAllMax
  dataList$logFoldChangeMax <- logFoldChangeMax
  dataList$logAbsMax <- logAbsMax
  dataList$colorMatrixDataFrame <- colorMatrixDataFrame
  dataList$colorMapAbsoluteData <- colorMapAbsoluteData
  dataList$colorMapLogFoldChange <- colorMapLogFoldChange
  ## data: column name functions
  dataList$dataColumnsNameFunctionFromGroupName <- dataColumnsNameFunctionFromGroupName
  dataList$dataColumnsNameFunctionFromGroupIndex <- dataColumnsNameFunctionFromGroupIndex
  dataList$dataColumnsNameFunctionFromGroupNames <- dataColumnsNameFunctionFromGroupNames
  dataList$groupNameFunctionFromDataColumnName <- groupNameFunctionFromDataColumnName
  dataList$lfcColumnNameFunctionFromString <- lfcColumnNameFunctionFromString
  dataList$dataMeanColumnNameFunctionFromString <- dataMeanColumnNameFunctionFromString
  dataList$dataColumnIndecesFunctionFromGroupIndex <- dataColumnIndecesFunctionFromGroupIndex
  dataList$dataMeanColumnNameFunctionFromName <- dataMeanColumnNameFunctionFromName
  dataList$dataMeanColumnNameFunctionFromIndex <- dataMeanColumnNameFunctionFromIndex
  dataList$lfcColumnNameFunctionFromName <- lfcColumnNameFunctionFromName
  dataList$lfcColumnNameFunctionFromIndex <- lfcColumnNameFunctionFromIndex
  dataList$groupNameFromGroupIndex <- groupNameFromGroupIndex
  dataList$groupIdxFromGroupName <- groupIdxFromGroupName
  ## features
  dataList$featureMatrix <- featureMatrix
  dataList$featureIndeces <- featureIndeces
  dataList$featureCount <- featureCount
  dataList$featureIndexMatrix <- featureIndexMatrix
  ## ms2 plot data
  dataList$ms2_numberOfFragments <- ms2PlotDataNumberOfFragments
  dataList$ms2_averageAbundance  <- ms2PlotDataAverageAbundance
  dataList$ms2_masses            <- ms2PlotDataFragmentMasses
  dataList$colorMapFragmentData <- ms2PlotDataColorMapFragmentData
  ## annotations
  dataList$annotationColumnName <- annotationColumnName
  dataList$annotationColorsName <- annotationColorsName
  dataList$annotationColumnIndex <- annotationColumnIndex
  dataList$annotationValueIgnore <- annotationValueIgnore
  dataList$annotationColorIgnore <- annotationColorIgnore
  dataList$annoArrayOfLists <- annoArrayOfLists
  dataList$annoArrayIsArtifact <- annoArrayIsArtifact
  dataList$annoPresentAnnotationsList <- annoPresentAnnotationsList
  dataList$annoPresentColorsList <- annoPresentColorsList
  
  if(!is.na(progress))  if(progress)  setProgress(1) else print("Ready")
  
  
  ## redefine MS1 column functions
  dataColumnIndecesFunctionFromGroupIndex <- function(groupIdx, sampleNamesToExclude){
    which(dataList$tagsSector == dataList$grouXXXps[[groupIdx]] & !(dataList$metaboliteProfileColumnNames %in% sampleNamesToExclude))
  }
  dataList$dataColumnIndecesFunctionFromGroupIndex <- dataColumnIndecesFunctionFromGroupIndex
  dataColumnsNameFunctionFromGroupIndex <- function(groupIdx, sampleNamesToExclude){
    dataList$metaboliteProfileColumnNames[dataList$dataColumnIndecesFunctionFromGroupIndex(groupIdx = groupIdx, sampleNamesToExclude = sampleNamesToExclude)]
  }
  dataList$dataColumnsNameFunctionFromGroupIndex <- dataColumnsNameFunctionFromGroupIndex
  dataColumnsNameFunctionFromGroupName <- function(group, sampleNamesToExclude){
    dataColumns <- dataList$dataColumnsNameFunctionFromGroupIndex(groupIdx = match(x = group, table = dataList$grouXXXps), sampleNamesToExclude = sampleNamesToExclude)
  }
  dataList$dataColumnsNameFunctionFromGroupName <- dataColumnsNameFunctionFromGroupName
  dataColumnsNameFunctionFromGroupNames <- function(grouXXXps, sampleNamesToExclude){
    unlist(lapply(X = grouXXXps, FUN = function(x){
      dataList$dataColumnsNameFunctionFromGroupName(group = x, sampleNamesToExclude = sampleNamesToExclude)
    }))
  }
  dataList$dataColumnsNameFunctionFromGroupNames <- dataColumnsNameFunctionFromGroupNames
  groupNameFunctionFromDataColumnName <- function(dataColumnName, sampleNamesToExclude){
    groupIdx <- which(unlist(lapply(X = dataList$grouXXXps, FUN = function(x){
      dataColumnNames <- dataList$dataColumnsNameFunctionFromGroupName(group = x, sampleNamesToExclude = sampleNamesToExclude)
      any(dataColumnNames == dataColumnName)
    })))
    dataList$grouXXXps[[groupIdx]]
  }
  dataList$groupNameFunctionFromDataColumnName <- groupNameFunctionFromDataColumnName
  
  orderColumnNames <- function(groupSampleDataFrame, columnNames){
    order <- groupSampleDataFrame[groupSampleDataFrame[, "Sample"] %in% columnNames, "Order"]
    list <- list()
    list[order] <- columnNames
    columnNames <- unlist(list)
    return(columnNames)
  }
  dataList$orderColumnNames <- orderColumnNames
  
  ## define sample in-/exclusion functions
  excludedSamples <- function(groupSampleDataFrame, grouXXXps = dataList$grouXXXps){
    samples    =  groupSampleDataFrame[, "Sample"]
    isExcluded =  groupSampleDataFrame[, "Exclude"]
    isGroup    =  groupSampleDataFrame[, "Group"] %in% grouXXXps
    return(samples[isExcluded & isGroup])
  }
  dataList$excludedSamples <- excludedSamples
  includedSamples <- function(groupSampleDataFrame, grouXXXps = dataList$grouXXXps){
    samples    =  groupSampleDataFrame[, "Sample"]
    isIncluded = !groupSampleDataFrame[, "Exclude"]
    isGroup    =  groupSampleDataFrame[, "Group"] %in% grouXXXps
    return(samples[isIncluded & isGroup])
  }
  dataList$includedSamples <- includedSamples
  
  includedGroups <- function(groupSampleDataFrame, samples = dataList$groupSampleDataFrame[, "Sample"]){
    unique(unlist(lapply(X = intersect(samples, dataList$includedSamples(groupSampleDataFrame)), FUN = function(sampleName){
      dataList$groupNameFunctionFromDataColumnName(dataColumnName = sampleName, sampleNamesToExclude = dataList$excludedSamples(dataList$groupSampleDataFrame))
    })))
  }
  dataList$includedGroups <- includedGroups
  excludedGroups <- function(groupSampleDataFrame, samples = dataList$groupSampleDataFrame[, "Sample"]){
    setdiff(dataList$grouXXXps, dataList$includedGroups(groupSampleDataFrame, samples)) 
  }
  dataList$excludedGroups <- excludedGroups
  
  return(dataList)
}

#' Process MS-Dial-like MS1 data.frame
#' 
#' Processing of MS-Dial-like MS1 data.frame. Includes calculation 
#' of MS1 data mean and log-fold-change (LFC) data
#'
#' @param sampleNamesToExclude 
#' @param numberOfMS1features 
#' @param precursorLabels 
#' @param grouXXXps 
#' @param metaboliteProfileColumnNames 
#' @param dataColumnIndecesFunctionFromGroupIndex 
#' @param dataColumnsNameFunctionFromGroupIndex 
#' @param dataColumnsNameFunctionFromGroupName 
#' @param dataColumnsNameFunctionFromGroupNames 
#' @param groupNameFunctionFromDataColumnName 
#' @param tagsSector 
#' @param metaboliteProfile 
#' @param progress 
#'
#' @return
#' @export
#' @importFrom grDevices colorRampPalette rainbow
#'
#' @examples
processMS1data <- function(sampleNamesToExclude, 
                           numberOfMS1features, 
                           precursorLabels, 
                           grouXXXps, 
                           metaboliteProfileColumnNames, 
                           dataColumnIndecesFunctionFromGroupIndex, 
                           dataColumnsNameFunctionFromGroupIndex, 
                           dataColumnsNameFunctionFromGroupName, 
                           dataColumnsNameFunctionFromGroupNames, 
                           groupNameFunctionFromDataColumnName,
                           tagsSector, 
                           metaboliteProfile, 
                           progress=FALSE)
{
  numberOfGroups <- length(grouXXXps)
  
  ####################
  ## MS1 measurement data: mean and LFC
  if(!is.na(progress))  
    if(progress)  
      incProgress(amount = 0.1, detail = "Coloring") 
  else 
    print("Coloring")

  if(!is.na(progress))  
    if(progress)  
      incProgress(amount = 0, detail = "Coloring init") 
  else 
    print("Coloring init")
  
  dataFrameMeasurements <- data.frame(matrix(nrow = numberOfMS1features, ncol = 0))
  rownames(dataFrameMeasurements) <- precursorLabels
  
  ## column name functions
  if(!is.na(progress))  
    if(progress)  
      incProgress(amount = 0, detail = "Coloring naming functions") 
  else 
    print("Coloring naming functions")
  
  ## store data of grouXXXps
  dataColumnNames <- list()
  for(groupIdx in seq_len(numberOfGroups)){
    dataColumnNamesHere <- dataColumnsNameFunctionFromGroupIndex(groupIdx = groupIdx, 
                                                                 sampleNamesToExclude = sampleNamesToExclude)
    dataColumnNames <- c(dataColumnNames, dataColumnNamesHere)
    dataFrameMeasurements[, dataColumnNamesHere] <- data.numericmatrix(metaboliteProfile[, dataColumnIndecesFunctionFromGroupIndex(groupIdx = groupIdx, 
                                                                                                                                   sampleNamesToExclude = sampleNamesToExclude), 
                                                                                         drop = FALSE])
  }
  dataColumnNames <- unlist(dataColumnNames)
  
  dataMeanColumnNameFunctionFromName  <- function(group){
    return(paste(group, "_mean", sep = ""))
  }
  
  dataMeanColumnNameFunctionFromIndex  <- function(groupIdx){
    return(dataMeanColumnNameFunctionFromName(grouXXXps[[groupIdx]]))
  }
  
  lfcColumnNameFunctionFromName <- function(groupOne, groupTwo){
    return(paste("LFC", groupOne, "vs", groupTwo, sep = "_"))
  }
  
  lfcColumnNameFunctionFromIndex <- function(groupIdxOne, groupIdxTwo){
    lfcColumnNameFunctionFromName(grouXXXps[[groupIdxOne]], grouXXXps[[groupIdxTwo]])
  }
  
  groupNameFromGroupIndex <- function(groupIdx){
    return(grouXXXps[[groupIdx]])
  }
  
  groupIdxFromGroupName <- function(group){
    return(match(x = group, table = grouXXXps))
  }
  
  if(!is.na(progress))  
    if(progress)  incProgress(amount = 0, detail = "Coloring gather data") 
  else 
    print("Coloring gather data")
  
  ## mean data columns
  dataMeanColumnNames <- list()
  for(groupIdx in seq_len(numberOfGroups)){
    dataMeanColumnName <- dataMeanColumnNameFunctionFromIndex(groupIdx)
    dataMeanColumnNames[[groupIdx]] <- dataMeanColumnName
    if(is(unlist(metaboliteProfile[, dataColumnIndecesFunctionFromGroupIndex(groupIdx = groupIdx, sampleNamesToExclude = sampleNamesToExclude)]),"character"))
      for(colIdx in dataColumnIndecesFunctionFromGroupIndex(groupIdx = groupIdx, sampleNamesToExclude = sampleNamesToExclude))
        metaboliteProfile[, colIdx] <- as.numeric(metaboliteProfile[, colIdx])
    
    dataFrameMeasurements[, dataMeanColumnName] <- apply(X = data.numericmatrix(metaboliteProfile[, dataColumnIndecesFunctionFromGroupIndex(groupIdx = groupIdx, sampleNamesToExclude = sampleNamesToExclude), drop=FALSE]), MARGIN = 1, FUN = mean)
    dataFrameMeasurements[is.na(dataFrameMeasurements[, dataMeanColumnName]), dataMeanColumnName] <- 0
  }
  dataMeanColumnNames <- unlist(dataMeanColumnNames)
  
  ## all replicates mean
  dataFrameMeasurements[, "meanAllNormed"] <- apply(
    X = data.numericmatrix(metaboliteProfile[, 
                                             unlist(lapply(X = seq_len(numberOfGroups), FUN = function(x) {dataColumnIndecesFunctionFromGroupIndex(groupIdx = x, sampleNamesToExclude = sampleNamesToExclude)})),
                                             drop=FALSE]), 
    MARGIN = 1, FUN = mean
  )
  
  meanAllMax <- max(dataFrameMeasurements[, "meanAllNormed"])
  if(meanAllMax != 0)
    dataFrameMeasurements[, "meanAllNormed"] <- dataFrameMeasurements[, "meanAllNormed"] / meanAllMax
  
  ## log fold change between grouXXXps
  lfcColumnNames <- list()
  for(groupIdx1 in seq_len(numberOfGroups))
    for(groupIdx2 in seq_len(numberOfGroups)){
      lfcColumnName <- lfcColumnNameFunctionFromIndex(groupIdx1, groupIdx2)
      lfcColumnNames[[length(lfcColumnNames) + 1]] <- lfcColumnName
      dataFrameMeasurements[, lfcColumnName] <- log(
        x = dataFrameMeasurements[, dataMeanColumnNameFunctionFromIndex(groupIdx1)] / dataFrameMeasurements[, dataMeanColumnNameFunctionFromIndex(groupIdx2)], 
        base = 2
      )
      
      ## tackle zero values
      dataFrameMeasurements[is.na(dataFrameMeasurements[, lfcColumnName]), lfcColumnName] <- 0
      dataFrameMeasurements[is.infinite(dataFrameMeasurements[, lfcColumnName]), lfcColumnName] <- 0
    }
  lfcColumnNames <- unlist(lfcColumnNames)
  
  
  #########################################################################################
  ## MS1 measurement data to colors
  if(!is.na(progress))  
    if(progress)  
      incProgress(amount = 0, detail = "Coloring matrix") 
  else 
    print("Coloring matrix")
  
  matrixDataFrame <- data.numericmatrix(dataFrameMeasurements)
  
  matrixDataFrame[, dataColumnNames    ][matrixDataFrame[, dataColumnNames    ] < 1] <- 1
  matrixDataFrame[, dataMeanColumnNames][matrixDataFrame[, dataMeanColumnNames] < 1] <- 1

  matrixDataFrame[, dataColumnNames]     <- log10(matrixDataFrame[, dataColumnNames])
  matrixDataFrame[, dataMeanColumnNames] <- log10(matrixDataFrame[, dataMeanColumnNames])
  matrixDataFrame[is.infinite(matrixDataFrame)] <- 0

  ## min / max
  logAbsMin <- min(0, min(matrixDataFrame[, dataMeanColumnNames]))
  logAbsMax <- max(matrixDataFrame[, c(dataColumnNames, dataMeanColumnNames)])
  logFoldChangeMinMax <- c(min(matrixDataFrame[, lfcColumnNames]), max(matrixDataFrame[, lfcColumnNames]))
  logFoldChangeMax <- max(abs(logFoldChangeMinMax))
  if(logFoldChangeMax < 1)
    logFoldChangeMax <- 1
  
  ## maps
  colorMapAbsoluteData  <- makecmap(
    x = c(logAbsMin, logAbsMax), n = 100, 
    colFn = colorRampPalette(rainbow(18)[10:1])
  )
  colorMapLogFoldChange <- makecmap(
    x = c(-logFoldChangeMax, logFoldChangeMax), n = 100, 
    colFn = colorRampPalette(c('blue', 'white', 'red'))
  )
  
  columnGroupLabels <- sapply(X = grouXXXps, 
                              FUN = function(x){ 
                                rep(x = x, 
                                    times = length(dataColumnsNameFunctionFromGroupName(group = x, 
                                                                                        sampleNamesToExclude = sampleNamesToExclude))) 
                              })
  
  ## translate and box colors
  if(!is.na(progress))  
    if(progress)  
      incProgress(amount = 0, detail = "Coloring box") 
  else 
    print("Coloring box")
  
  colorDataFrame <- dataFrameMeasurements
  colorDataFrame[, dataColumnNames    ] <- cmap(x = matrixDataFrame[, dataColumnNames    ], map = colorMapAbsoluteData)
  colorDataFrame[, dataMeanColumnNames] <- cmap(x = matrixDataFrame[, dataMeanColumnNames], map = colorMapAbsoluteData)
  colorDataFrame[, lfcColumnNames]      <- cmap(x = matrixDataFrame[, lfcColumnNames     ], map = colorMapLogFoldChange)
  colorMatrixDataFrame <- as.matrix(colorDataFrame)
  
  returnObj <- list(
    ## name functions
    dataMeanColumnNameFunctionFromIndex=dataMeanColumnNameFunctionFromIndex,
    dataMeanColumnNameFunctionFromName=dataMeanColumnNameFunctionFromName,
    lfcColumnNameFunctionFromIndex=lfcColumnNameFunctionFromIndex,
    lfcColumnNameFunctionFromName=lfcColumnNameFunctionFromName,
    groupNameFromGroupIndex=groupNameFromGroupIndex,
    groupIdxFromGroupName=groupIdxFromGroupName,
    ## data and names
    dataFrameMeasurements=dataFrameMeasurements,
    ## colors
    colorMatrixDataFrame=colorMatrixDataFrame,
    colorMapAbsoluteData=colorMapAbsoluteData,
    colorMapLogFoldChange=colorMapLogFoldChange,
    columnGroupLabels=columnGroupLabels,
    ## constants
    meanAllMax=meanAllMax,
    logFoldChangeMax=logFoldChangeMax,
    logAbsMax=logAbsMax
  )
}

serializeSampleSelectionAndOrder <- function(groupSampleDataFrame)
{
  ## wrap columns
  columnsSerialized <- sapply(X = seq_len(ncol(groupSampleDataFrame)), FUN = function(colIdx){
    cellContent <- paste(groupSampleDataFrame[, colIdx], collapse = "; ")
    paste(colnames(groupSampleDataFrame)[[colIdx]], "=", "(", cellContent, ")", sep = "")
  })
  ## box
  groupSampleDataFrameName <- "SampleSelectionAndOrder"
  groupSampleDataFrameValue <- paste(columnsSerialized, collapse = "|")
  groupSampleDataFrameFieldValue <- paste(groupSampleDataFrameName, "=", "{", groupSampleDataFrameValue, "}", sep = "")
  
  return(groupSampleDataFrameFieldValue)
}

deserializeSampleSelectionAndOrder <- function(groupSampleDataFrameFieldValue){
  ## unbox
  groupSampleDataFrameName <- "SampleSelectionAndOrder"
  groupSampleDataFrameValue <- substr(
    x = groupSampleDataFrameFieldValue, 
    start = nchar(paste(groupSampleDataFrameName, "={", sep = "")) + 1, 
    stop = nchar(groupSampleDataFrameFieldValue) - nchar("}")
  )
  
  ## unwrap
  columnsSerialized <- strsplit(x = groupSampleDataFrameValue, split = "\\|")[[1]]
  columnNames = unlist(lapply(X = strsplit(x = columnsSerialized, split = "="), FUN = function(x){
    x[[1]]
  }))
  groupSampleDataFrame <- as.data.frame(stringsAsFactors = FALSE, lapply(X = strsplit(x = columnsSerialized, split = "="), FUN = function(x){
    cellContent <- x[[2]]
    cellContent <- substr(
      x = cellContent, 
      start = 1 + nchar("("), 
      stop = nchar(cellContent) - nchar(")")
    )
    cellContent <- strsplit(x = cellContent, split = "; ")
  }))
  colnames(groupSampleDataFrame) <- columnNames
  
  groupSampleDataFrame[, "Order"]   <- as.integer(groupSampleDataFrame[, "Order"])
  groupSampleDataFrame[, "Exclude"] <- as.logical(groupSampleDataFrame[, "Exclude"])
  
  return(groupSampleDataFrame)
}

serializeParameterSetFile <- function(importParameterSet, toolName, toolVersion){
  ## wrap
  importParametersValue <- paste(names(importParameterSet), importParameterSet, sep = "=", collapse = "\n")
  ## box
  comment <- paste(
    "# This is the set of parameters which have been used for the initial data import to ",
    importParameterSet$toolVersion,
    "\n",
    "# Exported with ",
    toolName, " ", toolVersion,
    sep = ""
  )
  importParametersFileValue <- paste(comment, importParametersValue, sep = "\n")
  return(importParametersFileValue)
}

deserializeParameterSetFile <- function(importParametersFileContent){
  ## remove comments
  importParametersValuePairs <- importParametersFileContent[-grep(pattern = "#.*", x = importParametersFileContent)]
  ## deserialize
  importParameterSet <- deserializeParameterSetKeyValuePairs(importParametersValuePairs)
  return(importParameterSet)
}

serializeParameterSet <- function(importParameterSet){
  ## wrap
  importParametersValue <- paste(names(importParameterSet), importParameterSet, sep = "=", collapse = "; ")
  ## box
  importParametersName <- "ImportParameters"
  importParametersFieldValue <- paste(importParametersName, "={", importParametersValue, "}", sep = "")
  return(importParametersFieldValue)
}

deserializeParameterSet <- function(importParametersFieldValue){
  ## unbox
  importParametersName <- "ImportParameters"
  importParametersValue <- substr(
    x = importParametersFieldValue, 
    start = nchar(paste(importParametersName, "={", sep = "")) + 1, 
    stop = nchar(importParametersFieldValue) - nchar("}")
  )
  
  ## unwrap
  importParametersValuePairs <- unlist(strsplit(x = importParametersValue, split = "; "))
  importParameterSet <- deserializeParameterSetKeyValuePairs(importParametersValuePairs)
  return(importParameterSet)
}

deserializeParameterSetKeyValuePairs <- function(importParametersValuePairs){
  ## unwrap
  importParametersValuePairsList <- strsplit(x = importParametersValuePairs, split = "=")
  
  ## catch empty parameter values
  for(i in seq_len(length(importParametersValuePairsList)))
    if(length(importParametersValuePairsList[[i]]) == 1)
      importParametersValuePairsList[[i]][[2]] <- ""
    
    ## split
    importParametersValues <- unlist(importParametersValuePairsList)
    importParametersKeys   <- importParametersValues[seq(from = 1, to = length(importParametersValues), by = 2)]
    importParametersValues <- importParametersValues[seq(from = 2, to = length(importParametersValues), by = 2)]
    
    ## box to list
    importParameterSet        <- as.list(importParametersValues)
    names(importParameterSet) <- importParametersKeys
    
    ## cast logical's and numeric's
    importParameterSet <- castListEntries(importParameterSet)
    return(importParameterSet)
}

#' Cast logical's and numeric's in a list or data.frame
#'
#' Tries to cast a list entry (or column in a data.frame) to logical's, 
#' if that does not create any missing values, it is assumed 
#' to be a logical will be replaced by `as.logical()` conversion.
#' Similarly for numeric entries (or columns). Everything else remains strings
#' 
#' @param list 
#'
#' @return list of the same lenght with logical's and numeric's casted
#' @export
#'
#' @examples
castListEntries <- function(list){
  ## cast logical's and numeric's
  suppressWarnings(
    for(idx in seq_len(length(list))){
      if(!is.na(as.logical(list[[idx]]))){
        ## logical
        list[[idx]] <- as.logical(list[[idx]])
      } else if(!is.na(as.numeric(list[[idx]]))){
        ## numeric
        list[[idx]] <- as.numeric(list[[idx]])
      } else {
        ## string
      }
    }
  )
  
  return(list)
}

#########################################################################################
## annotation stuff
precursorSetToSetOfAnnotationSets <- function(dataList, precursorSet){
  setOfAnnotationSets <- lapply(X = precursorSet, FUN = function(x){
    annotationSet <- dataList$annoArrayOfLists[[x]]
    if(dataList$annoArrayIsArtifact[[x]])
      annotationSet <- c(annotationSet, "Ignore")
    return(unlist(annotationSet))
  })
  return(setOfAnnotationSets)
}
setOfAnnotationSetsToSetOfColorSets <- function(dataList, setOfAnnotationSets){
  setOfColorSets <- lapply(X = setOfAnnotationSets, FUN = function(x){
    if(is.null(x))
      ## no annotation
      colors <- "black"
    else
      ## at least one annotation
      colors <- unlist(lapply(X = x, FUN = function(y){
        dataList$annoPresentColorsList[[match(x = y, table = dataList$annoPresentAnnotationsList)]] }
      ))
    
    return(colors)
  })
  return(setOfColorSets)
}
getPrecursorColors <- function(dataList, precursorSet){
  setOfAnnotationSets <- precursorSetToSetOfAnnotationSets(dataList, precursorSet)
  setOfColorSets      <- setOfAnnotationSetsToSetOfColorSets(dataList, setOfAnnotationSets)
  setOfColors <- lapply(X = setOfColorSets, FUN = function(x){
    if(any(x == "red"))
      ## at least one annotation is ignore --> take ignore
      color <- "red"
    else{
      switch(as.character(length(x)),
             "0"={## no annotation
               color <- "black"
             },
             "1"={## one annotation
               color <- x
             },
             {## multiple annotations --> take the one which is primary
               color <- x[[1]]
             }
      )## end switch
    }## end else
  })## end lapply
  setOfAnnotations <- lapply(X = setOfAnnotationSets, FUN = function(x){
    if(any(x == "Ignore"))
      ## at least one annotation is ignore --> take ignore
      annotation <- "Ignore"
    else{
      switch(as.character(length(x)),
             "0"={## no annotation
               annotation <- "Unknown"
             },
             "1"={## one annotation
               annotation <- x
             },
             {## multiple annotations --> take the one which is primary
               annotation <- x[[1]]
             }
      )## end switch
    }## end else
  })## end lapply
  
  resultList <- list(
    setOfColors      = unlist(setOfColors),
    setOfAnnotations = unlist(setOfAnnotations)
  )
  
  #return(unlist(setOfColors))
  return(resultList)
}

#########################################################################################
## data fetching
getMetFragLink <- function(dataList, precursorIndex, outAdductWarning = TRUE){
  features <- dataList$featureIndeces[[precursorIndex]]
  fragmentsX <- dataList$fragmentMasses[features]
  fragmentsY <- as.numeric(dataList$featureMatrix[precursorIndex, features])
  fragmentsY[fragmentsY > 1] <- 1
  
  precursorMass  <- as.numeric(dataList$dataFrameInfos$"m/z"[[precursorIndex]])
  adduct <- "Unknown"
  if("Adduct ion name" %in% colnames(dataList$dataFrameInfos))
    adduct <- dataList$dataFrameInfos$"Adduct ion name"[[precursorIndex]]
  if("Adduct.ion.name" %in% colnames(dataList$dataFrameInfos))
    adduct <- dataList$dataFrameInfos$"Adduct.ion.name"[[precursorIndex]]
  neutralMassCorrection <- NA
  ionMode <- NA
  #generateLink <- TRUE
  
  error <- NULL
  
  switch(adduct,
         "[M-H]-"={
           neutralMassCorrection <- 1.008
           ionMode <- -1
         },
         "[M+H]+"={
           neutralMassCorrection <- -1.008
           ionMode <- 1
         },
         "Unknown"={
           #generateLink <- FALSE
           neutralMassCorrection <- NA
           ionMode <- NA
           error <- paste("This MS\u00B9 feature cannot be send to MetFrag, because the adduct is unknown.")
         },{
           #stop(paste("Unknown adduct (", adduct, ")!", sep = ""))
           if(outAdductWarning) print(paste("###### Unknown adduct (", adduct, ")!", sep = ""))
           #generateLink <- FALSE
           neutralMassCorrection <- NA
           ionMode <- NA
           error <- paste("This MS\u00B9 feature cannot be send to MetFrag, because the adduct '", adduct, "' is not supported.")
         }
  )
  neutralMass <- precursorMass + neutralMassCorrection
  
  fragmentsPositive <- fragmentsX > 0
  fragmentsPositiveX <- fragmentsX[fragmentsPositive]
  fragmentsPositiveY <- fragmentsY[fragmentsPositive]
  fragmentStrings <- paste(fragmentsPositiveX, fragmentsPositiveY, sep = " ", collapse = "; ")
  
  metFragOld <- FALSE
  if(metFragOld){
    # http://msbi.ipb-halle.de/MetFragBeta/LandingPage.jspx?limit=1000&ionmode=-1&database=pubchem&mzppm=7&mzabs=0.005&mass=448.468&formula=C16H20N2O9S2&mzabs=0.05&peaks=130.0655 288214.8119 ; 207.0589 422771.0127 ; 208.0622  87002.3217 ; 210.1334   2674.1707 ; 351.1016  27580.9393 ; 369.1115 739357.5045 ; 370.1148 143864.9611 ; 385.1094   5971.8328 ; 391.0937 337133.4536 ; 392.1025  40126.6888 ; 407.0678   3095.0322 ; 449.0690  37952.2515 
    landingPageUrl <- paste(sep = "",
                            "http://msbi.ipb-halle.de/MetFrag/LandingPage.jspx?",
                            "mass=", neutralMass, "&",
                            "formula=", "", "&",
                            "ionmode=", ionMode, "&",
                            #"limit=", "1000", "&",
                            "database=", "pubchem", "&",
                            #"mzppm=", "7", "&"
                            #"mzabs=", "0.005", "&",
                            "peaks=", fragmentStrings
    )
  } else {
    
    fragmentStrings <- paste(fragmentsPositiveX, fragmentsPositiveY, sep = "_", collapse = ";")
    
    ## https://msbi.ipb-halle.de/MetFragBeta/landing.xhtml?FragmentPeakMatchAbsoluteMassDeviation=0.01&FragmentPeakMatchRelativeMassDeviation=10&DatabaseSearchRelativeMassDeviation=10&PeakList=110_100;210_100&IonizedPrecursorMass=200.101&MetFragDatabaseType=PubChem
    #FragmentPeakMatchAbsoluteMassDeviation
    #FragmentPeakMatchRelativeMassDeviation
    #DatabaseSearchRelativeMassDeviation
    #PrecursorCompoundIDs
    #IonizedPrecursorMass
    #NeutralPrecursorMolecularFormula
    #PrecursorIonMode
    #IonizedPrecursorMass
    landingPageUrl <- paste(sep = "",
                            "https://msbi.ipb-halle.de/MetFragBeta/landing.xhtml", "?",
                            #"https://msbi.ipb-halle.de/MetFrag/landing.xhtml", "?",
                            "NeutralPrecursorMass", "=", neutralMass, "&",
                            "PrecursorIonMode", "=", ionMode, "&",
                            "MetFragDatabaseType", "=", "PubChem", "&",
                            "PeakList", "=", fragmentStrings
    )
  }
  
  
  #writeClipboard(landingPageUrl, format = 1)
  returObj <- list(
    error = error,
    landingPageUrl = landingPageUrl,
    precursorMass = precursorMass,
    neutralMass = neutralMass,
    adduct = adduct,
    fragmentMass = fragmentsPositiveX,
    fragmentIntensities = fragmentsPositiveY
  )
  
  return(returObj)
}
getMS2spectrum <- function(dataList, clusterDataList, treeLabel){
  if(treeLabel < 0){
    ###############################################
    ## leaf
    #return(getMS2spectrumInfoForPrecursorLeaf(dataList, clusterDataList, treeLabel))
    return(clusterDataList$ms2spectrumInfoForLeaves[[-treeLabel]])
  } else {
    ###############################################
    ## inner node
    #return(getMS2spectrumInfoForCluster(dataList, clusterDataList, treeLabel))
    return(clusterDataList$ms2spectrumInfoForClusters[[treeLabel]])
  }
}
getMS2spectrumInfoForPrecursorLeaf <- function(dataList, clusterDataList, treeLabel, outAdductWarning = TRUE){
  if(treeLabel >= 0)
    return(NULL)
  ###############################################
  ## leaf
  precursorIndex <- clusterDataList$filterObj$filter[[-treeLabel]]
  return(getMS2spectrumInfoForPrecursor(dataList, precursorIndex, outAdductWarning))
}
getMS2spectrumInfoForPrecursor <- function(dataList, precursorIndex, outAdductWarning = TRUE){
  
  precursorSet <- precursorIndex
  numberOfPrecursors <- length(precursorSet)
  
  ## fragments
  features <- dataList$featureIndeces[[precursorIndex]]
  fragmentsX <- dataList$fragmentMasses[features]
  fragmentsY <- as.numeric(dataList$featureMatrix[precursorIndex, features])
  fragmentsY[fragmentsY > 1] <- 1
  fragmentsColor <- rep(x = "black", times = length(fragmentsY))
  
  ## fragment discriminativity
  fragmentDiscriminativity <- rep(x = 0, times = length(features))
  
  
  ## info and MetFrag link
  featureID <- trimws(gsub(x = dataList$precursorLabels[[precursorIndex]], pattern = " +", replacement = " "))
  #featureID <- trimws(gsub(x = clusterDataList$cluster$labels[[-treeLabel]], pattern = " +", replacement = " "))
  featureFamilies <- dataList$annoArrayOfLists[[precursorIndex]]
  featureFamilies <- ifelse(
    test = length(featureFamilies) == 0, 
    yes = "None", 
    no = paste(unlist(featureFamilies), collapse = ", ")
  )
  featureName <- dataList$dataFrameInfos[[precursorIndex, "Metabolite name"]]
  
  infoText <- paste(
    "The MS/MS spectrum of MS\u00B9 feature '", 
    featureID, "'", 
    " comprises ", length(fragmentsX), " fragments. Families: ", featureFamilies, ". Name: ", featureName,
    sep = ""
  )
  metFragLinkList <- getMetFragLink(dataList, precursorIndex, outAdductWarning = FALSE)
  
  
  ## order data
  order <- order(fragmentsX)
  fragmentsX <- fragmentsX[order]
  fragmentsY <- fragmentsY[order]
  fragmentsColor <- fragmentsColor[order]
  fragmentDiscriminativity <- fragmentDiscriminativity[order]
  
  ## box
  resultObj <- list()
  resultObj$fragmentMasses <- fragmentsX
  resultObj$fragmentAbundances <- fragmentsY
  resultObj$fragmentColor <- fragmentsColor
  resultObj$fragmentDiscriminativity <- fragmentDiscriminativity
  resultObj$infoText <- infoText
  resultObj$infoFeatureLabel <- featureID
  resultObj$infoFragmentCount <- length(fragmentsX)
  resultObj$infoFamilies <- featureFamilies
  resultObj$infoName <- featureName
  resultObj$metFragLinkList <- metFragLinkList
  resultObj$precursorSet <- precursorSet
  resultObj$numberOfPrecursors <- numberOfPrecursors
  
  return(resultObj)
}
getMS2spectrumInfoForCluster <- function(dataList, clusterDataList, treeLabel){
  if(treeLabel < 0)
    return(NULL)
  ###############################################
  ## inner node
  clusterIndex <- treeLabel
  clusterMembersPrecursors <- sort(clusterDataList$innerNodeMembersPrecursors[[clusterIndex]])
  precursorSet <- clusterMembersPrecursors
  numberOfPrecursors <- length(precursorSet)
  numberOfClusterMembers <- length(clusterMembersPrecursors)
  
  ## fragments
  featuresIntersection <- clusterDataList$innerNodeFeaturesIntersection[[clusterIndex]]
  featuresUnion <- clusterDataList$innerNodeFeaturesUnion[[clusterIndex]]
  #fragmentsX <- dataList$fragmentMasses[featuresIntersection]
  #fragmentsY <- apply(X = data.numericmatrix(dataList$featureMatrix[clusterMembersPrecursors, featuresIntersection]), MARGIN = 2, FUN = mean)
  fragmentsX <- dataList$fragmentMasses[featuresUnion]
  fragmentsY <- apply(X = data.numericmatrix(dataList$featureMatrix[clusterMembersPrecursors, featuresUnion]), MARGIN = 2, FUN = mean)
  
  selectedPositive <- clusterDataList$innerNodeFeaturesCountsMatrix[clusterIndex, featuresUnion]
  coverageSelected <- selectedPositive / numberOfClusterMembers
  #fragmentsColor <- rep(x = "black", times = length(fragmentsY))
  fragmentsColor <- vector(length = length(fragmentsX))
  fragmentsColor[coverageSelected >= minimumProportionOfLeafs] <- "black"
  fragmentsColor[coverageSelected < minimumProportionOfLeafs] <- "grey"
  
  ## fragment discriminativity
  rootIndex <- length(clusterDataList$cluster$height)
  numberOfLeaves <- length(clusterDataList$innerNodeMembersPrecursors[[rootIndex]])
  numberOfNotClusterMembers <- numberOfLeaves - numberOfClusterMembers
  positives <- clusterDataList$innerNodeFeaturesCountsMatrix[rootIndex, featuresUnion]
  notSelectedPositive <- positives - selectedPositive
  
  #selectedNegative <- numberOfClusterMembers - featuresCountsMatrixSelected
  #notSelectedNegative <- numberOfNotClusterMembers - featuresCountsMatrixNotSelected
  #coverageNotSelected <- notSelectedPositive / numberOfNotClusterMembers
  #coverageAll <- positives / numberOfLeaves
  #relativePositives <- (selectedPositive - notSelectedPositive) / numberOfClusterMembers
  #fragmentDiscriminativity <- coverageSelected - coverageNotSelected
  #fragmentDiscriminativity <- coverageSelected * (1 - coverageNotSelected)
  #fragmentDiscriminativity <- ((selectedPositive - notSelectedPositive) / numberOfClusterMembers) * coverageSelected
  fragmentDiscriminativity <- (selectedPositive - notSelectedPositive) / numberOfClusterMembers
  fragmentDiscriminativity[fragmentDiscriminativity < 0] <- 0
  
  ## reduce to fragments above minimumProportionToShowFragment
  fragmentsX               <- fragmentsX              [coverageSelected > minimumProportionToShowFragment]
  fragmentsY               <- fragmentsY              [coverageSelected > minimumProportionToShowFragment]
  fragmentsColor           <- fragmentsColor          [coverageSelected > minimumProportionToShowFragment]
  fragmentDiscriminativity <- fragmentDiscriminativity[coverageSelected > minimumProportionToShowFragment]
  
  if(length(fragmentDiscriminativity) > 0)
    clusterDiscriminativity <- max(fragmentDiscriminativity)
  else
    clusterDiscriminativity <- 0
  
  ## annotations
  minimumProportionOfMembership <- 0.5
  featureFamilies_all <- unlist(unique(dataList$annoArrayOfLists[precursorSet])) ## all families
  proportionOfMembership <- sapply(X = featureFamilies_all, FUN = function(featureFamily){
    numberOfMembersHere <- sum(unlist(lapply(X = dataList$annoArrayOfLists[precursorSet], function(families){featureFamily %in% families})))
    return(numberOfMembersHere / length(precursorSet))
  })
  frequentFamilies <- featureFamilies_all[proportionOfMembership >= minimumProportionOfMembership]
  
  featureFamilies <- unlist(unique(dataList$annoArrayOfLists[precursorSet]))
  featureFamilies <- ifelse(
    test = length(featureFamilies) == 0, 
    yes = "None", 
    no = paste(unlist(featureFamilies), collapse = ", ")
  )
  
  ## info
  infoText <- paste(
    "This cluster has a cluster discriminativity of ", format(x = clusterDiscriminativity*100, digits = 3, nsmall = 2), "%",
    " and comprises ", length(clusterMembersPrecursors), " MS\u00B9 features",
    " which have ", length(fragmentsX), " fragment(s) in common.", 
    sep = ""
  )
  
  ## order data
  order <- order(fragmentsX)
  fragmentsX <- fragmentsX[order]
  fragmentsY <- fragmentsY[order]
  fragmentsColor <- fragmentsColor[order]
  fragmentDiscriminativity <- fragmentDiscriminativity[order]
  
  ## box
  resultObj <- list()
  resultObj$fragmentMasses <- fragmentsX
  resultObj$fragmentAbundances <- fragmentsY
  resultObj$fragmentColor <- fragmentsColor
  resultObj$fragmentDiscriminativity <- fragmentDiscriminativity
  resultObj$clusterDiscriminativity <- clusterDiscriminativity
  resultObj$frequentFamilies <- frequentFamilies
  resultObj$infoText <- infoText
  resultObj$metFragLinkList <- NULL
  resultObj$precursorSet <- precursorSet
  resultObj$numberOfPrecursors <- numberOfPrecursors
  
  return(resultObj)
}
## XXX adapt getTableFromTreeSelection
getTableFromPrecursorSet <- function(dataList, precursorSet){
  ###############################################
  ## table data
  numberOfPrecursors <- length(precursorSet)
  
  ## measurements
  columnNames <- unlist(lapply(X = dataList$grouXXXps, FUN = dataList$dataMeanColumnNameFunctionFromName))
  dataFrameMeasurements     <- data.frame(dataList$dataFrameMeasurements[precursorSet, columnNames, drop=FALSE])
  colnames(dataFrameMeasurements) <- columnNames
  rownames(dataFrameMeasurements) <- dataList$precursorLabels[precursorSet]
  dataFrameMeasurements <- format(x = dataFrameMeasurements, nsmall = 4)
  
  ## MS2 fragments
  props <- apply(
    X = dataList$featureMatrix[precursorSet, , drop = FALSE], 
    MARGIN = 2, 
    FUN = function(x){ sum(x != 0) / numberOfPrecursors }
  )
  featureIndeces <- which(props > minimumProportionToShowFragment)
  featureMatrix <- data.frame(as.matrix(dataList$featureMatrix[precursorSet, featureIndeces, drop = FALSE]))
  rownames(featureMatrix) <- dataList$precursorLabels[precursorSet]
  colnames(featureMatrix) <- colnames(dataList$featureMatrix)[featureIndeces]
  featureMatrix <- format(x = featureMatrix, digits = 1, nsmall = 4)
  if(length(featureIndeces) > 0){
    featureMatrix[featureMatrix=="0.0000"] <- "-"
    featureMatrix[featureMatrix=="1.0000"] <- "1"
  }
  
  ## annotations
  setOfAnnotationSets <- precursorSetToSetOfAnnotationSets(dataList, precursorSet)
  setOfAnnotations <- unlist(lapply(X = setOfAnnotationSets, FUN = function(x){
    paste(x, collapse = ", ")
  }))
  annotationDataFrame <- data.frame("Annotation" = setOfAnnotations, row.names = rownames(dataFrameMeasurements))
  
  ## box
  precursorLabels <- rownames(dataFrameMeasurements)
  ms1abundanceDataFrame <- dataFrameMeasurements
  ms2fragmentDataFrame <- featureMatrix
  
  resultObj <- list(
    precursorSet = precursorSet,
    featureIndeces = featureIndeces,
    ms1abundanceDataFrame = ms1abundanceDataFrame,
    ms2fragmentDataFrame = ms2fragmentDataFrame,
    annotationDataFrame = annotationDataFrame
  )
  
  return(resultObj)
}
getPrecursorSetFromTreeSelections <- function(clusterDataList, clusterLabels){
  precursorSet <- NULL
  for(clusterLabel in clusterLabels)
    precursorSet <- c(precursorSet, getPrecursorSetFromTreeSelection(clusterDataList, clusterLabel))
  return(precursorSet)
}
getPrecursorSetFromTreeSelection <- function(clusterDataList, clusterLabel){
  if(clusterLabel < 0){
    ###############################################
    ## leaf
    precursorIndex <- clusterDataList$filterObj$filter[[-clusterLabel]]
    precursorSet <- precursorIndex
  } else {
    ###############################################
    ## inner node
    clusterIndex <- clusterLabel
    precursorSet <- sort(clusterDataList$innerNodeMembersPrecursors[[clusterIndex]])
  }
  return(precursorSet)
}
getSpectrumStatistics <- function(dataList, precursorSet){
  if(FALSE){
    dataList_ <<- dataList
    precursorSet_ <<- precursorSet
  }
  if(FALSE){
    dataList <- dataList_
    precursorSet <- precursorSet_
  }
  
  fragmentCounts <- Matrix::colSums(x = dataList$featureMatrix[precursorSet, , drop=FALSE] != 0)
  theseFragments <- fragmentCounts > 0
  fragmentCounts <- fragmentCounts[theseFragments]
  fragmentMasses <- dataList$ms2_masses[theseFragments]
  return(list(
    fragmentMasses = fragmentMasses,
    fragmentCounts = fragmentCounts
  ))
}
getMS2plotData <- function(matrixRows, matrixCols, matrixVals, fragmentMasses){
  numberOfFragments <- length(fragmentMasses)
  meanIntensity <- vector(mode = "numeric", length = numberOfFragments)
  fragmentCount <- vector(mode = "numeric", length = numberOfFragments)
  for(colIdx in seq_len(numberOfFragments)){
    intensities <- matrixVals[matrixCols == colIdx]
    fragmentCount[[colIdx]] <- length(intensities)
    meanIntensity[[colIdx]] <- mean(x = intensities)
  }
  
  presentFragments <- fragmentCount > 0
  
  resultObj <- list()
  resultObj$numberOfFragments <- fragmentCount
  resultObj$averageAbundance  <- meanIntensity
  resultObj$masses            <- fragmentMasses
  
  return(resultObj)
}
regExExtraction = function(pattern, x, ...) {
  args = list(...)
  args[['perl']] = T
  
  re = do.call(gregexpr, c(list(pattern, x), args))
  
  mapply(function(re, x){
    
    cap = sapply(attr(re, 'capture.names'), function(n, re, x){
      start = attr(re, 'capture.start')[, n]
      len   = attr(re, 'capture.length')[, n]
      end   = start + len - 1
      tok   = substr(rep(x, length(start)), start, end)
      
      return(tok)
    }, re, x, simplify=F, USE.NAMES=T)
    
    return(cap)
  }, re, x, SIMPLIFY=F)
}
numericVectorToStringForEval <- function(vec){
  return(paste("c(", paste(vec, collapse = ","), ")", sep = ""))
}
colorVectorToStringForEval <- function(vec){
  return(paste("c('", paste(vec, collapse = "','"), "')", sep = ""))
}

================
File: R/FragmentMatrixFunctions.R
================
####################################################################################
## aligned spectra
parsePeakAbundanceMatrix <- function(filePeakMatrix, 
                                     doPrecursorDeisotoping, 
                                     mzDeviationInPPM_precursorDeisotoping, 
                                     mzDeviationAbsolute_precursorDeisotoping, 
                                     maximumRtDifference, 
                                     progress=FALSE)
{
  ## read file
  if(!is.na(progress))  if(progress)  incProgress(amount = 0.1, detail = paste("Parsing MS1 file content...", sep = "")) else print(paste("Parsing MS1 file content...", sep = ""))
  
  dataFrameAll <- read.table(filePeakMatrix, header=FALSE, sep = "\t", as.is=TRUE, quote = "\"", check.names = FALSE, comment.char = "")
  dataFrameAll1 <- read.table(filePeakMatrix, header=TRUE, sep = "\t", as.is=TRUE, quote = "\"", check.names = FALSE, comment.char = "")
  
  oldFormat <- max(which(dataFrameAll[1:5, 1] == "")) == 3
  header_rowNumber <- ifelse(test = oldFormat, yes = 4, no = 5)
  dataFrameHeader <- dataFrameAll[1:header_rowNumber, ]
  
  `%notin%` <- Negate(`%in%`)
  TR<- c("Reference RT","Reference m/z","Comment",
         "Manually modified for quantification",
         "Total score","RT similarity","Average","Stdev")
  IN2<-which(unname(dataFrameHeader[4,]) %notin% TR)
  dataFrameHeader1 <-dataFrameHeader[IN2]
  
  dataFrame <- dataFrameAll[(header_rowNumber + 1):nrow(dataFrameAll), ]
  dataFrame1 <- dataFrame[IN2]
  
  colnames(dataFrame) <- dataFrameHeader[header_rowNumber, ]
  colnames(dataFrame1) <- dataFrameHeader1[header_rowNumber, ]
  
  numberOfPrecursors <- nrow(dataFrame1)
  numberOfPrecursorsPrior <- numberOfPrecursors
  
  columnIndexEndOfAnnotation <- max(match(x = "Class", 
                                          table = dataFrameHeader1[1, ]), 
                                    na.rm = TRUE)
  
  if(ncol(dataFrame1) > columnIndexEndOfAnnotation){
    dataColumnStartEndIndeces <- c(columnIndexEndOfAnnotation + 1, ncol(dataFrame1))
    numberOfDataColumns <- dataColumnStartEndIndeces[[2]] - dataColumnStartEndIndeces[[1]] + 1
    dataColumnNames <- colnames(dataFrame1)[dataColumnStartEndIndeces[[1]]:dataColumnStartEndIndeces[[2]]]
    
    sampleClass          <- dataFrameHeader1[1, (columnIndexEndOfAnnotation + 1):ncol(dataFrameHeader1)]
    sampleType           <- dataFrameHeader1[2, (columnIndexEndOfAnnotation + 1):ncol(dataFrameHeader1)]
    sampleInjectionOrder <- dataFrameHeader1[3, (columnIndexEndOfAnnotation + 1):ncol(dataFrameHeader1)]
    batchID              <- NULL
    if(!oldFormat)
      batchID            <- dataFrameHeader1[4, (columnIndexEndOfAnnotation + 1):ncol(dataFrameHeader1)]
  } else {
    dataColumnStartEndIndeces <- NULL
    numberOfDataColumns <- 0
    dataColumnNames <- NULL
    
    sampleClass          <- NULL
    sampleType           <- NULL
    sampleInjectionOrder <- NULL
    batchID              <- NULL
  }
  
  commaNumbers <- sum(grepl(x = dataFrame1$"Average Mz", pattern = "^(\\d+,\\d+$)|(^\\d+$)"))
  decimalSeparatorIsComma <- commaNumbers == nrow(dataFrame1)
  if(decimalSeparatorIsComma){
    if(!is.null(dataFrame1$"Average Rt(min)"))     dataFrame1$"Average Rt(min)"     <- gsub(x = gsub(x = dataFrame1$"Average Rt(min)", pattern = "\\.", replacement = ""), pattern = ",", replacement = ".")
    if(!is.null(dataFrame1$"Average Mz"))          dataFrame1$"Average Mz"          <- gsub(x = gsub(x = dataFrame1$"Average Mz", pattern = "\\.", replacement = ""), pattern = ",", replacement = ".")
    if(!is.null(dataFrame1$"Fill %"))              dataFrame1$"Fill %"              <- gsub(x = gsub(x = dataFrame1$"Fill %", pattern = "\\.", replacement = ""), pattern = ",", replacement = ".")
    if(!is.null(dataFrame1$"Dot product"))         dataFrame1$"Dot product"         <- gsub(x = gsub(x = dataFrame1$"Dot product", pattern = "\\.", replacement = ""), pattern = ",", replacement = ".")
    if(!is.null(dataFrame1$"Reverse dot product")) dataFrame1$"Reverse dot product" <- gsub(x = gsub(x = dataFrame1$"Reverse dot product", pattern = "\\.", replacement = ""), pattern = ",", replacement = ".")
    if(!is.null(dataFrame1$"Fragment presence %")) dataFrame1$"Fragment presence %" <- gsub(x = gsub(x = dataFrame1$"Fragment presence %", pattern = "\\.", replacement = ""), pattern = ",", replacement = ".")
    
    ## replace -1 by 0
    if(numberOfDataColumns > 0) {
      for(colIdx in dataColumnStartEndIndeces[[1]]:dataColumnStartEndIndeces[[2]]){
        dataFrame1[ , colIdx] <- gsub(x = gsub(x = dataFrame1[ , colIdx], pattern = "\\.", replacement = ""), pattern = ",", replacement = ".")
      }
    }
  }
  
  ###################
  ## column formats
  if(!is.null(dataFrame1$"Average Rt(min)"))     dataFrame1$"Average Rt(min)"     <- as.numeric(dataFrame1$"Average Rt(min)")
  if(!is.null(dataFrame1$"Average Mz"))          dataFrame1$"Average Mz"          <- as.numeric(dataFrame1$"Average Mz")
  if(!is.null(dataFrame1$"Fill %"))              dataFrame1$"Fill %"              <- as.numeric(dataFrame1$"Fill %")
  if(!is.null(dataFrame1$"MS/MS included"))      dataFrame1$"MS/MS included"      <- as.logical(dataFrame1$"MS/MS included")
  if(!is.null(dataFrame1$"Dot product"))         dataFrame1$"Dot product"         <- as.numeric(dataFrame1$"Dot product")
  if(!is.null(dataFrame1$"Reverse dot product")) dataFrame1$"Reverse dot product" <- as.numeric(dataFrame1$"Reverse dot product")
  if(!is.null(dataFrame1$"Fragment presence %")) dataFrame1$"Fragment presence %" <- as.numeric(dataFrame1$"Fragment presence %")
  
  #####################
  ## sorted by m/z (needed for deisotoping)
  if(!is.null(dataFrame1$"Average Mz"))
    dataFrame1 <- dataFrame1[order(dataFrame1$"Average Mz"), ]
  
  ## replace -1 by 0
  if(numberOfDataColumns > 0){
    for(colIdx in dataColumnStartEndIndeces[[1]]:dataColumnStartEndIndeces[[2]]){
      dataFrame1[ , colIdx] <- as.numeric(dataFrame1[ , colIdx])
      if(!is.na(sum(dataFrame1[,colIdx] == -1)))
        dataFrame1[(dataFrame1[,colIdx] == -1),colIdx] <- 0
    }
  }
  
  ## deisotoping
  numberOfRemovedIsotopePeaks <- 0
  if(doPrecursorDeisotoping & !is.null(dataFrame1$"Average Mz")){
    if(!is.na(progress))  if(progress)  incProgress(amount = 0, detail = paste("Precursor deisotoping...", sep = "")) else print(paste("Precursor deisotoping...", sep = ""))
    distance13Cminus12C <- 1.0033548378
    
    ## mark isotope precursors
    precursorsToRemove <- vector(mode = "logical", length = numberOfPrecursors)
    
    if(numberOfDataColumns > 0){
      intensities <- dataFrame1[ , dataColumnStartEndIndeces[[1]]:dataColumnStartEndIndeces[[2]]]
      medians <- apply(X = as.matrix(intensities), MARGIN = 1, FUN = median)
    }
    
    for(precursorIdx in seq_len(numberOfPrecursors)){
      if((precursorIdx %% (as.integer(numberOfPrecursors/10))) == 0)
        if(!is.na(progress))  if(progress)  incProgress(amount = 0.0, detail = paste("Precursor deisotoping ", precursorIdx, " / ", numberOfPrecursors, sep = "")) else print(paste("Precursor deisotoping ", precursorIdx, " / ", numberOfPrecursors, sep = ""))
      
      mzError <- dataFrame1$"Average Mz"[[precursorIdx]] * mzDeviationInPPM_precursorDeisotoping / 1000000
      mzError <- max(mzError, mzDeviationAbsolute_precursorDeisotoping)
      
      ## RT difference <= maximumRtDifference
      validPrecursorsInRt <- abs(dataFrame1$"Average Rt(min)"[[precursorIdx]] - dataFrame1$"Average Rt(min)"[-precursorIdx]) <= maximumRtDifference
      
      ## MZ difference around 1.0033548378 (first isotope) or 1.0033548378 * 2 (second isotope)
      validPrecursorsInMz1 <- abs((dataFrame1$"Average Mz"[[precursorIdx]] - distance13Cminus12C * 1) - dataFrame1$"Average Mz"[-precursorIdx]) <= mzError
      validPrecursorsInMz2 <- abs((dataFrame1$"Average Mz"[[precursorIdx]] - distance13Cminus12C * 2) - dataFrame1$"Average Mz"[-precursorIdx]) <= mzError
      validPrecursorsInMz <- validPrecursorsInMz1 | validPrecursorsInMz2
      
      ## intensity gets smaller in the isotope spectrum
      if(numberOfDataColumns > 0){
        validPrecursorsInIntensity <- (medians[-precursorIdx] - medians[[precursorIdx]]) > 0
      } else {
        validPrecursorsInIntensity <- TRUE
      }
      
      if(any(validPrecursorsInRt & validPrecursorsInMz & validPrecursorsInIntensity))
        precursorsToRemove[[precursorIdx]] <- TRUE
    }
    
    ## remove isotopes
    dataFrame1 <- dataFrame1[!precursorsToRemove, ]
    
    numberOfRemovedIsotopePeaks <- sum(precursorsToRemove)
    numberOfPrecursors <- nrow(dataFrame1)
  }
  
  if(!is.na(progress))  if(progress)  incProgress(amount = 0, detail = paste("Boxing...", sep = "")) else print(paste("Boxing...", sep = ""))
  returnObj <- list()
  returnObj$dataFrame1 <- dataFrame1
  
  ## meta
  returnObj$oldFormat <- oldFormat
  returnObj$numberOfPrecursors <- numberOfPrecursors
  returnObj$dataColumnStartEndIndeces <- dataColumnStartEndIndeces
  returnObj$numberOfDataColumns <- numberOfDataColumns
  
  ## group anno
  returnObj$sampleClass          <- sampleClass
  returnObj$sampleType           <- sampleType
  returnObj$sampleInjectionOrder <- sampleInjectionOrder
  returnObj$batchID              <- batchID
  
  ## misc
  returnObj$numberOfPrecursorsPrior <- numberOfPrecursorsPrior
  returnObj$numberOfRemovedIsotopePeaks <- numberOfRemovedIsotopePeaks
  
  return (returnObj)
}


####################################################################################
## parse MS/MS spectra
parseMSP <- function(fileSpectra, 
                     minimumIntensityOfMaximalMS2peak, 
                     minimumProportionOfMS2peaks, 
                     neutralLossesPrecursorToFragments, 
                     neutralLossesFragmentsToFragments, 
                     progress = FALSE){
  fileLines <- readLines(con = fileSpectra)
  
  returnObj <- parseMSP_chunk(fileLines, 
                              minimumIntensityOfMaximalMS2peak, 
                              minimumProportionOfMS2peaks, 
                              neutralLossesPrecursorToFragments, 
                              neutralLossesFragmentsToFragments, 
                              progress=FALSE)
  returnObj$fileSpectra <- fileSpectra
  
  return(returnObj)
}

parseMSP_big <- function(fileSpectra, 
                         minimumIntensityOfMaximalMS2peak, 
                         minimumProportionOfMS2peaks, 
                         neutralLossesPrecursorToFragments, 
                         neutralLossesFragmentsToFragments, 
                         progress = FALSE){
  if(progress)  incProgress(amount = 0, detail = "MS/MS file: Read file") else print("MS/MS file: Read file")
  
  fileLines <- readLines(con = fileSpectra)
  
  if(progress)  incProgress(amount = 0, detail = "Decompose file to chunks") else print("Decompose file to chunks")
  ## entry lines in file
  isName	    <- grepl(pattern = "^Name:",			 x = fileLines)
  isNAME      <- grepl(pattern = "^NAME:",			 x = fileLines)
  isBeginIons	<- grepl(pattern = "^BEGIN IONS$", x = fileLines)
  
  ## entry line intervals in file
  entryBorders   <- c(which(isName | isNAME | isBeginIons), length(fileLines)+1)
  entryIntervals <- matrix(data = unlist(lapply(X = seq_len(length(entryBorders) - 1), FUN = function(x){c(entryBorders[[x]], entryBorders[[x+1]] - 1)})), nrow=2)
  
  rm(isName, isNAME, isBeginIons)
  
  ## split in chunks
  maximumNumberOfLinesPerChunk <- as.integer(1E6)
  fileLineChunks <- list()
  while(length(fileLines) > 0){
    numberOfEntries <- max(which(entryIntervals[2, ] <= maximumNumberOfLinesPerChunk))
    numberOfFileLinesInChunk <- entryIntervals[2, numberOfEntries]
    
    fileLinesInChunk <- fileLines[1:numberOfFileLinesInChunk]
    fileLineChunks[[length(fileLineChunks) + 1]] <- fileLinesInChunk
    
    ## remaining stuff
    fileLines      <- fileLines[-(1:numberOfFileLinesInChunk)]
    entryIntervals <- entryIntervals[, -(1:numberOfEntries)]
    if(ncol(entryIntervals) > 0)
      entryIntervals <- entryIntervals - min(entryIntervals) + 1
  }
  
  numberOfChunks <- length(fileLineChunks)
  fileLineCountOfChunks  <- unlist(lapply(X = fileLineChunks, FUN = length))
  fileLineOffsetOfChunks <- c(0, sapply(X = seq_along(fileLineCountOfChunks)[-1], FUN = function(x){sum(fileLineCountOfChunks[1:(x-1)])}))
  
  if(progress)  incProgress(amount = 0, detail = paste("Parse", numberOfChunks, "chunks")) else print(paste("Parse", numberOfChunks, "chunks"))
  ## merge chunks
  returnObj <- list()
  returnObj$fileSpectra <- fileSpectra
  returnObj$spectraList <- list()
  returnObj$numberOfSpectra <- 0
  returnObj$numberOfMS2PeaksOriginal <- 0
  returnObj$numberOfMS2PeaksWithNeutralLosses <- 0
  returnObj$numberOfMS2PeaksAboveThreshold <- 0
  returnObj$numberOfMS2PeaksBelowThreshold <- 0
  returnObj$precursorMz <- vector(mode = "numeric")
  returnObj$precursorRt <- vector(mode = "numeric")
  
  for(chunkIdx in seq_len(numberOfChunks)){
    if(progress)  incProgress(amount = 0, detail = paste("Chunk", chunkIdx, "/", numberOfChunks)) else print(paste("Chunk", chunkIdx, "/", numberOfChunks))
    
    fileLines  <- fileLineChunks[[1]]
    fileLineChunks[[1]] <- NULL
    
    returnObj2 <- parseMSP_chunk(
      fileLines = fileLines, 
      minimumIntensityOfMaximalMS2peak = minimumIntensityOfMaximalMS2peak, 
      minimumProportionOfMS2peaks = minimumProportionOfMS2peaks, 
      neutralLossesPrecursorToFragments = neutralLossesPrecursorToFragments, 
      neutralLossesFragmentsToFragments = neutralLossesFragmentsToFragments, 
      offset = fileLineOffsetOfChunks[[chunkIdx]], progress = NA
    )
    
    returnObj$spectraList                       <- c(returnObj$spectraList,                        returnObj2$spectraList)
    returnObj$numberOfSpectra                   <-   returnObj$numberOfSpectra                   + returnObj2$numberOfSpectra
    returnObj$numberOfSpectraOriginal           <-   returnObj$numberOfSpectraOriginal           + returnObj2$numberOfSpectraOriginal
    returnObj$numberOfMS2PeaksOriginal          <-   returnObj$numberOfMS2PeaksOriginal          + returnObj2$numberOfMS2PeaksOriginal
    returnObj$numberOfMS2PeaksWithNeutralLosses <-   returnObj$numberOfMS2PeaksWithNeutralLosses + returnObj2$numberOfMS2PeaksWithNeutralLosses
    returnObj$numberOfMS2PeaksAboveThreshold    <-   returnObj$numberOfMS2PeaksAboveThreshold    + returnObj2$numberOfMS2PeaksAboveThreshold
    returnObj$numberOfMS2PeaksBelowThreshold    <-   returnObj$numberOfMS2PeaksBelowThreshold    + returnObj2$numberOfMS2PeaksBelowThreshold
    returnObj$numberOfTooHeavyFragments         <-   returnObj$numberOfTooHeavyFragments         + returnObj2$numberOfTooHeavyFragments
    returnObj$numberOfSpectraDiscardedDueToNoPeaks      <-   returnObj$numberOfSpectraDiscardedDueToNoPeaks      + returnObj2$numberOfSpectraDiscardedDueToNoPeaks
    returnObj$numberOfSpectraDiscardedDueToMaxIntensity <-   returnObj$numberOfSpectraDiscardedDueToMaxIntensity + returnObj2$numberOfSpectraDiscardedDueToMaxIntensity
    returnObj$numberOfSpectraDiscardedDueToTooHeavy     <-   returnObj$numberOfSpectraDiscardedDueToTooHeavy     + returnObj2$numberOfSpectraDiscardedDueToTooHeavy
    returnObj$precursorMz                       <- c(returnObj$precursorMz,                        returnObj2$precursorMz)
    returnObj$precursorRt                       <- c(returnObj$precursorRt,                        returnObj2$precursorRt)
  }
  
  return(returnObj)
}

#####################
parseMSP_chunk <- function(fileLines, 
                           minimumIntensityOfMaximalMS2peak, 
                           minimumProportionOfMS2peaks, 
                           neutralLossesPrecursorToFragments, 
                           neutralLossesFragmentsToFragments, 
                           offset = 0, 
                           progress = FALSE)
{
  
  ## LC-MS/MS entry:
  ## NAME: Unknown
  ## RETENTIONTIME: 3.215358
  ## PRECURSORMZ: 78.91963
  ## METABOLITENAME: 
  ## ADDUCTIONNAME: [M-H]-
  ## Num Peaks: 2
  ## 76.97093  754
  ## 76.98951  754
  ## 
  ## GC-MS additional properties:
  ## SCANNUMBER: 518
  ## MODELION: 59
  ## MODELIONHEIGHT: 924
  ## MODELIONAREA: 924
  ## INTEGRATEDHEIGHT: 924
  ## INTEGRATEDAREA: 924
  
  if(!is.na(progress))  if(progress)  incProgress(amount = 0, detail = "MS/MS file: Read file") else print("MS/MS file: Read file")
  
  #fileLines <- readLines(con = fileSpectra)
  numberOfFileLines <- length(fileLines)
  
  numberOfMS2PeaksOriginal <<- 0
  numberOfMS2PeaksWithNeutralLosses <<- 0
  numberOfTooHeavyFragments <<- 0
  numberOfMS2PeaksAboveThreshold <<- 0
  numberOfMS2PeaksBelowThreshold <<- 0
  numberOfSpectraDiscardedDueToNoPeaks      <<- 0
  numberOfSpectraDiscardedDueToMaxIntensity <<- 0
  numberOfSpectraDiscardedDueToTooHeavy <<- 0
  
  ## start with empty lines or not?
  endOfRecord <- TRUE
  if(numberOfFileLines > 0)
    if(nchar(trimws(fileLines[[1]])) > 0)
      endOfRecord <- FALSE
  
  ## check for pattern
  if(!is.na(progress))  if(progress)  incProgress(amount = 0, detail = "MS/MS file: Parse") else print("MS/MS file: Parse")
  isBI  	<- grepl(pattern = "^BEGIN IONS$",                    		x = fileLines)
  isName	<- grepl(pattern = "(^Name:)|(^NAME:)",               		x = fileLines)
  isNAme	<- grepl(pattern = "^NAME=",                           		x = fileLines)
  isNAME	<- grepl(pattern = "^TITLE=",                          		x = fileLines)
  isRT	  <- grepl(pattern = "^RETENTIONTIME:",						          x = fileLines)
  isRt	  <- grepl(pattern = "^retention time:",			  	          x = fileLines)
  isRts	  <- grepl(pattern = "^RTINSECONDS=",	     		  	          x = fileLines)
  isMZ	  <- grepl(pattern = "^PRECURSORMZ:",							          x = fileLines)
  isMz	  <- grepl(pattern = "^precursor m/z:",						          x = fileLines)
  isTotEm	<- grepl(pattern = "^total exact mass:",					        x = fileLines)
  isEMass	<- grepl(pattern = "(^exact mass:)|(^EXACT_MASS:)",       x = fileLines)
  isPMass	<- grepl(pattern = "^PEPMASS=",   							          x = fileLines)
  isE2Mass<- grepl(pattern = "^EXACTMASS=", 							          x = fileLines)
  isMetN	<- grepl(pattern = "^METABOLITENAME:",						        x = fileLines)
  isAddN	<- grepl(pattern = "(^ADDUCTIONNAME:)|(^Adductionname:)",	x = fileLines)
  isScanN	<- grepl(pattern = "^SCANNUMBER:",							          x = fileLines)
  isMIon	<- grepl(pattern = "^MODELION:",							            x = fileLines)
  isPrety	<- grepl(pattern = "^precursor type:",						        x = fileLines)
  isPretyp	<- grepl(pattern = "^PRECURSORTYPE:",						          x = fileLines)
  isNumP	<- grepl(pattern = "^Num Peaks:",							            x = fileLines)
  isPeak	<- grepl(pattern = "^\\d+(((\\.)|(,))\\d+)?[ \t]\\d+(((\\.)|(,))\\d+)?$",	x = fileLines)
  isCoCl	<- grepl(pattern = "^compound class:",						        x = fileLines)
  isInty	<- grepl(pattern = "^instrument type:",						        x = fileLines)
  isIntyp	<- grepl(pattern = "^INSTRUMENTTYPE:",						        x = fileLines)
  isIntype<- grepl(pattern = "^SOURCE_INSTRUMENT=",					        x = fileLines)
  isInt  	<- grepl(pattern = "^INSTRUMENT:",						            x = fileLines)
  isInchi	<- grepl(pattern = "(^InChI:)|(^InChI=)|(^INCHI=)|(^INCHI:)", x = fileLines)
  isInchiKey	<- grepl(pattern = "(^InChIKey:)|(^INCHIKEY:)|(^InChIKey=)|(^INCHIKEY=)|(^INCHIAUX=)",	      x = fileLines)
  isSmiles  	<- grepl(pattern = "(^SMILES:)|(^SMILES=)",		        x = fileLines)
  
  someStrings <- trimws(c(
    substring(text = fileLines[isMZ], first = nchar("RETENTIONTIME:") + 1), 
    substring(text = fileLines[isMZ], first = nchar("PRECURSORMZ:") + 1), 
    substring(text = fileLines[isMz], first = nchar("precursor m/z:") + 1)
  ))
  decimalDelimiterIsComma <- ifelse(test = length(someStrings) > 0, yes = all(grepl(x = someStrings, pattern = "^(\\d+,\\d+$)|(^\\d+$)")), no = FALSE)
  if(decimalDelimiterIsComma){
    fileLines_02 <- gsub(pattern = ",", replacement = ".", x = gsub(pattern = "\\.", replacement = "", x = fileLines))
  } else {
    fileLines_02 <- fileLines
  }
  
  ## extract
  suppressWarnings({
    parsedName	 <- 						      trimws(substring(text = fileLines, first = nchar("Name:") + 1))
    parsedNAme	 <- 						      trimws(substring(text = fileLines, first = nchar("NAME=") + 1))
    parsedNAME	 <- 						      trimws(substring(text = fileLines, first = nchar("TITLE=") + 1))
    parsedRT  	 <- as.numeric(				trimws(substring(text = fileLines_02, first = nchar("RETENTIONTIME:") + 1)))
    parsedRt     <- as.numeric(unlist(lapply(X = strsplit(x =   trimws(substring(text = fileLines_02, first = nchar("retention time:") + 1)), split = " "), FUN = function(x){if(length(x)==0) return(NA) else return(x[[1]])})))
    parsedRts  	 <- as.numeric(				trimws(substring(text = fileLines_02, first = nchar("RTINSECONDS=") + 1)))
    parsedMZ	   <- as.numeric(				trimws(substring(text = fileLines_02, first = nchar("PRECURSORMZ:") + 1)))
    parsedMz	   <- as.numeric(				trimws(substring(text = fileLines_02, first = nchar("precursor m/z:") + 1)))
    parsedTotEm  <- as.numeric(				trimws(substring(text = fileLines_02, first = nchar("total exact mass:") + 1)))
    parsedEMass  <- as.numeric(				trimws(substring(text = fileLines_02, first = nchar("exact mass:") + 1)))
    parsedE2Mass <- as.numeric(				trimws(substring(text = fileLines_02, first = nchar("EXACTMASS=") + 1)))
    parsedPMass  <- as.numeric(				trimws(substring(text = fileLines_02, first = nchar("PEPMASS=") + 1)))
    parsedMetN	 <- 						      trimws(substring(text = fileLines, first = nchar("METABOLITENAME:") + 1))
    parsedAddN	 <- 						      trimws(substring(text = fileLines, first = nchar("Adductionname:") + 1))
    parsedScanN  <- as.numeric(				trimws(substring(text = fileLines_02, first = nchar("SCANNUMBER:") + 1)))
    parsedMIon	 <- as.numeric(				trimws(substring(text = fileLines_02, first = nchar("MODELION:") + 1)))
    parsedPrety  <- 						      trimws(substring(text = fileLines, first = nchar("precursor type:") + 1))
    parsedPretyp <- 						      trimws(substring(text = fileLines, first = nchar("PRECURSORTYPE:") + 1))
    parsedNumP	 <- as.numeric(				trimws(substring(text = fileLines_02, first = nchar("Num Peaks:") + 1)))
    
    parsedTokensTmp <- strsplit(x = trimws(fileLines_02), split = "[ \t]")
    #parsedms2Peaks_mz <- as.numeric(unlist(lapply(X = parsedTokensTmp, FUN = function(x){head(x = x, n = 1)})))
    parsedms2Peaks_mz  <- as.numeric(unlist(lapply(X = parsedTokensTmp, FUN = function(x){if(length(x)<1) return(NA) else return(x[[1]])})))
    parsedms2Peaks_int <- as.numeric(unlist(lapply(X = parsedTokensTmp, FUN = function(x){if(length(x)<2) return(NA) else return(x[[2]])})))
    
    parsedCoCl	 <- 						      trimws(substring(text = fileLines, first = nchar("compound class:") + 1))
    parsedInty	 <- 						      trimws(substring(text = fileLines, first = nchar("instrument type:") + 1))
    parsedIntype <- 						      trimws(substring(text = fileLines, first = nchar("SOURCE_INSTRUMENT=") + 1))
    parsedIntyp  <- 						      trimws(substring(text = fileLines, first = nchar("INSTRUMENTTYPE:") + 1))
    parsedInt    <- 						      trimws(substring(text = fileLines, first = nchar("INSTRUMENT:") + 1))
    parsedInchi  <- 						      trimws(substring(text = fileLines, first = nchar("InChI:") + 1))
    parsedInchiKey  <- 						    trimws(substring(text = fileLines, first = nchar("InChIKey:") + 1))
    parsedSmiles    <- 						    trimws(substring(text = fileLines, first = nchar("SMILES:") + 1))
  })
  
  ## entry line intervals in file
  entryBorders   <- c(which(isName | isNAME | isBI), length(fileLines)+1)
  entryIntervals <- matrix(data = unlist(lapply(X = seq_len(length(entryBorders) - 1), FUN = function(x){c(entryBorders[[x]], entryBorders[[x+1]] - 1)})), nrow=2)
  
  numberOfSpectraOriginal <- length(entryBorders)
  
  ## do it
  if(!is.na(progress))  if(progress)  incProgress(amount = 0, detail = "MS/MS file: Assemble spectra") else print("MS/MS file: Assemble spectra")
  suppressWarnings(
    spectraList <- apply(X = entryIntervals, MARGIN = 2, FUN = function(x){
      #print(x)
      
      fileLines2      <- fileLines 	 		[x[[1]]:x[[2]]]
      fileLines_022   <- fileLines_02 	[x[[1]]:x[[2]]]
      parsedName2	 		<- parsedName	 		[x[[1]]:x[[2]]]
      parsedNAme2	 		<- parsedNAme	 		[x[[1]]:x[[2]]]
      parsedNAME2	 		<- parsedNAME	 		[x[[1]]:x[[2]]]
      parsedRT2  	 		<- parsedRT  	 		[x[[1]]:x[[2]]]
      parsedRt2     	<- parsedRt     	[x[[1]]:x[[2]]]
      parsedRts2     	<- parsedRts     	[x[[1]]:x[[2]]]
      parsedMZ2	 		  <- parsedMZ	 		  [x[[1]]:x[[2]]]
      parsedMz2	 		  <- parsedMz	 		  [x[[1]]:x[[2]]]
      parsedTotEm2  	<- parsedTotEm  	[x[[1]]:x[[2]]]
      parsedEMass2  	<- parsedEMass  	[x[[1]]:x[[2]]]
      parsedE2Mass2  	<- parsedE2Mass  	[x[[1]]:x[[2]]]
      parsedPMass2  	<- parsedPMass  	[x[[1]]:x[[2]]]
      parsedMetN2	 		<- parsedMetN	 		[x[[1]]:x[[2]]]
      parsedAddN2	 		<- parsedAddN	 		[x[[1]]:x[[2]]]
      parsedScanN2  	<- parsedScanN  	[x[[1]]:x[[2]]]
      parsedMIon2	 		<- parsedMIon	 		[x[[1]]:x[[2]]]
      parsedPrety2  	<- parsedPrety  	[x[[1]]:x[[2]]]
      parsedPretyp2  	<- parsedPretyp  	[x[[1]]:x[[2]]]
      parsedNumP2	 		<- parsedNumP	 		[x[[1]]:x[[2]]]
      parsedms2Peaks_mz2	<- parsedms2Peaks_mz	[x[[1]]:x[[2]]]
      parsedms2Peaks_int2	<- parsedms2Peaks_int	[x[[1]]:x[[2]]]
      parsedCoCl2	 		<- parsedCoCl	 		[x[[1]]:x[[2]]]
      parsedInty2	 		<- parsedInty	 		[x[[1]]:x[[2]]]
      parsedIntype2		<- parsedIntype		[x[[1]]:x[[2]]]
      parsedIntyp2		<- parsedIntyp		[x[[1]]:x[[2]]]
      parsedInt2	  	<- parsedInt  		[x[[1]]:x[[2]]]
      parsedInchi2  	<- parsedInchi  	[x[[1]]:x[[2]]]
      parsedInchiKey2 <- parsedInchiKey [x[[1]]:x[[2]]]
      parsedSmiles2  	<- parsedSmiles  	[x[[1]]:x[[2]]]
      
      isName2	 		<- isName	 		[x[[1]]:x[[2]]]
      isNAme2	 		<- isName	 		[x[[1]]:x[[2]]]
      isNAME2	 		<- isNAME	 		[x[[1]]:x[[2]]]
      isRT2  	 		<- isRT  	 		[x[[1]]:x[[2]]]
      isRt2     	<- isRt     	[x[[1]]:x[[2]]]
      isRts2     	<- isRts     	[x[[1]]:x[[2]]]
      isMZ2	 		  <- isMZ	 		  [x[[1]]:x[[2]]]
      isMz2	 		  <- isMz	 		  [x[[1]]:x[[2]]]
      isTotEm2  	<- isTotEm  	[x[[1]]:x[[2]]]
      isEMass2  	<- isEMass  	[x[[1]]:x[[2]]]
      isE2Mass2  	<- isE2Mass  	[x[[1]]:x[[2]]]
      isPMass2  	<- isPMass  	[x[[1]]:x[[2]]]
      isMetN2	 		<- isMetN	 		[x[[1]]:x[[2]]]
      isAddN2	 		<- isAddN	 		[x[[1]]:x[[2]]]
      isScanN2  	<- isScanN  	[x[[1]]:x[[2]]]
      isMIon2	 		<- isMIon	 		[x[[1]]:x[[2]]]
      isPrety2  	<- isPrety  	[x[[1]]:x[[2]]]
      isPretyp2  	<- isPretyp  	[x[[1]]:x[[2]]]
      isNumP2	 		<- isNumP	 		[x[[1]]:x[[2]]]
      isPeak2	    <- isPeak	    [x[[1]]:x[[2]]]
      isCoCl2	 		<- isCoCl	 		[x[[1]]:x[[2]]]
      isInty2	 		<- isInty	 		[x[[1]]:x[[2]]]
      isIntype2		<- isIntype		[x[[1]]:x[[2]]]
      isIntyp2		<- isIntyp		[x[[1]]:x[[2]]]
      isInt2  		<- isInt  		[x[[1]]:x[[2]]]
      isInchi2  	<- isInchi  	[x[[1]]:x[[2]]]
      isInchiKey2 <- isInchiKey [x[[1]]:x[[2]]]
      isSmiles2  	<- isSmiles  	[x[[1]]:x[[2]]]
      
      name <- NULL
      ms1Int <- NA
      rt <- NULL
      mz <- NULL
      metName <- "Unknown"
      adduct <- "Unknown"
      scanNumber <- NA
      quantMass <- NA
      peakNumber <- NA
      ms2Peaks_mz  <- vector(mode = "numeric")
      ms2Peaks_int <- vector(mode = "numeric")
      compoundClass <- "Unknown"
      instrumentType <- "Unknown"
      inchi <- ""
      inchiKey <- ""
      smiles <- ""
      
      if(any(isName2))
        ## name
        name        <- parsedName2	[[which(isName2)[[1]]]]
      if(any(isNAme2))
        ## name
        name        <- parsedNAme2	[[which(isNAme2)[[1]]]]
      if(any(isNAME2))
        ## name
        name        <- parsedNAME2	[[which(isNAME2)[[1]]]]
      if(any(isRT2))
        ## retention time
        rt          <- parsedRT2	[[which(isRT2)[[1]]]]
      if(any(isRt2) & any(is.null(rt), is.na(rt)))
        rt          <- parsedRt2	[[which(isRt2)[[1]]]]
      if(any(isRts2) & any(is.null(rt), is.na(rt)))
        rt          <- parsedRts2	[[which(isRts2)[[1]]]]
      if(any(isMZ2))
        ## precursor m/z
        mz          <- parsedMZ2	[[which(isMZ2)[[1]]]]
      if(any(isMz2)    & any(is.null(mz), is.na(mz), ifelse(test = is.null(mz), yes = FALSE, no = mz%%1==0)))
        mz          <- parsedMz2	[[which(isMz2)[[1]]]]
      if(any(isTotEm2) & any(is.null(mz), is.na(mz), ifelse(test = is.null(mz), yes = FALSE, no = mz%%1==0)) & any(isPrety2)){
        mzTmp <- parsedTotEm2[[which(isTotEm2)[[1]]]]
        pit   <- parsedPrety2[[which(isPrety2)[[1]]]]
        switch(pit,
               "[M-H]-" = { mz <- mzTmp -  1.008  },
               "[M-H]"  = { mz <- mzTmp -  1.008  },
               "[M+H]+" = { mz <- mzTmp +  1.008  },
               "[M+H]"  = { mz <- mzTmp +  1.008  },
               "[M+Na]+"= { mz <- mzTmp + 22.9898 },
               "[M+Na]" = { mz <- mzTmp + 22.9898 }#,
        )
      }
      if(any(isEMass2) & any(is.null(mz), is.na(mz), ifelse(test = is.null(mz), yes = FALSE, no = mz%%1==0))){
        mz <- parsedEMass2[[which(isEMass2)[[1]]]]
      }
      if(any(isPMass2) & any(is.null(mz), is.na(mz), ifelse(test = is.null(mz), yes = FALSE, no = mz%%1==0))){
        if(!is.na(parsedPMass2[[which(isPMass2)[[1]]]])){
          mz  <- parsedPMass2[[which(isPMass2)[[1]]]]
        } else {
          tmp <- as.numeric(strsplit(x = trimws(substring(text = fileLines_022[[which(isPMass2)[[1]]]], first = nchar("PEPMASS=") + 1)), split = "[\t ]")[[1]])
          mz  <- tmp[[1]]
          if(length(tmp) > 1)
            ms1Int <- tmp[[2]]
        }
      }
      if(any(isE2Mass2) & any(is.null(mz), is.na(mz), ifelse(test = is.null(mz), yes = FALSE, no = mz%%1==0))){
        mz <- parsedE2Mass2[[which(isE2Mass2)[[1]]]]
      }
      if(any(isMetN2))
        metName     <- parsedMetN2	[[which(isMetN2)[[1]]]]
      if(any(isAddN2)  & adduct == "Unknown")
        ## adduct
        adduct      <- parsedAddN2	[[which(isAddN2)[[1]]]]
      if(any(isPrety2) & adduct == "Unknown")
        adduct      <- parsedPrety2[[which(isPrety2)[[1]]]]
      if(any(isPretyp2) & adduct == "Unknown")
        adduct      <- parsedPretyp2[[which(isPretyp2)[[1]]]]
      if(any(isScanN2))
        scanNumber  <- parsedScanN2[[which(isScanN2)[[1]]]]
      if(any(isMIon2))
        quantMass  <- parsedMIon2	[[which(isMIon2)[[1]]]]
      if(any(isNumP2))
        ## #peaks
        peakNumber  <- parsedNumP2	[[which(isNumP2)[[1]]]]
      if(any(isPeak2)){
        ## MS2 peaks: "178.88669\t230"
        ms2Peaks_mz  <- parsedms2Peaks_mz2 [which(isPeak2)]
        ms2Peaks_int <- parsedms2Peaks_int2[which(isPeak2)]
      }
      if(any(isCoCl2))
        ## compound class
        compoundClass  <- parsedCoCl2	[[which(isCoCl2)[[1]]]]
      if(any(isInty2))
        ## instrument type
        instrumentType  <- parsedInty2	[[which(isInty2)[[1]]]]
      if(any(isIntype2))
        ## instrument type
        instrumentType  <- parsedIntype2	[[which(isIntype2)[[1]]]]
      if(any(isIntyp2))
        ## instrument type
        instrumentType  <- parsedIntyp2	[[which(isIntyp2)[[1]]]]
      if(all(any(isInt2), instrumentType %in% c("Unknown", "NA")))
        ## instrument
        instrumentType  <- parsedInt2	[[which(isInt2)[[1]]]]
      if(any(isInchi2))
        ## structure
        inchi  <- parsedInchi2 [[which(isInchi2)[[1]]]]
      if(any(isInchiKey2))
        ## structure
        inchiKey  <- parsedInchiKey2 [[which(isInchiKey2)[[1]]]]
      if(any(isSmiles2))
        ## structure
        smiles  <- parsedSmiles2 [[which(isSmiles2)[[1]]]]
      ## end of parsing
      
      if(is.null(rt))
        rt <- 0
      
      ms2Peaks_mz_original  <- ms2Peaks_mz
      ms2Peaks_int_original <- ms2Peaks_int
      
      numberOfMS2PeaksOriginal <<- numberOfMS2PeaksOriginal + length(ms2Peaks_mz)
      if(length(ms2Peaks_mz) == 0)
        numberOfSpectraDiscardedDueToNoPeaks <<- numberOfSpectraDiscardedDueToNoPeaks + 1
      
      ###################################################################
      ## filter fragments with mass greater than precursor
      numberOfTooHeavyFragmentsHere <- 0
      if(all(!is.null(mz), !is.na(mz))){
        tooHeavy <- ms2Peaks_mz > mz
        ms2Peaks_mz  <- ms2Peaks_mz [!tooHeavy]
        ms2Peaks_int <- ms2Peaks_int[!tooHeavy]
        numberOfTooHeavyFragmentsHere <- sum(tooHeavy)
        
        if(length(ms2Peaks_mz) == 0 & numberOfTooHeavyFragmentsHere > 0)
          numberOfSpectraDiscardedDueToTooHeavy <<- numberOfSpectraDiscardedDueToTooHeavy + 1
      }
      numberOfTooHeavyFragments <<- numberOfTooHeavyFragments + numberOfTooHeavyFragmentsHere
      
      ###################################################################
      ## filter for ms2 peak intensity
      peakNumber <- length(ms2Peaks_mz)
      if(peakNumber > 0){
        ###################################################################
        ## filter for ms2 peak intensity relative to maximum peak intensity in spectrum
        maximumIntensity <- max(ms2Peaks_int)
        if(maximumIntensity >= minimumIntensityOfMaximalMS2peak){
          ## spectrum is considered
          intensityThreshold <- maximumIntensity * minimumProportionOfMS2peaks
          fragmentsAboveThreshold <- ms2Peaks_int >= intensityThreshold
          
          ms2Peaks_mz  <- ms2Peaks_mz [fragmentsAboveThreshold]
          ms2Peaks_int <- ms2Peaks_int[fragmentsAboveThreshold]
          numberOfMS2PeaksAboveThreshold <<- numberOfMS2PeaksAboveThreshold + sum( fragmentsAboveThreshold)
          numberOfMS2PeaksBelowThreshold <<- numberOfMS2PeaksBelowThreshold + sum(!fragmentsAboveThreshold)
        } else {
          ## spectrum is not considered
          numberOfMS2PeaksBelowThreshold <<- numberOfMS2PeaksBelowThreshold + length(ms2Peaks_mz)
          numberOfSpectraDiscardedDueToMaxIntensity <<- numberOfSpectraDiscardedDueToMaxIntensity + 1
          ms2Peaks_mz  <- vector(mode = "numeric")
          ms2Peaks_int <- vector(mode = "numeric")
        }
      }
      
      ###################################################################
      ## normalize ms2 peaks to maximum = 1
      peakNumber <- length(ms2Peaks_mz)
      if(peakNumber > 0){
        max <- max(ms2Peaks_int)
        ms2Peaks_int <- ms2Peaks_int / max
      }
      
      ###################################################################
      ## add neutral losses
      if(peakNumber > 0){
        #################################
        ## neutral losses regarding the precursor
        if(all(!is.null(mz), !is.na(mz), neutralLossesPrecursorToFragments)){
          ms2PeaksNLPF_mz  <- ms2Peaks_mz - as.numeric(mz)
          ms2PeaksNLPF_int <- ms2Peaks_int
        } else {
          ms2PeaksNLPF_mz  <- vector(mode = "numeric")
          ms2PeaksNLPF_int <- vector(mode = "numeric")
        }
        #################################
        ## neutral losses amongst fragments
        if(neutralLossesFragmentsToFragments){
          m_mz  <- outer(X = ms2Peaks_mz,  Y = ms2Peaks_mz,  FUN = function(x,y){x-y})
          m_int <- outer(X = ms2Peaks_int, Y = ms2Peaks_int, FUN = function(x,y){(x+y) / 2})
          upper <- upper.tri(x = m_mz)
          ms2PeaksNLFF_mz  <- m_mz [upper]
          ms2PeaksNLFF_int <- m_int[upper]
        } else {
          ms2PeaksNLFF_mz  <- vector(mode = "numeric")
          ms2PeaksNLFF_int <- vector(mode = "numeric")
        }
        
        ms2Peaks_mz  <- c(ms2Peaks_mz,  ms2PeaksNLPF_mz,  ms2PeaksNLFF_mz)
        ms2Peaks_int <- c(ms2Peaks_int, ms2PeaksNLPF_int, ms2PeaksNLFF_int)
      }
      
      ###################################################################
      ## precursor mz
      #mz <- ifelse(test = !is.null(mz), yes = round(as.numeric(mz), digits = 4), no = ifelse(test = !is.null(scanNumber), yes = scanNumber, no = max(ms2Peaks_mz)))
      if(all(!is.null(mz), !is.na(mz))){
        mz <- round(as.numeric(mz), digits = 4)
      } else {
        if(!is.na(quantMass)){
          mz <- quantMass
        } else {
          if(!is.na(scanNumber)){
            mz <- scanNumber
          } else {
            mz <- max(ms2Peaks_mz)
          }
        }
      }
      
      ###################################################################
      ## string representation of spectrum
      spectrumString <- paste(ms2Peaks_mz_original, ms2Peaks_int_original, sep = " ", collapse = ";")
      
      ###################################################################
      ## built ms set
      spectrumItem <- list(
        name = name,
        ms1Int = ms1Int,
        #rt = round(as.numeric(rt), digits = 2),
        rt = rt,
        mz = mz,
        metName = metName,
        adduct = adduct,
        quantMass = quantMass,
        compoundClass = compoundClass,
        instrumentType = instrumentType,
        inchi = inchi,
        inchiKey = inchiKey,
        smiles = smiles,
        #peakNumber = as.numeric(peakNumber),
        peakNumber = length(ms2Peaks_mz),
        ms2Peaks_mz  = ms2Peaks_mz,
        ms2Peaks_int = ms2Peaks_int,
        spectrumString = spectrumString,
        entryInterval = x + offset
      )
      if(spectrumItem$peakNumber > 0){
        ## add
        numberOfMS2PeaksWithNeutralLosses <<- numberOfMS2PeaksWithNeutralLosses + spectrumItem$peakNumber
        return(spectrumItem)
      } else
        return(NULL)
    })
  )
  
  rm(
    isName,
    isNAME,
    isRT,
    isRt,
    isMZ,
    isMz,
    isTotEm,
    isEMass,
    isE2Mass,
    isPMass,
    isMetN,
    isAddN,
    isScanN,
    isMIon,
    isPrety,
    isNumP,
    isPeak,
    isCoCl,
    isInty,
    isInchi,
    isInchiKey,
    isSmiles,
    parsedName,
    parsedNAME,
    parsedRT,
    parsedRt,
    parsedMZ,
    parsedMz,
    parsedTotEm,
    parsedEMass,
    parsedE2Mass,
    parsedPMass,
    parsedMetN,
    parsedAddN,
    parsedScanN,
    parsedMIon,
    parsedPrety,
    parsedNumP,
    parsedTokensTmp,
    parsedms2Peaks_mz,
    parsedms2Peaks_int,
    parsedCoCl,
    parsedInty,
    parsedInchi,
    parsedInchiKey,
    parsedSmiles
  )
  
  if(!is.na(progress))  if(progress)  incProgress(amount = 0.1, detail = "MS/MS file: Box") else print("MS/MS file: Box")
  
  ## remove NULL entries?
  spectraList[unlist(lapply(X = spectraList, FUN = is.null))] <- NULL
  
  numberOfSpectra <- length(spectraList)
  
  ## postprocess
  if(!is.na(progress))  if(progress)  incProgress(amount = 0.01, detail = paste("MS/MS file postprocessing", sep = "")) else print(paste("MS/MS file postprocessing", sep = ""))
  
  precursorMz <- unlist(lapply(X = spectraList, FUN = function(x){
    if(is.null(x))  return(NULL)
    else            return(x$mz)
  }))
  precursorRt <- unlist(lapply(X = spectraList, FUN = function(x){
    if(is.null(x))  return(NULL)
    else            return(x$rt)
  }))
  
  if(!is.na(progress))  if(progress)  incProgress(amount = 0.01, detail = paste("MS/MS file boxing", sep = "")) else print(paste("MS/MS file boxing", sep = ""))
  returnObj <- list()
  returnObj$fileSpectra <- NA
  returnObj$spectraList <- spectraList
  returnObj$numberOfSpectra <- numberOfSpectra
  returnObj$numberOfSpectraOriginal <- numberOfSpectraOriginal
  returnObj$numberOfMS2PeaksOriginal <- numberOfMS2PeaksOriginal
  returnObj$numberOfMS2PeaksWithNeutralLosses <- numberOfMS2PeaksWithNeutralLosses
  returnObj$numberOfMS2PeaksAboveThreshold <- numberOfMS2PeaksAboveThreshold
  returnObj$numberOfMS2PeaksBelowThreshold <- numberOfMS2PeaksBelowThreshold
  returnObj$numberOfTooHeavyFragments <- numberOfTooHeavyFragments
  returnObj$numberOfSpectraDiscardedDueToNoPeaks <- numberOfSpectraDiscardedDueToNoPeaks
  returnObj$numberOfSpectraDiscardedDueToMaxIntensity <- numberOfSpectraDiscardedDueToMaxIntensity
  returnObj$numberOfSpectraDiscardedDueToTooHeavy <- numberOfSpectraDiscardedDueToTooHeavy
  returnObj$precursorMz <- precursorMz
  returnObj$precursorRt <- precursorRt
  
  return(returnObj)
}

parseMSP_attributes <- function(fileSpectra, progress = FALSE, flexiblePeakList = FALSE, multiplePeaksPerLine = FALSE, includeIDasRecordSeparator=TRUE, includeNAMEasRecordSeparator=TRUE, includeTITLEasRecordSeparator=TRUE, returnEmptySpectra = FALSE){
  fileLines <- readLines(con = fileSpectra)
  
  if(!is.na(progress))  if(progress)  incProgress(amount = 0, detail = "MS/MS file: Read file") else print("MS/MS file: Read file")
  
  numberOfFileLines <- length(fileLines)
  
  ## start with empty lines or not?
  endOfRecord <- TRUE
  if(numberOfFileLines > 0)
    if(nchar(trimws(fileLines[[1]])) > 0)
      endOfRecord <- FALSE
  
  ## check for pattern
  if(!is.na(progress))  if(progress)  incProgress(amount = 0, detail = "MS/MS file: Parse") else print("MS/MS file: Parse")
  isID  	<- grepl(pattern = "^ID:",                            		x = fileLines)
  isBI  	<- grepl(pattern = "^BEGIN IONS$",                    		x = fileLines)
  isName	<- grepl(pattern = "(^Name:)|(^NAME:)",               		x = fileLines)
  isNAme	<- grepl(pattern = "^NAME=",                           		x = fileLines)
  isTITLE	<- grepl(pattern = "^TITLE=",                          		x = fileLines)
  isAccession	<- grepl(pattern = "^ACCESSION:",                          		x = fileLines)
  
  if(!includeIDasRecordSeparator) isID <- rep(x = F, times = length(isID))
  if(!includeNAMEasRecordSeparator){
    isName <- rep(x = F, times = length(isName))
    isNAme <- rep(x = F, times = length(isNAme))
  }
  if(!includeTITLEasRecordSeparator) isTITLE <- rep(x = F, times = length(isTITLE))
  
  numberSmall <- "\\d+(\\.\\d+)?"
  numberBig   <- "\\d+(\\.\\d+(E\\d+)?)?"
  mzValueRegEx <- "(\\d+(\\.\\d+)?)"
  intensityRegex <- "(\\d+((\\.\\d+)?([eE](-)?\\d+)?)?)"
  annotationRegex <- "\".+\""
  if(flexiblePeakList){
    isPeak	<- grepl(pattern = "^[ \t]*\\d+(\\.\\d+([eE](-)?\\d+)?)?([ \t]\\d+(\\.\\d+([eE](-)?\\d+)?)?)*[ \t]*$",	x = fileLines)
  } else {
    isPeak	<- grepl(pattern = paste("^[ \t]*", mzValueRegEx, "[ \t]", intensityRegex, "([ \t]+((", mzValueRegEx, "[ \t]", intensityRegex, ")|(", annotationRegex, ")))*[ \t]*$", sep = ""),	x = fileLines)
  }
  isEmpty	<- nchar(trimws(fileLines)) == 0
  
  tagVector   <- unlist(lapply(X = str_split(string = fileLines, pattern = "(:)|(=)"), FUN = function(x){x[[1]]}))
  valueVector <- trimws(substr(x = fileLines, start = nchar(tagVector) + 1 + 1, stop = nchar(fileLines)))
  
  ## entry line intervals in file
  entryBorders   <- c(which(isName | isNAme | isTITLE | isBI | isID | isAccession), length(fileLines)+1)
  entryIntervals <- matrix(data = unlist(lapply(X = seq_len(length(entryBorders) - 1), FUN = function(x){c(entryBorders[[x]], entryBorders[[x+1]] - 1)})), nrow=2)
  
  ## do it
  if(!is.na(progress))  if(progress)  incProgress(amount = 0, detail = "MS/MS file: Assemble spectra") else print("MS/MS file: Assemble spectra")
  spectraList <- apply(X = entryIntervals, MARGIN = 2, FUN = function(x){
    #print(x)
    fileLines2   <- fileLines  [x[[1]]:x[[2]]]
    isPeak2	     <- isPeak	   [x[[1]]:x[[2]]]
    isEmpty2     <- isEmpty    [x[[1]]:x[[2]]]
    
    tagVector2   <- tagVector  [x[[1]]:x[[2]]]
    valueVector2 <- valueVector[x[[1]]:x[[2]]]
    
    ###################################################################
    ## built ms set
    spectrumItem <- list()
    spectrumItem[tagVector2[!isPeak2 & !isEmpty2]] <- trimws(valueVector2[!isPeak2 & !isEmpty2])
    
    if(!is.null(spectrumItem$"Num Peaks"))
      if(spectrumItem$"Num Peaks" == "0" & !returnEmptySpectra)
        return(NULL)
    
    peakLines <- fileLines2[isPeak2]
    peakLines <- trimws(gsub(x = peakLines, pattern = "\".*\"", replacement = ""))
    
    if(multiplePeaksPerLine){
      peakLines <- unlist(strsplit(x = peakLines, split = "[ \t]"))
    } else {
      peakLines <- unlist(lapply(X = strsplit(x = peakLines, split = "[ \t]"), FUN = function(peaktokens){peaktokens[1:2]}))
    }
    spectrumItem["peaks"] <- paste(peakLines, collapse = " ")
    spectrumItem["peaks"] <- trimws(gsub(x = spectrumItem["peaks"], pattern = "  ", replacement = " "))
    
    ## check peaks
    tokens <- strsplit(x = spectrumItem[["peaks"]], split = "[ \t]")[[1]]
    if(length(tokens) == 0){#spectrumItem$"Num Peaks" == "0"){
      mzs  <- character(0)
      ints <- character(0)
      warning(paste(basename(fileSpectra), ": Empty peak list for [", paste(x, collapse = ","), "]", sep = ""))
    } else {
      mzs  <- tokens[seq(from=1, to=length(tokens), by = 2)]
      ints <- tokens[seq(from=2, to=length(tokens), by = 2)]
    }
    if(length(mzs) != length(ints)) stop("error in parsing peaks")
    
    ## handle duplicated tags
    duplicatedTags    <- unique(names(spectrumItem)[duplicated(names(spectrumItem))])
    if(length(duplicatedTags) > 0){
      duplicated <- sapply(X = duplicatedTags, FUN = function(x){
        unlist(sapply(X = seq_along(spectrumItem), FUN = function(y){ if(names(spectrumItem[y])==x) return(y) }))
      }, simplify = F)
      
      indecesToRemove <- vector(mode = "integer", length = 0)
      for(idx in seq_along(duplicated)){
        indeces <- duplicated[[idx]]
        representant <- indeces[[1]]
        indecesToRemoveHere <- indeces[-1]
        
        spectrumItem[[representant]] <- paste(spectrumItem[indeces], sep = "; ")
        indecesToRemove <- c(indecesToRemove, indecesToRemoveHere)
      }
      spectrumItem <- spectrumItem[-indecesToRemove]
    }
    
    return(spectrumItem)
  })
  
  rm(
    isName,
    isNAme,
    isTITLE,
    isBI,
    isID,
    isPeak,
    tagVector,
    valueVector
  )
  
  if(!is.na(progress))  if(progress)  incProgress(amount = 0.1, detail = "MS/MS file: Box") else print("MS/MS file: Box")
  
  ## remove NULL entries?
  spectraList[unlist(lapply(X = spectraList, FUN = is.null))] <- NULL
  
  numberOfSpectra <- length(spectraList)
  
  ## postprocess
  if(!is.na(progress))  if(progress)  incProgress(amount = 0.01, detail = paste("MS/MS file postprocessing", sep = "")) else print(paste("MS/MS file postprocessing", sep = ""))
  
  if(!is.na(progress))  if(progress)  incProgress(amount = 0.01, detail = paste("MS/MS file boxing", sep = "")) else print(paste("MS/MS file boxing", sep = ""))
  returnObj <- list()
  returnObj$fileSpectra <- fileSpectra
  returnObj$spectraList <- spectraList
  returnObj$numberOfSpectra <- numberOfSpectra
  
  return(returnObj)
}





####################################################################################
## built matrix

builtMatrix <- function(spectraList, 
                        mzDeviationAbsolute_grouping, 
                        mzDeviationInPPM_grouping, 
                        doMs2PeakGroupDeisotoping, 
                        mzDeviationAbsolute_ms2PeakGroupDeisotoping, 
                        mzDeviationInPPM_ms2PeakGroupDeisotoping, 
                        proportionOfMatchingPeaks_ms2PeakGroupDeisotoping, 
                        progress = FALSE)
{
  
  if(!is.na(progress))  if(progress)  incProgress(amount = 0.005, detail = paste("Fragment grouping preprocessing...", sep = "")) else print(paste("Fragment grouping preprocessing...", sep = ""))
  numberOfSpectra <- length(spectraList)
  
  fragment_mz   <- as.vector(unlist(lapply(X = spectraList, FUN = function(x){x$ms2Peaks_mz })))
  fragment_int  <- as.vector(unlist(lapply(X = spectraList, FUN = function(x){x$ms2Peaks_int})))
  fragment_spec <- as.vector(unlist(lapply(X = spectraList, FUN = function(x){x$peakNumber  })))
  fragment_spec <- rep(x = seq_len(numberOfSpectra), times = fragment_spec)
  numberOfMS2Peaks <- length(fragment_mz)
  
  if(!is.na(progress))  if(progress)  incProgress(amount = 0.005, detail = paste("Fragment grouping preprocessing ready", sep = "")) else print(paste("Fragment grouping preprocessing ready", sep = ""))
  if(!is.na(progress))  if(progress)  incProgress(amount = 0,     detail = paste("Fragment grouping", sep = "")) else print(paste("Fragment grouping", sep = ""))
  startTime <- Sys.time()
  
  resultObj <- mzClustGeneric(
    p = matrix(data = c(fragment_mz, fragment_spec), nrow = numberOfMS2Peaks, ncol = 2), 
    sampclass = NULL, 
    mzppm = mzDeviationInPPM_grouping, mzabs = mzDeviationAbsolute_grouping, 
    minsamp = 1, minfrac = 0,
    progress
  )
  
  endTime <- Sys.time()
  if(!is.na(progress))  if(progress)  incProgress(amount = 0.2,     detail = paste("Fragment grouping ready (", difftime(time1 = endTime, time2 = startTime, units = "secs"), "s)", sep = "")) else print(paste("Fragment grouping ready (", difftime(time1 = endTime, time2 = startTime, units = "secs"), "s)", sep = ""))
  
  if(!is.na(progress))  if(progress)  incProgress(amount = 0.05, detail = paste("Fragment group postprocessing", sep = "")) else print(paste("Fragment group postprocessing", sep = ""))
  startTime <- Sys.time()
  matrixRows <- vector(mode = "numeric")
  matrixCols <- vector(mode = "numeric")
  matrixVals <- vector(mode = "numeric")
  
  numberOfMS2PeakGroups <- nrow(resultObj$mat)
  fragmentMasses <- resultObj$mat[, "mzmed"]
  for(groupIdx in seq_len(numberOfMS2PeakGroups)){
    if(numberOfMS2PeakGroups > 10)
      if((groupIdx %% (as.integer(numberOfMS2PeakGroups/10))) == 0)
        if(!is.na(progress))  if(progress)  incProgress(amount = 0.01, detail = paste("Fragment group postprocessing: ", groupIdx, " / ", numberOfMS2PeakGroups, sep = "")) else print(paste("Fragment group postprocessing: ", groupIdx, " / ", numberOfMS2PeakGroups, sep = ""))
    
    groupMembers <- resultObj$idx[[groupIdx]]
    numberOfFragmentsInGroup <- length(groupMembers)
    
    matrixCols <- c(matrixCols, rep(x = groupIdx, times = numberOfFragmentsInGroup))
    matrixRows <- c(matrixRows, fragment_spec[groupMembers])
    matrixVals <- c(matrixVals, fragment_int[groupMembers])
  }
  
  numberOfCollisions <- sum(duplicated(cbind(matrixRows, matrixCols)))
  endTime <- Sys.time()
  if(!is.na(progress))  if(progress)  incProgress(amount = 0, detail = paste("Fragment group postprocessing ready (", difftime(time1 = endTime, time2 = startTime, units = "secs"), "s)", sep = "")) else print(paste("Fragment group postprocessing ready (", difftime(time1 = endTime, time2 = startTime, units = "secs"), "s)", sep = ""))
  
  if(length(matrixRows) == 0){
    ## box results
    if(!is.na(progress))  if(progress)  incProgress(amount = 0.05, detail = paste("Fragment group boxing", sep = "")) else print(paste("Fragment group boxing", sep = ""))
    returnObj <- list()
    returnObj$matrix <- matrix(nrow = 0, ncol = 0)
    returnObj$numberOfSpectra <- numberOfSpectra
    returnObj$fragmentMasses <- vector(mode = "numeric", length = 0)
    returnObj$numberOfCollisions <- numberOfCollisions
    
    returnObj$numberOfMS2Peaks <- numberOfMS2Peaks
    returnObj$numberOfMS2PeaksPrior <- 0
    returnObj$numberOfRemovedMS2IsotopePeaks <- 0
    returnObj$numberOfMS2PeakGroups <- numberOfMS2PeakGroups
    returnObj$numberOfMS2PeakGroupsPrior <- 0
    returnObj$numberOfRemovedMS2PeakGroupIsotopeColumns <- 0
    
    return(returnObj)
  }
  
  if(!is.na(progress))  if(progress)  incProgress(amount = 0, detail = paste("Boxing to matrix", sep = "")) else print(paste("Boxing to matrix", sep = ""))
  matrix <- sparseMatrix(i = matrixRows, j = matrixCols, x = matrixVals, dims = c(numberOfSpectra, numberOfMS2PeakGroups))
  
  orderTempCol <- order(fragmentMasses)
  matrix <- matrix[, orderTempCol]
  fragmentMasses <- fragmentMasses[orderTempCol]
  
  ## deisotoping
  numberOfMS2PeakGroupsPrior <- numberOfMS2PeakGroups
  numberOfRemovedMS2PeakGroupIsotopeColumns <- 0
  numberOfMS2PeaksPrior <- numberOfMS2Peaks
  numberOfRemovedMS2IsotopePeaks <- 0
  if(doMs2PeakGroupDeisotoping){
    if(!is.na(progress))  if(progress)  incProgress(amount = 0.05, detail = paste("Fragment group deisotoping", sep = "")) else print(paste("Fragment group deisotoping", sep = ""))
    startTime <- Sys.time()
    
    distance13Cminus12C <- 1.0033548378
    ## mark isotope precursors
    ms2PeakGroupsToRemove <- vector(mode = "logical", length = numberOfMS2PeakGroups)
    for(ms2PeakGroupIdx in seq_len(numberOfMS2PeakGroups)){
      if(numberOfMS2PeakGroups > 10)
        if((ms2PeakGroupIdx %% (as.integer(numberOfMS2PeakGroups/10))) == 0)
          if(!is.na(progress)){
            if(progress)  incProgress(amount = 0.0, detail = paste("Fragment group deisotoping ", ms2PeakGroupIdx, " / ", numberOfMS2PeakGroups, sep = "")) else print(paste("Fragment group deisotoping ", ms2PeakGroupIdx, " / ", numberOfMS2PeakGroups, sep = ""))
          }
      mzError <- abs(fragmentMasses[[ms2PeakGroupIdx]] * mzDeviationInPPM_ms2PeakGroupDeisotoping / 1E6)
      mzError <- max(mzError, mzDeviationAbsolute_ms2PeakGroupDeisotoping)
      
      ## MZ difference around 1.0033548378 (first isotope) or 1.0033548378 * 2 (second isotope)
      if(fragmentMasses[[ms2PeakGroupIdx]] > 0){
        ## fragment
        distances <- (fragmentMasses[[ms2PeakGroupIdx]] - distance13Cminus12C)     - fragmentMasses[-ms2PeakGroupIdx]
      } else {
        ## neutral loss
        distances <- (fragmentMasses[[ms2PeakGroupIdx]] + distance13Cminus12C)     - fragmentMasses[-ms2PeakGroupIdx]
      }
      validInMz <- abs(distances) <= mzError
      
      if(!any(validInMz))
        next
      validInMz <- which(validInMz)
      if(fragmentMasses[[ms2PeakGroupIdx]] < 0)
        validInMz <- validInMz + 1
      
      ## isotopic fragments are mainly in spectra with monoisotopic fragments
      fragmentIntensitiesHere <- matrix[, ms2PeakGroupIdx]
      
      isotopicThere <- fragmentIntensitiesHere != 0
      numberOfFragmentPeaksHere <- sum(isotopicThere)
      
      validInOverlap <- apply(X = matrix(data = matrix[, validInMz], 
                                         nrow = numberOfSpectra), 
                              MARGIN = 2, FUN = function(x){
                                monoisotopicThere <- x != 0
                                precursorInCommon <- isotopicThere & monoisotopicThere
                                validOverlap <- (sum(precursorInCommon) / sum(isotopicThere)) >= proportionOfMatchingPeaks_ms2PeakGroupDeisotoping
                                return(validOverlap)
                              })
      
      if(!any(validInOverlap))
        next
      
      monoisotopicFragmentColumn <- min(validInMz[validInOverlap])
      
      
      ## intensity gets smaller in the isotope spectrum
      monoisotopicThere <- matrix[, monoisotopicFragmentColumn] != 0
      numberOfMonoisotopicFragmentPeaks <- sum(monoisotopicThere)
      precursorInCommon <- isotopicThere & monoisotopicThere
      validToRemove <- (matrix[, monoisotopicFragmentColumn] > matrix[, ms2PeakGroupIdx]) & isotopicThere
      numberOfRemovedPeaks <- sum(validToRemove)
      matrix[validToRemove, ms2PeakGroupIdx] <- rep(x = 0, times = numberOfRemovedPeaks)
      numberOfRemovedMS2IsotopePeaks <- numberOfRemovedMS2IsotopePeaks + numberOfRemovedPeaks
      
      if(sum(matrix[, ms2PeakGroupIdx] != 0) == 0)
        ms2PeakGroupsToRemove[[ms2PeakGroupIdx]] <- TRUE
    }
    
    ## remove
    matrix <- matrix[, !ms2PeakGroupsToRemove]
    
    numberOfRemovedMS2PeakGroupIsotopeColumns <- sum(ms2PeakGroupsToRemove)
    fragmentMasses <- fragmentMasses[!ms2PeakGroupsToRemove]
    numberOfMS2PeakGroups <- length(fragmentMasses)
    numberOfMS2Peaks <- numberOfMS2PeaksPrior - numberOfRemovedMS2IsotopePeaks
    
    endTime <- Sys.time()
    if(!is.na(progress))  if(progress)  incProgress(amount = 0.05, detail = paste("Fragment group deisotoping ready (", difftime(time1 = endTime, time2 = startTime, units = "secs"), "s)", sep = "")) else print(paste("Fragment group deisotoping ready (", difftime(time1 = endTime, time2 = startTime, units = "secs"), "s)", sep = ""))
  }
  
  precursorMz <- unlist(lapply(X = spectraList, FUN = function(x){
    if(is.null(x))  return(NULL)
    else            return(x$mz)
  }))
  precursorRt <- unlist(lapply(X = spectraList, FUN = function(x){
    if(is.null(x))  return(NULL)
    else            return(x$rt)
  }))
  matrix@Dimnames[[1]] <- paste(precursorMz, precursorRt, sep = " / ") #TODO: mz / rt / x for uniqueness...?
  matrix@Dimnames[[2]] <- fragmentMasses
  
  ## box results
  if(!is.na(progress))  if(progress)  incProgress(amount = 0.05, detail = paste("Fragment group boxing", sep = "")) else print(paste("Fragment group boxing", sep = ""))
  returnObj <- list()
  returnObj$matrix <- matrix
  returnObj$numberOfSpectra <- numberOfSpectra
  returnObj$fragmentMasses <- fragmentMasses
  returnObj$numberOfCollisions <- numberOfCollisions
  
  returnObj$numberOfMS2Peaks <- numberOfMS2Peaks
  returnObj$numberOfMS2PeaksPrior <- numberOfMS2PeaksPrior
  returnObj$numberOfRemovedMS2IsotopePeaks <- numberOfRemovedMS2IsotopePeaks
  returnObj$numberOfMS2PeakGroups <- numberOfMS2PeakGroups
  returnObj$numberOfMS2PeakGroupsPrior <- numberOfMS2PeakGroupsPrior
  returnObj$numberOfRemovedMS2PeakGroupIsotopeColumns <- numberOfRemovedMS2PeakGroupIsotopeColumns
  
  return(returnObj)
}

#' Alignment of high resolution mass spectra
#'
#' adapted from R package xcms: xcms_1.44.0, package path: R/mzClust.R
#' Reference: 
#' Alignment of high resolution mass spectra: development of a heuristic approach for metabolomics
#' Metabolomics June 2006, Volume 2, Issue 2, pp 75-83
#' http://link.springer.com/article/10.1007%2Fs11306-006-0021-7
#' 
#' @param p 
#' @param sampclass 
#' @param mzppm 
#' @param mzabs 
#' @param minsamp 
#' @param minfrac 
#' @param progress 
#'
#' @return
#' @export
#'
#' @examples
mzClustGeneric <- function(p, 
                           sampclass=NULL, 
                           mzppm = 20, 
                           mzabs = 0, 
                           minsamp = 1, 
                           minfrac=0.5, 
                           progress = FALSE)
{
  makeBin <- function(pos){
    if(pos > numpeaks)
      return(list(pos=pos,bin=c(-1)))
    
    bin <- pord[pos]
    pos <- pos+1
    basepeak <- p[bin[1],1]
    
    error_range <- c(basepeak, abs(basepeak)*error_window+basepeak+2*mzabs)
    while(pos < numpeaks && p[pord[pos],1] <= error_range[2]) {
      bin <- c(bin,pord[pos])
      pos <- pos + 1
    }
    
    lst <- list(pos=pos,bin=bin)
    lst
  }
  meanDeviationOverLimit <- function(bin){
    bin_mz <- p[bin,1]
    m <- mean(bin_mz)
    error_range <- c(m-ppm_error*abs(m)-mzabs, ppm_error*abs(m)+m+mzabs)
    if(length(bin_mz[(bin_mz > error_range[2]) |
                     (bin_mz < error_range[1])]) > 0 ) {
      return(TRUE)
    } else { FALSE }
  }
  bin2output <- function(bin){
    gcount <- integer(length(classnum))
    if(length(gcount) != 0){
      for(i in seq(along = bin)){
        class_idx <- sampclass[p[bin[i],2]]
        gcount[class_idx] <- gcount[class_idx] + 1
      }
    }
    ## make sure, that if no classes given, 'any' is false
    if(length(bin) < minsamp || (!any(gcount >= classnum*minfrac) && length(gcount)>0))
      return(list())
    groupvec <- c(rep(NA,4+length(gcount)))
    groupvec[1] <- mean(p[bin,1])
    groupvec[2:3] <- range(p[bin,1])
    groupvec[4] <- length(bin)
    sorted <- order(p[bin,1])
    grp_members <- bin[sorted]
    groupvec[4+seq(along = gcount)] <- gcount
    lst <- list(stat=groupvec,members=grp_members)
    lst
  }
  ppm_error <- mzppm/1000000
  error_window <- 2*ppm_error
  
  ## numeric version of classlabel
  if(is.null(sampclass)){
    classnum <- integer(0)
    classnames <- seq(along=classnum)
  } else {
    classnames <- levels(sampclass)
    sampclass <- as.vector(unclass(sampclass))
    
    classnum <- integer(max(sampclass))
  }
  
  for(i in seq(along = classnum))
    classnum[i] <- sum(sampclass == i)
  
  numpeaks <- nrow(p)
  
  groupmat <- matrix(nrow = 512, ncol = 4 + length(classnum))
  groupindex <- vector("list", 512)
  
  pord <- order(p[,1])
  pos <- c(1)
  binNumber <- 1
  newbin <- makeBin(pos)
  binA <- newbin$bin
  pos <- newbin$pos
  
  lastOut <- proc.time()["user.self"]
  lastPos <- 1
  
  loopCounter <- 0
  while(TRUE){
    loopCounter <- loopCounter + 1
    
    if(binNumber +4 > nrow(groupmat)){
      groupmat <- rbind(groupmat, matrix(nrow = nrow(groupmat), ncol = ncol(groupmat)))
      groupindex <- c(groupindex, vector("list", length(groupindex)))
    }
    
    ## progress output
    time <- proc.time()["user.self"]
    if(time - lastOut > 1){
      lastOut <- time
      peakProgress <- (pos - lastPos) / numpeaks
      lastPos <- pos
      if(!is.na(progress))  if(progress)  incProgress(amount = peakProgress * 0.2,     detail = paste("Fragment grouping ", pos, " / ", numpeaks, sep = "")) else {
        print(paste("Fragment grouping ", pos, " / ", numpeaks, sep = ""))
      }
    }
    
    newbin <- makeBin(pos)
    binB <- newbin$bin
    pos <- newbin$pos
    
    if(binB[1] < 0){
      ## cancel
      out <- bin2output(binA)
      if(length(out) != 0){
        groupmat[binNumber,] <- out$stat
        groupindex[[binNumber]] <- out$members
        binNumber <- binNumber + 1
      }
      break
    }
    max_binA <- max(p[binA,1])
    min_binB <- min(p[binB,1])
    
    binclust <- 0
    if(   max_binA + abs(max_binA)*error_window+2*mzabs >= min_binB 
          && min_binB - abs(min_binB)*error_window - 2*mzabs <= max_binA){
      binC <- c(binA,binB)
      binclust <- 1
    } else {
      if(meanDeviationOverLimit(binA)){
        binC <- binA
        binclust <- 2
      }
    }
    
    ## case: not in range or mean deviation over limit
    ## perform hierarchical clustering
    if(binclust != 0){
      
      if(length(unique(p[binC,1])) > 10000){
        ## debugging
        stop(paste("Too many fragments for clustering:", 
                   ppm_error, mzabs, length(p[binC,1]), length(unique(p[binC,1]))))
      }
      
      bin <- p[binC,1]
      uniqueBin <- unique(bin)
      
      ## xcms:::mzClust_hclust is using 
      ## the fast C implementation: .C("R_mzClust_hclust"
      mzFragmentGroups <- xcms:::mzClust_hclust(uniqueBin,ppm_error,mzabs)
      mzFragmentGroups2 <- vector(mode = "integer", length = length(bin))
      for(idx in seq_along(uniqueBin))
        mzFragmentGroups2[bin==uniqueBin[[idx]]] <- mzFragmentGroups[[idx]]
      
      mzFragmentGroups <- mzFragmentGroups2
      
      last_group <- mzFragmentGroups[which.max(p[binC,1])]
      binA <- binC[which(mzFragmentGroups == last_group)]
      
      ## bug fix where there were not enough empty rows in the matrix 
      ## (in case of more than four new mzFragmentGroups)
      if(binNumber + last_group > nrow(groupmat)){
        groupmat <- rbind(groupmat, matrix(nrow = nrow(groupmat), ncol = ncol(groupmat)))
        groupindex <- c(groupindex, vector("list", length(groupindex)))
      }
      
      if(max(mzFragmentGroups) >1){
        for(c in 1:max(mzFragmentGroups)){
          if(c == last_group){
            next
          }
          tmp_grp <- which(mzFragmentGroups == c)
          tmp_c <- binC[tmp_grp]
          out <- bin2output(tmp_c)
          if(length(out) != 0){
            groupmat[binNumber,] <- out$stat
            groupindex[[binNumber]] <- out$members
            binNumber <- binNumber + 1
          }
        }
      }
    }
    
    if(binclust != 1){
      out <- bin2output(binA)
      if(length(out) != 0){
        groupmat[binNumber,] <- out$stat
        groupindex[[binNumber]] <- out$members
        binNumber <- binNumber + 1
      }
      binA <- binB
    }
  }
  colnames(groupmat) <- c("mzmed", "mzmin", "mzmax", "npeaks", classnames)
  
  binNumber <- binNumber - 1
  groupmat <- groupmat[seq(length = binNumber), ]
  groupindex <- groupindex[seq(length = binNumber)]
  cat("\n")
  flush.console()
  return(list(mat=groupmat,idx=groupindex))
}

convertToProjectFile <- function(filePeakMatrixPath, 
                                 fileSpectra,
                                 fileAnnotation,
                                 parameterSet, 
                                 progress = FALSE){
  ####################################################################################
  ## parse MS/MS spectra
  
  if(!is.na(progress))  if(progress)  incProgress(amount = 0.01, detail = paste("Parsing MS/MS file...", sep = "")) else print(paste("Parsing MS/MS file...", sep = ""))
  
  returnObj <- parseMSP(
    fileSpectra = fileSpectra, 
    minimumIntensityOfMaximalMS2peak = parameterSet$minimumIntensityOfMaximalMS2peak, 
    minimumProportionOfMS2peaks = parameterSet$minimumProportionOfMS2peaks, 
    neutralLossesPrecursorToFragments = parameterSet$neutralLossesPrecursorToFragments,
    neutralLossesFragmentsToFragments = parameterSet$neutralLossesFragmentsToFragments,
    progress = progress
  )
  spectraList <- returnObj$spectraList
  numberOfSpectra <- returnObj$numberOfSpectra
  numberOfSpectraOriginal <- returnObj$numberOfSpectraOriginal
  precursorMz     <- returnObj$precursorMz
  precursorRt     <- returnObj$precursorRt
  numberOfMS2PeaksOriginal <- returnObj$numberOfMS2PeaksOriginal
  numberOfMS2PeaksWithNeutralLosses <- returnObj$numberOfMS2PeaksWithNeutralLosses
  numberOfMS2PeaksAboveThreshold <- returnObj$numberOfMS2PeaksAboveThreshold
  numberOfMS2PeaksBelowThreshold <- returnObj$numberOfMS2PeaksBelowThreshold
  numberOfTooHeavyFragments <- returnObj$numberOfTooHeavyFragments
  numberOfSpectraDiscardedDueToNoPeaks <- returnObj$numberOfSpectraDiscardedDueToNoPeaks
  numberOfSpectraDiscardedDueToMaxIntensity <- returnObj$numberOfSpectraDiscardedDueToMaxIntensity
  numberOfSpectraDiscardedDueToTooHeavy <- returnObj$numberOfSpectraDiscardedDueToTooHeavy
  
  if(numberOfSpectra == 0)
    return("Number of spectra is zero")
  
  if(!is.na(progress))  if(progress)  incProgress(amount = 0.01, detail = paste("Parsing MS/MS file ready", sep = "")) else print(paste("Parsing MS/MS file ready", sep = ""))
  
  rm(returnObj)
  
  
  filePeakMatrixQF <- readMSDial(filePeakMatrixPath)
  if (!is.null(fileAnnotation)){
    # TODO: determine colums to merge by
    filePeakMatrixQF <- addSiriusAnnotations(filePeakMatrixQF,fileAnnotation)
  }
  
  returnObj <- convertToProjectFile2(
    filePeakMatrixQF = filePeakMatrixQF, 
    spectraList = spectraList, precursorMz = precursorMz, precursorRt = precursorRt, 
    metaboliteFamilies = rep(x = "", times = numberOfSpectra), uniqueMetaboliteFamilies = NULL, metaboliteFamilyColors = NULL, 
    parameterSet = parameterSet, 
    progress = progress
  )
  returnObj$numberOfSpectraOriginal <- numberOfSpectraOriginal
  returnObj$numberOfMS2PeaksOriginal <- numberOfMS2PeaksOriginal
  returnObj$numberOfMS2PeaksWithNeutralLosses <- numberOfMS2PeaksWithNeutralLosses
  returnObj$numberOfMS2PeaksAboveThreshold <- numberOfMS2PeaksAboveThreshold
  returnObj$numberOfMS2PeaksBelowThreshold <- numberOfMS2PeaksBelowThreshold
  returnObj$numberOfTooHeavyFragments <- numberOfTooHeavyFragments
  returnObj$numberOfSpectraDiscardedDueToNoPeaks <- numberOfSpectraDiscardedDueToNoPeaks
  returnObj$numberOfSpectraDiscardedDueToMaxIntensity <- numberOfSpectraDiscardedDueToMaxIntensity
  returnObj$numberOfSpectraDiscardedDueToTooHeavy <- numberOfSpectraDiscardedDueToTooHeavy
 
  return(returnObj)
}

convertToProjectFile2 <- function(filePeakMatrixQF, 
                                  spectraList, 
                                  precursorMz, 
                                  precursorRt, 
                                  metaboliteFamilies, 
                                  uniqueMetaboliteFamilies, 
                                  metaboliteFamilyColors, 
                                  furtherProperties = list(), 
                                  parameterSet, 
                                  progress = FALSE)
{
  numberOfSpectraParsed <- length(spectraList)
  
  ####################################################################################
  ## metabolite profile
  if(!is.na(progress))  if(progress)  incProgress(amount = 0.1, detail = paste("Parsing MS1 file...", sep = "")) else print(paste("Parsing MS1 file...", sep = ""))
  
  if(!is.null(filePeakMatrixQF)){
    returnObj <- parsePeakAbundanceMatrixQF(
      qfeatures = filePeakMatrixQF, 
      doPrecursorDeisotoping = parameterSet$doPrecursorDeisotoping, 
      mzDeviationInPPM_precursorDeisotoping = parameterSet$mzDeviationInPPM_precursorDeisotoping, 
      mzDeviationAbsolute_precursorDeisotoping = parameterSet$mzDeviationAbsolute_precursorDeisotoping, 
      maximumRtDifference = parameterSet$maximumRtDifference,
      progress = progress
    )
    dataFrame <- returnObj$dataFrame
    oldFormat <- returnObj$oldFormat
    numberOfPrecursors <- returnObj$numberOfPrecursors
    dataColumnStartEndIndeces <- returnObj$dataColumnStartEndIndeces
    numberOfDataColumns <- returnObj$numberOfDataColumns
    
    groupLabels          <- returnObj$sampleClass
    sampleType           <- returnObj$sampleType
    sampleInjectionOrder <- returnObj$sampleInjectionOrder
    batchID              <- returnObj$batchID
    
    numberOfParsedMs1Features <- returnObj$numberOfPrecursorsPrior
    numberOfRemovedPrecursorIsotopePeaks <- returnObj$numberOfRemovedIsotopePeaks
    
    qfeatures <- returnObj$qfeatures
    rm(returnObj)
  } else {
    propList <- list(
      "Average Rt(min)" = precursorRt,
      "Average Mz" = precursorMz,
      "Metabolite name" = unlist(lapply(X = spectraList, FUN = function(x){x$name})),
      "Adduct ion name" = unlist(lapply(X = spectraList, FUN = function(x){x$adduct}))
    )
    propList <- c(propList, furtherProperties)
    propList <- c(propList, list("MySample" = rep(x = 0, times = numberOfSpectraParsed)))
    dataFrame <- data.frame(propList, check.names = FALSE, stringsAsFactors = FALSE)
    oldFormat <- FALSE
    
    numberOfPrecursors <- numberOfSpectraParsed
    dataColumnStartEndIndeces <- c(5,5) + length(furtherProperties)
    numberOfDataColumns <- 1
    
    groupLabels <- c("Unknown")
    sampleType <- c("Sample")
    sampleInjectionOrder <- -1
    batchID              <- -1
    
    numberOfPrecursorsPrior <- numberOfPrecursors
    numberOfRemovedPrecursorIsotopePeaks <- 0
    
    numberOfParsedMs1Features <- -1
  }
  
  isGC <- "EI spectrum" %in% colnames(dataFrame)
  if(isGC){
    ## in case of GC-MS data set this value according to retention time
    #assignment <- unlist(lapply(X = precursorRt, FUN = function(x){
    #  precursorMz[[which.min(abs(x-dataFrame$"Average Rt(min)"))]]
    #}))
    
    #diffAll <- abs(outer(X = precursorRt, Y = dataFrame$"Average Rt(min)", FUN = function(x, y){abs(x-y)}))
    #allHits <- apply(X = diffAll, MARGIN = 2, FUN = function(x){which(x == min(x[x < parameterSet$mzDeviationAbsolute_mapping], Inf))})
    #assignment <- unlist(lapply(X = allHits, FUN = function(x){
    #  if(length(x) == 0)
    #    return(-1)
    #  return(precursorMz[[x[[1]]]])
    #}))
    
    dataFrame$"Average Mz" <- as.numeric(dataFrame$"Quant mass")
    
    if(nrow(dataFrame) == length(spectraList)){
      ## replace rounded rts in the MS1 data by the unrounded ones from the MS/MS data
      dataFrame$"Average Rt(min)" <- unlist(lapply(X = spectraList, FUN = function(x){x$rt}))
    }
    
    ## remove empty spectra
    nullSpectra <- unlist(lapply(X = spectraList, FUN = is.null))
    if(any(nullSpectra)){
      spectraList[nullSpectra] <- NULL
      dataFrame <- dataFrame[-which(nullSpectra),]
      metaboliteFamilies <- metaboliteFamilies[-which(nullSpectra)] ## unique metabolite families and colors...?
      furtherProperties <- lapply(X = furtherProperties, FUN = function(props){props[-which(nullSpectra)]})
      numberOfPrecursors <- length(spectraList)
      precursorMz <- dataFrame$"Average Mz"
      precursorRt <- dataFrame$"Average Rt(min)"
      numberOfSpectra <- length(spectraList)
    }
  }
  
  ## remove redundant MS1 features
  precursorLabels <- paste(dataFrame$"Average Mz", dataFrame$"Average Rt(min)", sep = " / ")
  dupplicated <- which(duplicated(precursorLabels))
  numberOfDupplicated <- length(dupplicated)
  if(numberOfDupplicated > 0){
    precursorLabels <- precursorLabels[-dupplicated]
    dataFrame <- dataFrame[-dupplicated, ]
  }
  numberOfPrecursors <- numberOfPrecursors - numberOfDupplicated
  
  ####################################################################################
  ## map MS1 and MS/MS to each other
  
  if(!is.na(progress))  if(progress)  incProgress(amount = 0.1, detail = "Postprocessing matrix...") else print("Postprocessing matrix...")
  
  ## order rows by precursor m/z and order columns by fragment group m/z (needed for deisotoping)
  orderMS1features <- order(precursorMz)
  
  precursorMz <- precursorMz[orderMS1features]
  precursorRt <- precursorRt[orderMS1features]
  spectraList <- spectraList[orderMS1features]
  metaboliteFamilies <- metaboliteFamilies[orderMS1features]
  furtherProperties <- lapply(X = furtherProperties, FUN = function(props){props[orderMS1features]})
  
  #TODO: resolve ?
  #temporary fix
  #filePeakMatrix <- NULL
  
  if(!is.null(filePeakMatrixQF)){
    ## allHits: dataFrame$"Average Mz" --> precursorMz; allHits indexes the spectraList
    diffAll <- abs(outer(X = precursorMz, Y = dataFrame$"Average Mz", FUN = function(x, y){abs(x-y)}))
    allHits <- apply(X = diffAll, MARGIN = 2, FUN = function(x){which(x == min(x[x < parameterSet$mzDeviationAbsolute_mapping], Inf))})
    rm(diffAll)
  } else {
    allHits <- lapply(X = dataFrame$"Average Mz", FUN = function(x){which(precursorMz == x)})
  }
  if(is.array(allHits))
    allHits <- as.list(as.data.frame(allHits))
  
  numberOfUnmappedPrecursorsMz <- 0
  numberOfUnmappedPrecursorsRt <- 0
  
  for(i in seq_len(numberOfPrecursors)){
    numberOfItems <- length(allHits[[i]])
    if(numberOfItems == 1)
      if(is.na(allHits[[i]]))
        numberOfItems <- 0
    
    if(numberOfItems == 0){    ## no hit
      allHits[[i]] <- NA
      numberOfUnmappedPrecursorsMz <- numberOfUnmappedPrecursorsMz + 1
    }
    else{    ## take hit with minimum absolute RT difference
      absoluteDifferences <- abs(dataFrame$"Average Rt(min)"[i] - precursorRt[allHits[[i]]])
      bestIdx <- which.min(absoluteDifferences)
      if(length(bestIdx) > 1)
        bestIdx <- bestIdx[[1]]
      if(absoluteDifferences[[bestIdx]] <= parameterSet$maximumRtDifference){
        allHits[[i]] <- allHits[[i]][[bestIdx]]
      } else {
        allHits[[i]] <- NA
        numberOfUnmappedPrecursorsRt <- numberOfUnmappedPrecursorsRt + 1
      }
    }
  }
  ## apply
  hitsTempAll     <- unlist(allHits)
  naRows <- is.na(hitsTempAll)
  hitsTempAll     <- hitsTempAll[!naRows]
  ## sub set matrices
  numberOfUnmappedSpectra <- length(spectraList) - length(spectraList[hitsTempAll])
  spectraList      <- spectraList[hitsTempAll]
  numberOfSpectra <- length(spectraList)
  ## sub set 
  metaboliteFamiliesAll <- metaboliteFamilies[hitsTempAll]
  furtherPropertiesAll <- lapply(X = furtherProperties, FUN = function(props){props[hitsTempAll]})
  
  dataFrame <- dataFrame[!naRows, ]
  precursorMzAll <- dataFrame$"Average Mz"
  precursorRtAll <- dataFrame$"Average Rt(min)"
  numberOfPrecursors <- length(precursorMzAll)
  numberOfUnmappedPrecursors <- sum(naRows)
  
  ####################################################################################
  ## built matrix
  
  if(!is.na(progress))  if(progress)  incProgress(amount = 0.01, detail = paste("Building fragment mzFragmentGroups...", sep = "")) else print(paste("Building fragment mzFragmentGroups...", sep = ""))
  if(isGC){
    ## round GC mzs to integer
    for(spectrumIdx in seq_len(length(spectraList))){
      spectraList[[spectrumIdx]]$ms2Peaks_mz <- round(x = spectraList[[spectrumIdx]]$ms2Peaks_mz, digits = 1)
    }
  }
  
  returnObj <- builtMatrix(
    spectraList = spectraList, 
    mzDeviationAbsolute_grouping = parameterSet$mzDeviationAbsolute_grouping, 
    mzDeviationInPPM_grouping = parameterSet$mzDeviationInPPM_grouping, 
    doMs2PeakGroupDeisotoping = parameterSet$doMs2PeakGroupDeisotoping, 
    mzDeviationAbsolute_ms2PeakGroupDeisotoping = parameterSet$mzDeviationAbsolute_ms2PeakGroupDeisotoping,
    mzDeviationInPPM_ms2PeakGroupDeisotoping = parameterSet$mzDeviationInPPM_ms2PeakGroupDeisotoping,
    proportionOfMatchingPeaks_ms2PeakGroupDeisotoping = parameterSet$proportionOfMatchingPeaks_ms2PeakGroupDeisotoping, 
    progress = progress
  )
  matrix <- returnObj$matrix
  fragmentMasses <- returnObj$fragmentMasses
  numberOfMS2PeakGroups <- returnObj$numberOfMS2PeakGroups
  
  if(!is.na(progress))  if(progress)  incProgress(amount = 0.01, detail = paste("Building fragment mzFragmentGroups ready", sep = "")) else print(paste("Building fragment mzFragmentGroups ready", sep = ""))
  
  orderTempCol <- order(fragmentMasses)
  matrix <- matrix[, orderTempCol]
  fragmentMasses <- fragmentMasses[orderTempCol]
  
  rm(returnObj)
  
  ########################################
  ## filter empty fragment mzFragmentGroups
  numberOfFragments <- length(fragmentMasses)
  fragmentGroupNonEmpty <- vector(mode = "logical", length = numberOfFragments)
  for(colIdx in seq_len(numberOfFragments))
    fragmentGroupNonEmpty[[colIdx]] <- sum(matrix[, colIdx] != 0) > 0
  matrix <- matrix[, fragmentGroupNonEmpty]
  fragmentMasses <- fragmentMasses[fragmentGroupNonEmpty]
  numberOfFragments <- length(fragmentMasses)
  
  ########################################
  ## filter small fragment masses
  minimumFragmentMass <- 5
  tmp <- abs(fragmentMasses) < minimumFragmentMass
  fragmentMasses <- fragmentMasses[!tmp]
  matrix     <- matrix[, !tmp]
  numberOfMS2PeakGroupsAll <- ncol(matrix)
  
  ########################################
  ## convert sparse matrix to three-vector format
  dgTMatrix <- as(matrix, "dgTMatrix")
  rm(matrix)
  gc()
  
  matrixRows <- dgTMatrix@i
  matrixCols <- dgTMatrix@j
  matrixVals <- dgTMatrix@x
  rm(dgTMatrix)
  gc()
  
  ## minimum index from 0 to 1
  matrixRows <- matrixRows + 1
  matrixCols <- matrixCols + 1
  
  numberOfItems <- length(matrixRows)
  
  ########################################
  ## first fragments, then neutral losses
  colIdx <- min(which(fragmentMasses > 0))
  numberOfColumns <- length(fragmentMasses)
  
  matrixCols[matrixCols < colIdx] <- matrixCols[matrixCols < colIdx] + numberOfColumns
  matrixCols <- matrixCols - (colIdx - 1)
  
  fragmentMasses <- unlist(c(fragmentMasses[colIdx:numberOfColumns], fragmentMasses[seq_len(colIdx - 1)]))
  
  ## row ordering
  numberOfAnnotationColumns <- ncol(dataFrame)
  rowOrder <- order(precursorMzAll)
  
  ####################################################################################
  ## matrix assembly with additional columns and column head
  
  if(!is.na(progress))  if(progress)  incProgress(amount = 0.1, detail = "Boxing...") else print("Boxing...")
  
  ## additional rows stuff
  matrixRows <- as.integer(matrixRows)
  matrixCols <- as.integer(matrixCols)
  
  ## TODO performance 30s
  numberOfFragments <- length(fragmentMasses)
  meanIntensity <- vector(mode = "numeric", length = numberOfFragments)
  fragmentCount <- vector(mode = "numeric", length = numberOfFragments)
  for(colIdx in seq_len(numberOfFragments)){
    intensities <- matrixVals[matrixCols == colIdx]
    fragmentCount[[colIdx]] <- length(intensities)
    meanIntensity[[colIdx]] <- mean(x = intensities)
  }
  
  ## add stuff
  numberOfRows <- length(precursorMzAll)
  numberOfPrimaryAnnotationColumns <- 3
  columnOffset <- numberOfPrimaryAnnotationColumns + numberOfAnnotationColumns# + length(furtherPropertiesAll)
  matrixCols <- matrixCols + columnOffset
  
  ######################################
  ## additional columns
  
  ## precursor m/z
  matrixRows <- c(matrixRows, seq_len(numberOfRows))
  matrixCols <- c(matrixCols, rep(x = 1, times = numberOfRows))
  matrixVals <- c(matrixVals, precursorMzAll)
  
  ## precursor RT
  matrixRows <- c(matrixRows, seq_len(numberOfRows))
  matrixCols <- c(matrixCols, rep(x = 2, times = numberOfRows))
  matrixVals <- c(matrixVals, precursorRtAll)
  
  ## annotation column
  matrixRows <- c(matrixRows, seq_len(numberOfRows))
  matrixCols <- c(matrixCols, rep(x = 3, times = numberOfRows))
  matrixVals <- c(matrixVals, metaboliteFamiliesAll)
  
  ## all present stuff
  for(colIdx in seq_len(numberOfAnnotationColumns)){
    matrixRows <- c(matrixRows, seq_len(numberOfRows))
    matrixCols <- c(matrixCols, rep(x = numberOfPrimaryAnnotationColumns + colIdx, times = numberOfRows))
    matrixVals <- c(matrixVals, dataFrame[, colIdx])
  }
  
  ## sort rows
  rowOrderReverse <- vector(mode = "numeric", length = numberOfRows)
  for(i in seq_len(numberOfRows))
    rowOrderReverse[[i]] <- which(rowOrder == i)
  matrixRows <- rowOrderReverse[matrixRows]
  
  ######################################
  ## additional rows
  numberOfColumns <- numberOfFragments + columnOffset
  
  ##################
  ## additional row: head
  headRow <- c("m/z", "RT", "Annotation", names(dataFrame)[seq_len(numberOfAnnotationColumns)], fragmentMasses)
  matrixRows <- matrixRows + 1
  
  matrixRows <- c(matrixRows, rep(x = 1, times = numberOfColumns))
  matrixCols <- c(matrixCols, seq_len(numberOfColumns))
  matrixVals <- c(matrixVals, headRow)
  
  ##################
  ## additional row: average fragment intensity
  intensityRow <- c(rep(x = "", times = numberOfPrimaryAnnotationColumns + numberOfAnnotationColumns), meanIntensity)
  
  matrixRows <- matrixRows + 1
  
  matrixRows <- c(matrixRows, rep(x = 1, times = numberOfColumns))
  matrixCols <- c(matrixCols, seq_len(numberOfColumns))
  matrixVals <- c(matrixVals, intensityRow)
  
  ## columns tags
  if(numberOfDataColumns > 0){
    dataColumnStartIdx <- numberOfPrimaryAnnotationColumns + dataColumnStartEndIndeces[[1]]
    dataColumns <- dataColumnStartIdx:(dataColumnStartIdx + numberOfDataColumns - 1)
  } else {
    dataColumns <- NULL
  }
  
  ## AnnotationColors={AS=#0000FF, SQT-glucosides=#FF0000}
  if(!is.null(uniqueMetaboliteFamilies) & !is.null(metaboliteFamilyColors)){
    annotationColorsValue <- paste(uniqueMetaboliteFamilies, metaboliteFamilyColors, sep = "=", collapse = ", ")
  } else {
    annotationColorsValue <- ""
  }
  annotationColorsFieldValue <- paste("AnnotationColors={", annotationColorsValue, "}", sep = "")
  
  matrixRows <- c(matrixRows, rep(x = 1, times = 3 + numberOfDataColumns))
  matrixCols <- c(matrixCols, 1, 2, 3, dataColumns)
  matrixVals <- c(matrixVals, "ID", "ID", annotationColorsFieldValue, groupLabels)
  
  ##################
  ## additional row: number of present fragment entries
  fragmentCountRow <- c(rep(x = "", times = numberOfPrimaryAnnotationColumns + numberOfAnnotationColumns), fragmentCount)
  
  matrixRows <- matrixRows + 1
  
  matrixRows <- c(matrixRows, rep(x = 1, times = numberOfColumns))
  matrixCols <- c(matrixCols, seq_len(numberOfColumns))
  matrixVals <- c(matrixVals, fragmentCountRow)
  
  ##################
  ## return
  resultObj <- list(
    matrixRows = as.numeric(unlist(matrixRows)),
    matrixCols = as.numeric(unlist(matrixCols)),
    matrixVals = unlist(matrixVals),
    numberOfPrecursors = numberOfPrecursors,
    numberOfParsedSpectra = numberOfSpectraParsed,
    numberOfParsedMs1Features = numberOfParsedMs1Features,
    numberOfRemovedPrecursorIsotopePeaks = numberOfRemovedPrecursorIsotopePeaks,
    numberOfDuplicatedPrecursors = numberOfDupplicated,
    numberOfUnmappedSpectra = numberOfUnmappedSpectra,
    numberOfUnmappedPrecursors = numberOfUnmappedPrecursors,
    numberOfUnmappedPrecursorsMz = numberOfUnmappedPrecursorsMz,
    numberOfUnmappedPrecursorsRt = numberOfUnmappedPrecursorsRt,
    qfeatures <- qfeatures
  )
  
  if(!is.na(progress))  if(progress)  setProgress(1) else print("Ready")
  return(resultObj)
}

================
File: R/parsePeakAbundanceMatrixQF.R
================
#' Title
#'
#' @param qfeatures Object of type QFeatures 
#' @param doPrecursorDeisotoping 
#' @param mzDeviationInPPM_precursorDeisotoping 
#' @param mzDeviationAbsolute_precursorDeisotoping 
#' @param maximumRtDifference 
#' @param progress boolean whether or not to show a progress bar
#'
#' @return
#' @export
#'
#' @examples

parsePeakAbundanceMatrixQF <- function(qfeatures, 
                                     doPrecursorDeisotoping, 
                                     mzDeviationInPPM_precursorDeisotoping, 
                                     mzDeviationAbsolute_precursorDeisotoping, 
                                     maximumRtDifference, 
                                     progress=FALSE)
{
  ## read file
  if(!is.na(progress)) {
    if(progress) {
      incProgress(amount = 0.1, detail = paste("Parsing MS1 file content...", sep = ""))
    } else {
      print(paste("Parsing MS1 file content...", sep = ""))
    } 
  }


  
  
  cols_to_exclude <- c("Reference RT","Reference m/z","Comment",
                       "Manually modified for quantification",
                       "Total score","RT similarity","Average","Stdev") 
  
  cols_to_keep <- which(!colnames(rowData(qfeatures))[[1]] %in% cols_to_exclude)
 
  dataFrame <- cbind(rowData(qfeatures)[[1]][,cols_to_keep] ,assay(qfeatures))
  #workaround for avoiding change in colnames during coercion
  cnames <- colnames(dataFrame)
  dataFrame <- as.data.frame(dataFrame, check.names = FALSE)
  colnames(dataFrame) <- cnames
  oldFormat <- ncol(colData(qfeatures))==3
  numRowDataCols <- ncol(rowData(qfeatures)[[1]])
  dataColumnStartEndIndeces <- c(numRowDataCols+1,ncol(dataFrame))
  numberOfPrecursors <- nrow(dataFrame)
  numberOfPrecursorsPrior <- numberOfPrecursors 

  if(ncol(assay(qfeatures))>0){
    numberOfDataColumns   <- ncol(assay(qfeatures))
    sampleClass           <- colData(qfeatures)$Class
    sampleType            <- colData(qfeatures)$Type
    sampleInjectionOrder  <- colData(qfeatures)$"Injection order"
    batchID               <- NULL
    if(! is.null(colData(qfeatures)$BatchID))
      batchID            <- colData(qfeatures)$BatchID
    
    }   else {
    dataColumnStartEndIndeces <- NULL
    numberOfDataColumns <- 0
    sampleClass          <- NULL
    sampleType           <- NULL
    sampleInjectionOrder <- NULL
    batchID              <- NULL
  }
  
  commaNumbers <- sum(grepl(x = dataFrame$"Average Mz", pattern = "^(\\d+,\\d+$)|(^\\d+$)"))
  decimalSeparatorIsComma <- commaNumbers == nrow(dataFrame)
  if(decimalSeparatorIsComma){
    if(!is.null(dataFrame$"Average Rt(min)"))     dataFrame$"Average Rt(min)"     <- gsub(x = gsub(x = dataFrame$"Average Rt(min)", pattern = "\\.", replacement = ""), pattern = ",", replacement = ".")
    if(!is.null(dataFrame$"Average Mz"))          dataFrame$"Average Mz"          <- gsub(x = gsub(x = dataFrame$"Average Mz", pattern = "\\.", replacement = ""), pattern = ",", replacement = ".")
    if(!is.null(dataFrame$"Fill %"))              dataFrame$"Fill %"              <- gsub(x = gsub(x = dataFrame$"Fill %", pattern = "\\.", replacement = ""), pattern = ",", replacement = ".")
    if(!is.null(dataFrame$"Dot product"))         dataFrame$"Dot product"         <- gsub(x = gsub(x = dataFrame$"Dot product", pattern = "\\.", replacement = ""), pattern = ",", replacement = ".")
    if(!is.null(dataFrame$"Reverse dot product")) dataFrame$"Reverse dot product" <- gsub(x = gsub(x = dataFrame$"Reverse dot product", pattern = "\\.", replacement = ""), pattern = ",", replacement = ".")
    if(!is.null(dataFrame$"Fragment presence %")) dataFrame$"Fragment presence %" <- gsub(x = gsub(x = dataFrame$"Fragment presence %", pattern = "\\.", replacement = ""), pattern = ",", replacement = ".")
    
    ## replace -1 by 0
    if(numberOfDataColumns > 0) {
      for(colIdx in (numRowDataCols+1):ncol(dataFrame)){
        dataFrame[ , colIdx] <- gsub(x = gsub(x = dataFrame[ , colIdx], pattern = "\\.", replacement = ""), pattern = ",", replacement = ".")
      }
    }
  }
  
  ###################
  ## column formats
  if(!is.null(dataFrame$"Average Rt(min)"))     dataFrame$"Average Rt(min)"     <- as.numeric(dataFrame$"Average Rt(min)")
  if(!is.null(dataFrame$"Average Mz"))          dataFrame$"Average Mz"          <- as.numeric(dataFrame$"Average Mz")
  if(!is.null(dataFrame$"Fill %"))              dataFrame$"Fill %"              <- as.numeric(dataFrame$"Fill %")
  if(!is.null(dataFrame$"MS/MS included"))      dataFrame$"MS/MS included"      <- as.logical(dataFrame$"MS/MS included")
  if(!is.null(dataFrame$"Dot product"))         dataFrame$"Dot product"         <- as.numeric(dataFrame$"Dot product")
  if(!is.null(dataFrame$"Reverse dot product")) dataFrame$"Reverse dot product" <- as.numeric(dataFrame$"Reverse dot product")
  if(!is.null(dataFrame$"Fragment presence %")) dataFrame$"Fragment presence %" <- as.numeric(dataFrame$"Fragment presence %")
  
  #####################
  ## sorted by m/z (needed for deisotoping)
  if(!is.null(dataFrame$"Average Mz"))
    dataFrame <- dataFrame[order(dataFrame$"Average Mz"), ]
  
  ## replace -1 by 0
  if(numberOfDataColumns > 0){
    for(colIdx in (numRowDataCols+1):ncol(dataFrame)){
      dataFrame[ , colIdx] <- as.numeric(dataFrame[ , colIdx])
      if(!is.na(sum(dataFrame[,colIdx] == -1)))
        dataFrame[(dataFrame[,colIdx] == -1),colIdx] <- 0
    }
  }
  vals <- NULL
  ## deisotoping
  numberOfRemovedIsotopePeaks <- 0
  if(doPrecursorDeisotoping & !is.null(dataFrame$"Average Mz")){
    if(!is.na(progress))  if(progress)  incProgress(amount = 0, detail = paste("Precursor deisotoping...", sep = "")) else print(paste("Precursor deisotoping...", sep = ""))
    distance13Cminus12C <- 1.0033548378
    
    ## mark isotope precursors
    precursorsToRemove <- vector(mode = "logical", length = numberOfPrecursors)
    
    if(numberOfDataColumns > 0){
      intensities <- dataFrame[ , (numRowDataCols+1):ncol(dataFrame)]
      medians <- apply(X = as.matrix(intensities), MARGIN = 1, FUN = median)
    }
    
    for(precursorIdx in seq_len(numberOfPrecursors)){
      if((precursorIdx %% (as.integer(numberOfPrecursors/10))) == 0)
        if(!is.na(progress))  if(progress)  incProgress(amount = 0.0, detail = paste("Precursor deisotoping ", precursorIdx, " / ", numberOfPrecursors, sep = "")) else print(paste("Precursor deisotoping ", precursorIdx, " / ", numberOfPrecursors, sep = ""))
      
      mzError <- dataFrame$"Average Mz"[[precursorIdx]] * mzDeviationInPPM_precursorDeisotoping / 1000000
      mzError <- max(mzError, mzDeviationAbsolute_precursorDeisotoping)
      
      ## RT difference <= maximumRtDifference
      validPrecursorsInRt <- abs(dataFrame$"Average Rt(min)"[[precursorIdx]] - dataFrame$"Average Rt(min)"[-precursorIdx]) <= maximumRtDifference
      
      ## MZ difference around 1.0033548378 (first isotope) or 1.0033548378 * 2 (second isotope)
      validPrecursorsInMz1 <- abs((dataFrame$"Average Mz"[[precursorIdx]] - distance13Cminus12C * 1) - dataFrame$"Average Mz"[-precursorIdx]) <= mzError
      validPrecursorsInMz2 <- abs((dataFrame$"Average Mz"[[precursorIdx]] - distance13Cminus12C * 2) - dataFrame$"Average Mz"[-precursorIdx]) <= mzError
      validPrecursorsInMz <- validPrecursorsInMz1 | validPrecursorsInMz2
      
      ## intensity gets smaller in the isotope spectrum
      if(numberOfDataColumns > 0){
        validPrecursorsInIntensity <- (medians[-precursorIdx] - medians[[precursorIdx]]) > 0
      } else {
        validPrecursorsInIntensity <- TRUE
      }

      if(any(validPrecursorsInRt & validPrecursorsInMz & validPrecursorsInIntensity))
        precursorsToRemove[[precursorIdx]] <- TRUE
    
    }
   
    ## remove isotopes
    dataFrame <- dataFrame[!precursorsToRemove, ]
    
    numberOfRemovedIsotopePeaks <- sum(precursorsToRemove)
    numberOfPrecursors <- nrow(dataFrame)
  }

  if(!is.na(progress))  if(progress)  incProgress(amount = 0, detail = paste("Boxing...", sep = "")) else print(paste("Boxing...", sep = ""))
  returnObj <- list()
  returnObj$dataFrame <- dataFrame
  returnObj$vals <- vals
  
  ## qfeatures
  returnObj$qfeatures <- qfeatures
  ## meta
  returnObj$oldFormat <- oldFormat
  returnObj$numberOfPrecursors <- numberOfPrecursors
  returnObj$dataColumnStartEndIndeces <- dataColumnStartEndIndeces
  returnObj$numberOfDataColumns <- numberOfDataColumns
  
  ## group anno
  returnObj$sampleClass          <- sampleClass
  returnObj$sampleType           <- sampleType
  returnObj$sampleInjectionOrder <- sampleInjectionOrder
  returnObj$batchID              <- batchID
  
  ## misc
  returnObj$numberOfPrecursorsPrior <- numberOfPrecursorsPrior
  returnObj$numberOfRemovedIsotopePeaks <- numberOfRemovedIsotopePeaks
  
  return (returnObj)
}

#' Title
#'
#' @param qfeatures 
#' @param siriusFile 
#' @param featureID 
#' @param siriusID 
#'
#' @return
#' @export
#'
#' @examples
addSiriusAnnotations <- function(qfeatures,
                                 siriusFile,
                                 rowData_col = "Alignment ID",
                                 sirius_col = "featureId") {
  #TODO: specify more parameters in read delim
  annotation <- read.delim(siriusFile)
 
  rowData <- rowData(qfeatures[[1]])
  
  # Print for debugging
  print(paste("Merging by:", sirius_col, "and", rowData_col))
  
  # Merge the data frames
  annotatedRowData <- S4Vectors::merge( rowData, annotation,
                             by.x = rowData_col, by.y = sirius_col,  all.x = TRUE)

  #TODO: ? check for duplicate columns ?
  annotation_cols <- colnames(annotation)[colnames(annotation) != rowData_col]
  rowData_cols <- colnames(rowData)
  
  for (col in colnames(annotatedRowData)) {
    if (col %in% annotation_cols) {
      attr(annotatedRowData[[col]], "source") <- "sirius"
    } else if (col %in% rowData_cols) {
      attr(annotatedRowData[[col]], "source") <- "data"
    }
  }
  
  # Set the annotation column
  attr(annotatedRowData, "annotation column") <- "ClassyFire.subclass"
  
  rowData(qfeatures[[1]]) <- annotatedRowData
  return(qfeatures)
}

================
File: R/Plots.R
================
#########################################################################################
## constants
minimumProportionOfLeafs <- 0.75
minimumProportionToShowFragment <- 0.5

### changing clusterNodePointSize0 from 2 to 1.8
clusterNodePointSize0 <- 1.7/3
clusterNodePointSize1 <- 3/3
clusterNodePointSize2 <- 4/3
clusterNodePointSize3 <- 5/3

ms2StickPointSizeInitial <- 1.
ms2StickPointSizeInitialSmall <- 2/3.
#ms2StickPointSizeEmph <- 1.5
#ms2StickPointSizeEmphSmall <- 3/3.
ms2StickPointSizeEmph <- 1
ms2StickPointSizeEmphSmall <- 2/3.
##changing the ms2StickPointSizeMaximumMultiplier <- 0.75 to 0.70
ms2StickPointSizeMaximumMultiplier <- 0.70
dendrogramClusterPointSizeMaximumMultiplier <- 0.75
dendrogramHeatmapLeftMargin <- 10#6#4

#########################################################################################
## plotting
colorLabels <- function(labels, clusterMembers, color, labelsToRemove = NULL, newLabels = NULL){
  colLab <- function(n) {
    if(is.leaf(n)) {
      a <- attributes(n)
      
      ## $label "New Hampshire"
      ## $members 1
      ## $height 0
      ## $leaf TRUE
      ## $class "dendrogram"
      
      nodeLabelHere <- a$label
      nodeIndexHere <- match(x = nodeLabelHere, table = labels)
      
      if(length(na.omit(match(x = nodeIndexHere, table = clusterMembers))) > 0)
        attr(n, "nodePar") <- c(a$nodePar, lab.col = color) # change the node color
      
      if(!is.null(labelsToRemove))
        if(length(na.omit(match(x = nodeLabelHere, table = labelsToRemove))) > 0)
          attr(n, "label") <- "" # clear label
      if(!is.null(newLabels))
        attr(n, "label") <- newLabels[[nodeIndexHere]] # new label
    }
    return(n)
  }
  
  return(colLab)
}


calcPlotDendrogram <- function(dataList, filter, clusterDataList, annoPresentAnnotationsList, annoPresentColorsList, distanceMeasure, selectionFragmentTreeNodeSet = NULL, selectionAnalysisTreeNodeSet = NULL, selectionSearchTreeNodeSet = NULL, showClusterLabels, hcaPrecursorLabels, xInterval = NULL){
  if(FALSE){
    dataList_ <<- dataList
    filter__ <<- filter
    clusterDataList_ <<- clusterDataList
    annoPresentAnnotationsList_ <<- annoPresentAnnotationsList
    annoPresentColorsList_ <<- annoPresentColorsList
    distanceMeasure_ <<- distanceMeasure
    selectionFragmentTreeNodeSet_ <<- selectionFragmentTreeNodeSet
    selectionAnalysisTreeNodeSet_ <<- selectionAnalysisTreeNodeSet
    selectionSearchTreeNodeSet_ <<- selectionSearchTreeNodeSet
    showClusterLabels_ <<- showClusterLabels
    hcaPrecursorLabels_ <<- hcaPrecursorLabels
    xInterval_ <<- xInterval
  }
  if(FALSE){
    dataList <<- dataList_
    filter <<- filter__
    clusterDataList <<- clusterDataList_
    annoPresentAnnotationsList <<- annoPresentAnnotationsList_
    annoPresentColorsList <<- annoPresentColorsList_
    distanceMeasure <<- distanceMeasure_
    selectionFragmentTreeNodeSet <<- selectionFragmentTreeNodeSet_
    selectionAnalysisTreeNodeSet <<- selectionAnalysisTreeNodeSet_
    selectionSearchTreeNodeSet <<- selectionSearchTreeNodeSet_
    showClusterLabels <<- showClusterLabels_
    hcaPrecursorLabels <<- hcaPrecursorLabels_
    xInterval <<- xInterval_
  }
  
  
  if(is.null(xInterval))
    xInterval <- c(1, clusterDataList$numberOfPrecursorsFiltered)
  
  ####################
  ## hcaPrecursorLabels
  precursorLabels <- NULL
  switch(as.character(hcaPrecursorLabels),
         "m/z / RT"={
           precursorLabels <- clusterDataList$cluster$labels
         },
         "Metabolite name"={
           precursorLabels <- dataList$dataFrameInfos[filter, "Metabolite name"]
           ### I am changing this
           ##maximumNumberOfCharacters <- 17
           maximumNumberOfCharacters <- 40
           tooLong <- nchar(x = precursorLabels) > maximumNumberOfCharacters
           precursorLabels[tooLong] <- paste(substring(text = precursorLabels[tooLong], first = 1, last = maximumNumberOfCharacters), rep(x = "...", times = sum(tooLong)), sep = "")
           ##precursorLabels[tooLong] <- paste(substring(text = precursorLabels[tooLong], first = 1, last = maximumNumberOfCharacters - 3), rep(x = "...", times = sum(tooLong)), sep = "")
         },
         "Metabolite family"={
           precursorLabels <- unlist(lapply(X = dataList$annoArrayOfLists[filter], FUN = function(x){
             if(length(x) == 0)
               return("Unknown")
             else
               return(x[[1]])
           }))
           
           ##maximumNumberOfCharacters <- 17
           maximumNumberOfCharacters <- 40
           tooLong <- nchar(x = precursorLabels) > maximumNumberOfCharacters
           precursorLabels[tooLong] <- paste(substring(text = precursorLabels[tooLong], first = 1, last = maximumNumberOfCharacters ), rep(x = "...", times = sum(tooLong)), sep = "")
           ##precursorLabels[tooLong] <- paste(substring(text = precursorLabels[tooLong], first = 1, last = maximumNumberOfCharacters - 3), rep(x = "...", times = sum(tooLong)), sep = "")
         },
         {## unknown state
           stop(paste("Unknown hcaPrecursorLabels value", hcaPrecursorLabels))
         }
  )## end switch
  
  precursorLabelsWithIdx <- paste(precursorLabels, "_", seq_len(length(precursorLabels)), sep = "")
  
  ## remove labels left of the y-axis
  rightMostInvisibleLabelIndex <- floor(xInterval[[1]] - (xInterval[[2]] - xInterval[[1]]) * 0.04)
  if(rightMostInvisibleLabelIndex > 0){
    #labelsToRemove <- precursorLabelsWithIdx[clusterDataList$cluster$order][1:rightMostInvisibleLabelIndex]
    #length(na.omit(match(x = precursorLabelsWithIdx, table = labelsToRemove))) > 0
    labelIndecesToRemove <- clusterDataList$cluster$order[seq_len(rightMostInvisibleLabelIndex)]
    precursorLabelsWithIdx[labelIndecesToRemove] <- ""
    precursorLabels[labelIndecesToRemove] <- ""
  }
  
  clusterDataList$cluster$labels <- precursorLabelsWithIdx
  
  ####################
  ## cluster
  par(mar=c(7.25,dendrogramHeatmapLeftMargin,2,0), mgp = c(3, 1, 0))  ## c(bottom, left, top, right)
  
  dend <- as.dendrogram(clusterDataList$cluster)
  
  ## color labels for search sub-roots
  if(!is.null(selectionSearchTreeNodeSet)){
    clusterMembers <- c(
      unlist(clusterDataList$innerNodeMembersTreeLeaves[selectionSearchTreeNodeSet[selectionSearchTreeNodeSet > 0]]), 
      -selectionSearchTreeNodeSet[selectionSearchTreeNodeSet < 0]
    )
    
    colLab <- colorLabels(precursorLabelsWithIdx, clusterMembers, 'red')
    dend <- dendrapply(dend, colLab)
  }
  ## color labels for fragment sub-roots
  if(!is.null(selectionFragmentTreeNodeSet)){
    clusterMembers <- c(
      unlist(clusterDataList$innerNodeMembersTreeLeaves[selectionFragmentTreeNodeSet[selectionFragmentTreeNodeSet > 0]]), 
      -selectionFragmentTreeNodeSet[selectionFragmentTreeNodeSet < 0]
    )
    
    colLab <- colorLabels(precursorLabelsWithIdx, clusterMembers, 'green')
    dend <- dendrapply(dend, colLab)
  }
  ## color labels for analysis sub-root
  if(!is.null(selectionAnalysisTreeNodeSet)){
    clusterMembers <- c(
      unlist(clusterDataList$innerNodeMembersTreeLeaves[selectionAnalysisTreeNodeSet[selectionAnalysisTreeNodeSet > 0]]), 
      -selectionAnalysisTreeNodeSet[selectionAnalysisTreeNodeSet < 0]
    )
    
    colLab <- colorLabels(precursorLabelsWithIdx, clusterMembers, 'blue')
    dend <- dendrapply(dend, colLab)
  }
  #if(!is.null(selectionAnalysisTreeNodeSet)){
  #  for(selectionAnalysisTreeNode in selectionAnalysisTreeNodeSet){
  #    clusterMembers <- NULL
  #    if(selectionAnalysisTreeNode > 0){
  #      clusterMembers <- c(clusterMembers, clusterDataList$innerNodeMembersTreeLeaves[[selectionAnalysisTreeNode]])
  #    } else {
  #      clusterMembers <- c(clusterMembers, -selectionAnalysisTreeNode)
  #    }
  #  }
  #  
  #  colLab <- colorLabels(precursorLabelsWithIdx, clusterMembers, 'blue')
  #  dend <- dendrapply(dend, colLab)
  #}
  
  ### remove labels left of the y-axis
  #rightMostInvisibleLabelIndex <- floor(xInterval[[1]] - (xInterval[[2]] - xInterval[[1]]) * 0.04)
  #if(rightMostInvisibleLabelIndex > 0){
  #  labelsToRemove <- precursorLabelsWithIdx[clusterDataList$cluster$order][1:rightMostInvisibleLabelIndex]
  #  
  #  colLab <- colorLabels(precursorLabelsWithIdx, NULL, NULL, labelsToRemove)
  #  dend <- dendrapply(dend, colLab)
  #}
  
  ## remove precursorLabel indeces
  colLab <- colorLabels(precursorLabelsWithIdx, NULL, NULL, NULL, precursorLabels)
  dend <- dendrapply(dend, colLab)
  
  ## plot
  plot(x = dend, xlab = "", ylab = distanceMeasure, main = "Hierarchical cluster dendrogram", sub = "", xlim = xInterval)
  
  ## color tree for annotations
  resultObjTree <- analyzeTreeFromRootForAnnotations(dataList, cluster = clusterDataList$cluster, filter)
  innerNodeFeaturesAnnotations <- resultObjTree$innerNodeFeaturesAnnotations
  
  rootIndex <- length(clusterDataList$cluster$height)
  setOfColorSets <- setOfAnnotationSetsToSetOfColorSets(dataList, innerNodeFeaturesAnnotations)
  innerNodeMembersTreeClusters <- clusterDataList$innerNodeMembersTreeClusters
  innerNodeMembersTreeLeaves <- clusterDataList$innerNodeMembersTreeLeaves
  
  poisX <- clusterDataList$poiCoordinatesX
  poisY <- clusterDataList$poiCoordinatesY
  numberOfPois <- clusterDataList$numberOfPois
  numberOfPoisDrawn <- sum(clusterDataList$drawPoi)
  
  poisX <- poisX[clusterDataList$drawPoi]
  poisY <- poisY[clusterDataList$drawPoi]
  
  a2r_counter <<- 0
  numberOfInnerNodes <- as.integer(numberOfPois / 2)
  resultObjAnno <- getPrecursorColors(dataList = dataList, precursorSet = filter)
  leafColors <- resultObjAnno$setOfColors
  
  innerNodeColors      <<- vector(length = numberOfInnerNodes)
  innerNodeAnnotations <<- vector(length = numberOfInnerNodes)
  colorSubTreeForAnnotations(cluster = clusterDataList$cluster, index = rootIndex, innerNodeAnnotations = innerNodeFeaturesAnnotations, setOfColorSets = setOfColorSets, parentIndex = NULL, parentAnnotation = "Unknown", parentColor = "black")
  
  ## coloring of nodes by annotation
  pointSizesAnno  <- rep(x = clusterNodePointSize0, times = numberOfPoisDrawn)
  pointColorsAnno <- unlist(c(innerNodeColors, leafColors)[clusterDataList$drawPoi])
  
  ## selections
  pointsAnalysis <- vector(mode = "logical", length = numberOfPois)
  if(!is.null(selectionAnalysisTreeNodeSet)){
    indeces <- NULL
    for(selectionAnalysisTreeNode in selectionAnalysisTreeNodeSet){
      if(selectionAnalysisTreeNode < 0) indeces <- c(indeces, numberOfInnerNodes + abs(selectionAnalysisTreeNode))  ## leaf
      else                              indeces <- c(indeces, unlist(c(innerNodeMembersTreeClusters[[selectionAnalysisTreeNode]], numberOfInnerNodes + innerNodeMembersTreeLeaves[[selectionAnalysisTreeNode]])))  ## inner node
    }
    pointsAnalysis[indeces] <- TRUE
  }
  pointsAnalysis <- pointsAnalysis[clusterDataList$drawPoi]
  
  pointsFragment <- vector(mode = "logical", length = numberOfPois)
  if(!is.null(selectionFragmentTreeNodeSet)){
    for(selectionFragmentTreeNode in selectionFragmentTreeNodeSet){
      if(selectionFragmentTreeNode < 0) idx <- numberOfInnerNodes + abs(selectionFragmentTreeNode)  ## leaf
      else                              idx <- unlist(c(innerNodeMembersTreeClusters[[selectionFragmentTreeNode]], numberOfInnerNodes + innerNodeMembersTreeLeaves[[selectionFragmentTreeNode]]))  ## inner node
      pointsFragment[idx] <- TRUE
    }
  }
  pointsFragment <- pointsFragment[clusterDataList$drawPoi]
  
  pointsSearch <- vector(mode = "logical", length = numberOfPois)
  if(!is.null(selectionSearchTreeNodeSet)){
    for(selectionSearchTreeNode in selectionSearchTreeNodeSet){
      if(selectionSearchTreeNode < 0) idx <- numberOfInnerNodes + abs(selectionSearchTreeNode)  ## leaf
      else                              idx <- unlist(c(innerNodeMembersTreeClusters[[selectionSearchTreeNode]], numberOfInnerNodes + innerNodeMembersTreeLeaves[[selectionSearchTreeNode]]))  ## inner node
      pointsSearch[idx] <- TRUE
    }
  }
  pointsSearch <- pointsSearch[clusterDataList$drawPoi]
  
  ## cluster discriminativity
  clusterDiscriminativity <- clusterDataList$clusterDiscriminativity[clusterDataList$drawPoi]
  
  ## calc points
  resultObjPoints <- generatePoints(
    poisX = poisX, poisY = poisY, 
    pointSizesAnno = pointSizesAnno, pointColorsAnno = pointColorsAnno, 
    pointsAnalysis = pointsAnalysis, pointsFragment = pointsFragment, pointsSearch = pointsSearch,
    pointSizeModifier = clusterDiscriminativity
  )
  pointSizes  <- resultObjPoints$pointSizes
  pointColors <- resultObjPoints$pointColors
  poisXpoints <- resultObjPoints$poisXpoints
  poisYpoints <- resultObjPoints$poisYpoints
  
  ## draw points
  points(x = poisXpoints, y = poisYpoints, col = pointColors, pch=19, cex=pointSizes)
  
  ## point labels
  if(showClusterLabels){
    poisXlabels <- poisX
    poisYlabels <- poisY
    
    plotRange <- par("usr") ## (x1, x2, y1, y2)
    yIntervalSize <- plotRange[[4]] - plotRange[[3]]
    poiLabelShift <- yIntervalSize / 50
    poiLabels <- clusterDataList$poiIntersectionSmooth[clusterDataList$drawPoi]
    #poiLabels <- clusterDataList$innerNodeFeaturesPresent[clusterDataList$drawPoi]
    graphics::text(x = poisXlabels - 0.0, y = poisYlabels + poiLabelShift, labels = poiLabels, pos = 4) ## pos: 1 below, 2 left, 3 above, 4 right
  }
  
  allAnnotations <- c(resultObjAnno$setOfAnnotations, innerNodeAnnotations)
  allColors      <- c(resultObjAnno$setOfColors, innerNodeColors)
  
  uniqueIndeces     <- which(!duplicated(allAnnotations))
  uniqueAnnotations <- allAnnotations[uniqueIndeces]
  uniqueColors      <- allColors[uniqueIndeces]
  
  resultList <- list(
    setOfAnnotations = uniqueAnnotations,
    setOfColors      = uniqueColors
  )
  
  return(resultList)
}


#' Title
#'
#' @param dataList 
#' @param filterObj 
#' @param clusterDataList 
#' @param distanceMeasure 
#' @param showClusterLabels 
#' @param hcaPrecursorLabels 
#' @param selectionFragmentTreeNodeSet 
#' @param selectionAnalysisTreeNodeSet 
#' @param selectionSearchTreeNodeSet 
#' @param selectedSelection 
#' @param heatmapContent 
#' @param heatmapOrdering 
#' @param heatmapProportion 
#'
#' @return
#' @importFrom grDevices colorRampPalette rainbow rgb
#' @export
#'
#' @examples
calcPlotDendrogram_plotly <- function(
  dataList, filterObj, clusterDataList, 
  #annoPresentAnnotationsList, annoPresentColorsList, 
  distanceMeasure, 
  showClusterLabels, hcaPrecursorLabels, 
  selectionFragmentTreeNodeSet = NULL, selectionAnalysisTreeNodeSet = NULL, selectionSearchTreeNodeSet = NULL, 
  selectedSelection, heatmapContent, heatmapOrdering, heatmapProportion)
  {
  
  if(FALSE){
    dataList_ <<- dataList
    filterObj_1 <<- filterObj
    clusterDataList_ <<- clusterDataList
    #annoPresentAnnotationsList_ <<- annoPresentAnnotationsList
    #annoPresentColorsList_ <<- annoPresentColorsList
    distanceMeasure_ <<- distanceMeasure
    showClusterLabels_ <<- showClusterLabels
    hcaPrecursorLabels_ <<- hcaPrecursorLabels
    selectionFragmentTreeNodeSet_ <<- selectionFragmentTreeNodeSet
    selectionAnalysisTreeNodeSet_ <<- selectionAnalysisTreeNodeSet
    selectionSearchTreeNodeSet_ <<- selectionSearchTreeNodeSet
    selectedSelection_ <<- selectedSelection
    heatmapContent_ <<- heatmapContent
    heatmapOrdering_ <<- heatmapOrdering
    heatmapProportion_ <<- heatmapProportion
    #xInterval_ <<- xInterval
    #stop()
  }
  if(FALSE){
    dataList <- dataList_
    filterObj <- filterObj_1
    clusterDataList <- clusterDataList_
    #annoPresentAnnotationsList <- annoPresentAnnotationsList_
    #annoPresentColorsList <- annoPresentColorsList_
    distanceMeasure <- distanceMeasure_
    showClusterLabels <- showClusterLabels_
    hcaPrecursorLabels <- hcaPrecursorLabels_
    selectionFragmentTreeNodeSet <- selectionFragmentTreeNodeSet_
    selectionAnalysisTreeNodeSet <- selectionAnalysisTreeNodeSet_
    selectionSearchTreeNodeSet <- selectionSearchTreeNodeSet_
    selectedSelection <- selectedSelection_
    heatmapContent <- heatmapContent_
    heatmapOrdering <- heatmapOrdering_
    heatmapProportion <- heatmapProportion_
    #xInterval <- xInterval_
  }
  
  #stop("hihi")
  
  
  #if(is.null(xInterval))
  #  xInterval <- c(1, clusterDataList$numberOfPrecursorsFiltered)
  
  ####################
  ## hcaPrecursorLabels
  precursorLabels <- NULL
  switch(as.character(hcaPrecursorLabels),
         "m/z / RT"={
           precursorLabels <- clusterDataList$cluster$labels
         },
         "Metabolite name"={
           precursorLabels <- dataList$dataFrameInfos[filterObj$filter, "Metabolite name"]
           ### changing from 17 to 30
           maximumNumberOfCharacters <- 30
           tooLong <- nchar(x = precursorLabels) > maximumNumberOfCharacters
           precursorLabels[tooLong] <- paste(substring(text = precursorLabels[tooLong], first = 1, last = maximumNumberOfCharacters - 3), rep(x = "...", times = sum(tooLong)), sep = "")
         },
         "Metabolite family"={
           precursorLabels <- unlist(lapply(X = dataList$annoArrayOfLists[filterObj$filter], FUN = function(x){
             if(length(x) == 0)
               return("Unknown")
             else
               return(x[[1]])
           }))
           ### changing from 17 to 30
           maximumNumberOfCharacters <- 30
           tooLong <- nchar(x = precursorLabels) > maximumNumberOfCharacters
           precursorLabels[tooLong] <- paste(substring(text = precursorLabels[tooLong], first = 1, last = maximumNumberOfCharacters - 3), rep(x = "...", times = sum(tooLong)), sep = "")
         },
         {## unknown state
           stop(paste("Unknown hcaPrecursorLabels value", hcaPrecursorLabels))
         }
  )## end switch
  
  if(FALSE){
  precursorLabelsWithIdx <- paste(precursorLabels, "_", seq_len(length(precursorLabels)), sep = "")
  
  ## remove labels left of the y-axis
  rightMostInvisibleLabelIndex <- 0#floor(xInterval[[1]] - (xInterval[[2]] - xInterval[[1]]) * 0.04)
  if(rightMostInvisibleLabelIndex > 0){
    #labelsToRemove <- precursorLabelsWithIdx[clusterDataList$cluster$order][1:rightMostInvisibleLabelIndex]
    #length(na.omit(match(x = precursorLabelsWithIdx, table = labelsToRemove))) > 0
    labelIndecesToRemove <- clusterDataList$cluster$order[seq_len(rightMostInvisibleLabelIndex)]
    precursorLabelsWithIdx[labelIndecesToRemove] <- ""
    precursorLabels[labelIndecesToRemove] <- ""
  }
  
  clusterDataList$cluster$labels <- precursorLabelsWithIdx
  }
  ## poi labels
  poiLabels <- as.character(clusterDataList$poiIntersectionSmooth[clusterDataList$drawPoi])
  poiHovers <- vector(mode = "character", length = length(poiLabels))
  
  poiLabelsHere <- clusterDataList$poiLabels[clusterDataList$drawPoi]
  
  for(poiIdx in seq_along(poiLabels)){
    nodeLabel <- poiLabelsHere[[poiIdx]]
    resultObj <- getMS2spectrum(dataList = dataList, clusterDataList = clusterDataList, treeLabel = nodeLabel)
    
    if(nodeLabel < 0){ ## leaf
      featureFamilies <- dataList$annoArrayOfLists[[resultObj$precursorSet]]
      featureFamilies <- ifelse(
        test = length(featureFamilies) == 0, 
        yes = "None", 
        no = paste(unlist(featureFamilies), collapse = ", ")
      )
      
      poiHovers[[poiIdx]] <- paste(
        "Precursor: ",           dataList$precursorLabels[[resultObj$precursorSet]],           "<br>", 
        "Number of fragments: ", length(resultObj$fragmentMasses),                             "<br>", 
        "Name: ",                dataList$dataFrameInfos[[resultObj$precursorSet, "Metabolite name"]], "<br>", 
        "Metabolite families: ", featureFamilies,
        sep = "")
    } else { ## cluster
      
      featureFamilies <- Reduce(intersect, dataList$annoArrayOfLists[resultObj$precursorSet])
      featureFamilies <- ifelse(
        test = length(featureFamilies) == 0, 
        yes = "None", 
        no = paste(unlist(featureFamilies), collapse = ", ")
      )
      
      poiHovers[[poiIdx]] <- paste(
        "Cluster discriminating power: ", resultObj$clusterDiscriminativity,      "<br>", 
        "Precursors in cluster: ",        resultObj$numberOfPrecursors,           "<br>", 
        "Frequent fragments: ",           length(resultObj$fragmentMasses),       "<br>", 
        "Characteristic fragments: ",     sum(resultObj$fragmentColor == "black"),"<br>",
        "Common metabolite families: ",   featureFamilies,
        sep = "")
    }
    
    ## cluster
    #$fragmentMasses
    #$fragmentAbundances
    #$fragmentColor
    #$fragmentDiscriminativity
    #$clusterDiscriminativity
    #$infoText
    #$precursorSet
    #$numberOfPrecursors
    
    ## leaf
    #$fragmentMasses
    #$fragmentAbundances
    #$fragmentColor
    #$fragmentDiscriminativity
    #$infoText
    #$landingPageUrl
    #$precursorSet
    #$numberOfPrecursors
  }
  
  
  ####################
  ## cluster
  
  if(FALSE){
    ### changing the left from 4 to 5
  par(mar=c(7.25,6.5,2,0), mgp = c(3, 1, 0))  ## c(bottom, left, top, right)
    print("entering this area ...plots.r ...line 478")
  
  dend <- as.dendrogram(clusterDataList$cluster)
  }
  
  leafLabelColors <- rep(x = "black", times = length(precursorLabels))
  
  ## color labels for search sub-roots
  if(!is.null(selectionSearchTreeNodeSet)){
    clusterMembers <- c(
      unlist(clusterDataList$innerNodeMembersTreeLeaves[selectionSearchTreeNodeSet[selectionSearchTreeNodeSet > 0]]), 
      -selectionSearchTreeNodeSet[selectionSearchTreeNodeSet < 0]
    )
    leafLabelColors[clusterMembers] <- 'red'
  }
  ## color labels for fragment sub-roots
  if(!is.null(selectionFragmentTreeNodeSet)){
    clusterMembers <- c(
      unlist(clusterDataList$innerNodeMembersTreeLeaves[selectionFragmentTreeNodeSet[selectionFragmentTreeNodeSet > 0]]), 
      -selectionFragmentTreeNodeSet[selectionFragmentTreeNodeSet < 0]
    )
    leafLabelColors[clusterMembers] <- 'green'
  }
  ## color labels for analysis sub-root
  if(!is.null(selectionAnalysisTreeNodeSet)){
    clusterMembers <- NULL
    for(selectionAnalysisTreeNode in selectionAnalysisTreeNodeSet){
      if(selectionAnalysisTreeNode > 0){
        clusterMembers <- c(clusterMembers, clusterDataList$innerNodeMembersTreeLeaves[[selectionAnalysisTreeNode]])
      } else {
        clusterMembers <- c(clusterMembers, -selectionAnalysisTreeNode)
      }
    }
    leafLabelColors[clusterMembers] <- 'blue'
  }
  
  ### remove labels left of the y-axis
  #rightMostInvisibleLabelIndex <- floor(xInterval[[1]] - (xInterval[[2]] - xInterval[[1]]) * 0.04)
  #if(rightMostInvisibleLabelIndex > 0){
  #  labelsToRemove <- precursorLabelsWithIdx[clusterDataList$cluster$order][1:rightMostInvisibleLabelIndex]
  #  
  #  colLab <- colorLabels(precursorLabelsWithIdx, NULL, NULL, labelsToRemove)
  #  dend <- dendrapply(dend, colLab)
  #}
  
  ## remove precursorLabel indeces
  #colLab <- colorLabels(precursorLabelsWithIdx, NULL, NULL, NULL, precursorLabels)
  #dend <- dendrapply(dend, colLab)
  
  ## color tree for annotations
  resultObjTree <- analyzeTreeFromRootForAnnotations(dataList, cluster = clusterDataList$cluster, filterObj$filter)
  innerNodeFeaturesAnnotations <- resultObjTree$innerNodeFeaturesAnnotations
  
  rootIndex <- length(clusterDataList$cluster$height)
  setOfColorSets <- setOfAnnotationSetsToSetOfColorSets(dataList, innerNodeFeaturesAnnotations)
  innerNodeMembersTreeClusters <- clusterDataList$innerNodeMembersTreeClusters
  innerNodeMembersTreeLeaves <- clusterDataList$innerNodeMembersTreeLeaves
  
  poisX <- clusterDataList$poiCoordinatesX
  poisY <- clusterDataList$poiCoordinatesY
  numberOfPois <- clusterDataList$numberOfPois
  numberOfPoisDrawn <- sum(clusterDataList$drawPoi)
  
  poisX <- poisX[clusterDataList$drawPoi]
  poisY <- poisY[clusterDataList$drawPoi]
  
  a2r_counter <<- 0
  numberOfInnerNodes <- as.integer(numberOfPois / 2)
  resultObjAnno <- getPrecursorColors(dataList = dataList, precursorSet = filterObj$filter)
  leafColors <- resultObjAnno$setOfColors
  
  innerNodeColors      <<- vector(length = numberOfInnerNodes)
  innerNodeAnnotations <<- vector(length = numberOfInnerNodes)
  segmentListAnno <- colorSubTreeForAnnotations(cluster = clusterDataList$cluster, index = rootIndex, innerNodeAnnotations = innerNodeFeaturesAnnotations, setOfColorSets = setOfColorSets, parentIndex = NULL, parentAnnotation = "Unknown", parentColor = "black")
  
  ## coloring of nodes by annotation
  numberOfPoisDrawn <- sum(clusterDataList$drawPoi)
  pointSizesAnno  <- rep(x = clusterNodePointSize0, times = numberOfPoisDrawn)
  pointColorsAnno <- unlist(c(innerNodeColors, leafColors)[clusterDataList$drawPoi])
  
  ############################
  ## dendrogram selections
  pointsAnalysis <- vector(mode = "logical", length = numberOfPois)
  if(!is.null(selectionAnalysisTreeNodeSet)){
    indeces <- NULL
    for(selectionAnalysisTreeNode in selectionAnalysisTreeNodeSet){
      if(selectionAnalysisTreeNode < 0) indeces <- c(indeces, numberOfInnerNodes + abs(selectionAnalysisTreeNode))  ## leaf
      else                              indeces <- c(indeces, unlist(c(innerNodeMembersTreeClusters[[selectionAnalysisTreeNode]], numberOfInnerNodes + innerNodeMembersTreeLeaves[[selectionAnalysisTreeNode]])))  ## inner node
    }
    pointsAnalysis[indeces] <- TRUE
  }
  pointsAnalysis <- pointsAnalysis[clusterDataList$drawPoi]
  
  pointsFragment <- vector(mode = "logical", length = numberOfPois)
  if(!is.null(selectionFragmentTreeNodeSet)){
    for(selectionFragmentTreeNode in selectionFragmentTreeNodeSet){
      if(selectionFragmentTreeNode < 0) idx <- numberOfInnerNodes + abs(selectionFragmentTreeNode)  ## leaf
      else                              idx <- unlist(c(innerNodeMembersTreeClusters[[selectionFragmentTreeNode]], numberOfInnerNodes + innerNodeMembersTreeLeaves[[selectionFragmentTreeNode]]))  ## inner node
      pointsFragment[idx] <- TRUE
    }
  }
  pointsFragment <- pointsFragment[clusterDataList$drawPoi]
  
  pointsSearch <- vector(mode = "logical", length = numberOfPois)
  if(!is.null(selectionSearchTreeNodeSet)){
    for(selectionSearchTreeNode in selectionSearchTreeNodeSet){
      if(selectionSearchTreeNode < 0) idx <- numberOfInnerNodes + abs(selectionSearchTreeNode)  ## leaf
      else                              idx <- unlist(c(innerNodeMembersTreeClusters[[selectionSearchTreeNode]], numberOfInnerNodes + innerNodeMembersTreeLeaves[[selectionSearchTreeNode]]))  ## inner node
      pointsSearch[idx] <- TRUE
    }
  }
  pointsSearch <- pointsSearch[clusterDataList$drawPoi]
  
  ## cluster discriminativity
  clusterDiscriminativity <- clusterDataList$clusterDiscriminativity[clusterDataList$drawPoi]
  
  
  ## calc points
  resultObjPoints <- generatePoints(
    poisX = poisX, poisY = poisY, 
    pointSizesAnno = pointSizesAnno, pointColorsAnno = pointColorsAnno, 
    pointsAnalysis = pointsAnalysis, pointsFragment = pointsFragment, pointsSearch = pointsSearch,
    pointSizeModifier = clusterDiscriminativity
  )
  pointSizes  <- resultObjPoints$pointSizes
  pointColors <- resultObjPoints$pointColors
  poisXpoints <- resultObjPoints$poisXpoints
  poisYpoints <- resultObjPoints$poisYpoints
  
  ###########################################################
  ## heatmap
  
  ## heatmap data
  grouXXXps <- dataList$grouXXXps
  print(grouXXXps)
  print("enetring this area ...plots.r..line 611")
  switch(heatmapContent,
         "Log-fold-change"={## log-fold-change
           columnsOfInterest <- c(
             dataList$dataMeanColumnNameFunctionFromName(filterObj$grouXXXps[[1]]), 
             dataList$dataMeanColumnNameFunctionFromName(filterObj$grouXXXps[[2]]), 
             dataList$lfcColumnNameFunctionFromName(filterObj$grouXXXps[[1]], filterObj$grouXXXps[[2]])
           )
           columnsOfInterestAbs <- columnsOfInterest[1:2]
           columnsOfInterestLFC <- columnsOfInterest[3]
           labels = c(filterObj$grouXXXps[[1]], filterObj$grouXXXps[[2]], "LFC")
           labelsAbs <- labels[1:2]
           labelsLFC <- labels[3]
         },
         "Abundance by group"={## grouXXXps
           columnsOfInterest <- unlist(lapply(X = grouXXXps, FUN = function(x){
             dataList$dataMeanColumnNameFunctionFromName(x)
           }))
           columnsOfInterest <- rev(columnsOfInterest) ## plot is bottom to top
           columnsOfInterestAbs <- columnsOfInterest
           columnsOfInterestLFC <- NULL
           labels <- grouXXXps
           labelsAbs <- labels[1:2]
           labelsLFC <- NULL
         },
         "Abundance by sample"={## samples
           columnsOfInterest <- dataList$dataColumnsNameFunctionFromGroupNames(grouXXXps = grouXXXps, sampleNamesToExclude = dataList$excludedSamples(dataList$groupSampleDataFrame))
           columnsOfInterest <- dataList$orderColumnNames(groupSampleDataFrame = dataList$groupSampleDataFrame, columnNames = columnsOfInterest)
           columnsOfInterest <- rev(columnsOfInterest) ## plot is bottom to top
           columnsOfInterestAbs <- columnsOfInterest
           print("this is entering the line..plots.r ...638")
           print(columnsOfInterest)
           columnsOfInterestLFC <- NULL
           labels <- columnsOfInterest
           print("this is entering the line ...plots.r...643")
           print(labels)
           labelsAbs <- labels[1:2]
           labelsLFC <- NULL
         },
         {## unknown state
           stop(paste("Unknown heatmapContent value", heatmapContent))
         }
  )## end switch
  numberOfGroups <- length(columnsOfInterest)
  
  ## heatmap ordering
  switch(heatmapOrdering,
         "Specified order"={## no clustering
           doCalculateCluster <- FALSE
         },
         "MS1 clustering"={## do clustering
           if(heatmapContent == "Log-fold-change"){
             doCalculateCluster <- FALSE
           } else {
             doCalculateCluster <- TRUE
           }
         },
         {## unknown state
           stop(paste("Unknown heatmapOrdering value", heatmapOrdering))
         }
  )## end switch
  
  ## selections and selection colors
  #selectedTreeNodeSet <- NULL
  #frameColor <- NULL
  if(!is.null(selectedSelection)){
    analysisSelection <- {
      selectedTreeNodeSet <- selectionAnalysisTreeNodeSet
      frameColor <- "blue"
    }
    fragmentSelection <- {
      selectedTreeNodeSet <- selectionFragmentTreeNodeSet
      frameColor <- "green"
    }
    searchSelection <- {
      selectedTreeNodeSet <- selectionSearchTreeNodeSet
      frameColor <- "red"
    }
    switch(selectedSelection,
           "Analysis_HCA" = analysisSelection,
           "Analysis_PCA" = analysisSelection,
           "Fragment_HCA" = fragmentSelection,
           "Fragment_PCA" = fragmentSelection,
           "Search_HCA"   = searchSelection,
           "Search_PCA"   = searchSelection,
           {## unknown state
             stop(paste("Unknown selectedSelection value", selectedSelection))
           }
    )## end switch
  }
  ## in case of tree selections compute leaf intervals
  #if(!is.null(selectedTreeNodeSet)){
    clusterMemberList <- lapply(X = selectedTreeNodeSet, FUN = function(x){
      ifelse(test = x < 0, yes = -x, no = clusterDataList$innerNodeMembersTreeLeaves[x])[[1]]
    })
    positionsList <- lapply(X = clusterMemberList, FUN = function(x){
      match(x = x, table = clusterDataList$cluster$order)
    })
    intervals <- lapply(X = clusterMemberList, FUN = function(x){
      positions <- match(x = x, table = clusterDataList$cluster$order)
      c(min(positions), max(positions))
    })
    intervalMatrix <- as.matrix(as.data.frame(intervals))
    
    ## merge adjacent intervals TODO
    #intervalMatrix <- matrix(data=unlist(intervals), nrow=2,ncol=length(intervals))
    #if(ncol(intervalMatrix) > 1){
    #  intervalMatrix <- intervalMatrix[, order(intervalMatrix[1, ])]
    #  
    #  sapply(X = seq_len(ncol(intervalMatrix) - 1), FUN = function(x){
    #    intervalMatrix[2, x] + 1 == intervalMatrix[1, x+1]
    #  })
    #}
    
  #}
 
     
  ## MS1 clustering and colors
  if(doCalculateCluster){
    data_s_p <- t(as.matrix(as.data.frame(lapply(X = columnsOfInterest, FUN = function(x){
      values <- dataList$dataFrameMeasurements[filterObj$filter, x][clusterDataList$cluster$order]
      if(is.null(selectedTreeNodeSet))
        return(values)
      
      unlist(apply(X = intervalMatrix, MARGIN = 2, FUN = function(x){
        values[seq(from=x[[1]], to = x[[2]], by = 1)]
      }))
    }))))
    
    dist <- dist(data_s_p)
    cluster <- hclust(d = dist, method = "ward.D")
    
    ## optimal leaf ordering
    if(numberOfGroups > 2){
      opt <- order.optimal(dist = dist, merge = cluster$merge)
      cluster$merge <- opt$merge
      cluster$order <- opt$order
    }
    
    labels <- labels[cluster$order]
    columnsOfInterest <- columnsOfInterest[cluster$order]
    
    colors <- lapply(X = columnsOfInterest[cluster$order], FUN = function(x){
      dataList$colorMatrixDataFrame[filterObj$filter, x][clusterDataList$cluster$order]
    })
    values <- lapply(X = columnsOfInterest[cluster$order], FUN = function(x){
      dataList$dataFrameMeasurements[filterObj$filter, x][clusterDataList$cluster$order]
    })
    valuesAbs <- values
    valuesLFC <- NULL
  } else {
    #colors <- lapply(X = columnsOfInterest, FUN = function(x){
    #  dataList$colorMatrixDataFrame[filterObj$filter, x][clusterDataList$cluster$order]
    #})
    colors <- sapply(columnsOfInterest,FUN = function(x){
      dataList$colorMatrixDataFrame[filterObj$filter, x][clusterDataList$cluster$order]
    },simplify = FALSE,USE.NAMES = TRUE)
    values <- lapply(X = columnsOfInterest, FUN = function(x){
      dataList$dataFrameMeasurements[filterObj$filter, x][clusterDataList$cluster$order]
    })
    valuesAbs <- lapply(X = columnsOfInterestAbs, FUN = function(x){
      dataList$dataFrameMeasurements[filterObj$filter, x][clusterDataList$cluster$order]
    })
    valuesLFC <- lapply(X = columnsOfInterestLFC, FUN = function(x){
      dataList$dataFrameMeasurements[filterObj$filter, x][clusterDataList$cluster$order]
    })
  }
  
  ## assemble heatmap values and colors
  numberOfGroupsAbs <- length(valuesAbs)
  numberOfGroupsLFC <- length(valuesLFC)
  
  matrixAbs <- t(matrix(data = unlist(valuesAbs), nrow = clusterDataList$numberOfPrecursorsFiltered, ncol = numberOfGroupsAbs))
  matrixAbsLog <- unlist(log10(matrixAbs))
  matrixAbsLog[is.infinite(matrixAbsLog)] <- 0
  
  #paletteAbs <- colorRampPalette(rainbow(18)[10:1])
  paletteAbs <- rainbow(18)[10:1]
  paletteLFC <- c('blue', 'white', 'red')
  
  if(numberOfGroupsLFC > 0){
    matrixLFC <- t(matrix(data = unlist(valuesLFC), nrow = clusterDataList$numberOfPrecursorsFiltered, ncol = numberOfGroupsLFC))
    matrixLFC[is.infinite(matrixLFC)] <- 0
  } else {
    matrixLFC <- matrix(nrow = 0, ncol = clusterDataList$numberOfPrecursorsFiltered)
  }
  
  if(FALSE){
  quantiles <- c(-dataList$logFoldChangeMax, 0, dataList$logFoldChangeMax, dataList$logFoldChangeMax*1.01, 10^(seq(from=dataList$logAbsMax/10, to=dataList$logAbsMax, length.out=9)))
  quantiles <- approx(x = quantiles, n = 10000)$y
  colors    <- c('blue', 'white', 'red', rainbow(18)[10:1])
  #colors    <- c('blue', 'white', 'red', rainbow(50)[17:8])
  colors    <- colorRampPalette(colors)(10000)
  
  matrixAbsTmp <- matrixAbs
  matrixAbsTmp[matrixAbsTmp<=dataList$logFoldChangeMax] <- dataList$logFoldChangeMax*1.01
  valueMatrix <- rbind(matrixLFC, matrixAbsTmp)
  valueMatrix <- matrix(data = #quantiles[
    cut(as.vector(valueMatrix), breaks = quantiles, right = TRUE, labels = FALSE)
    #]
  , nrow=numberOfGroups, ncol=clusterDataList$numberOfPrecursorsFiltered)
  #valueMatrix <- valueMatrix[rev(seq_len(nrow(valueMatrix))), ]
  
  m <- rbind(matrixLFC, matrixAbsTmp)
  m <- valueMatrix
  colors2    <- c('blue', 'white', 'red', rainbow(18)[10:1])
  vals <- unlist(m)
  o <- order(vals, decreasing = FALSE)
  cols <- scales::col_numeric(palette = colors2, domain = c(-dataList$logFoldChangeMax,10^dataList$logAbsMax))(vals)
  colz <- setNames(object = data.frame(vals[o], cols[o]), nm = NULL)
  
  
  colors    <- c('blue', 'white', 'red', rainbow(18)[10:1])
  
  minLFCnew <- 3/13*dataList$logAbsMax
  matrixLFCTmp <- (matrixLFC - dataList$logFoldChangeMax) / (2 * dataList$logFoldChangeMax)  * minLFCnew
  valueMatrix <- rbind(matrixLFCTmp, matrixAbsLog)
  #valueMatrix <- valueMatrix + minLFCnew
  }
  
  #################################
  ## dendrogram elements
  #subDivide <- function(items){
  #  ## add NA at every fourth position
  #  chunks <- split(items, cut(seq_along(items), ceiling(length(items) / 3), labels = FALSE))
  #  chunks <- lapply(X = chunks, FUN = function(x){
  #    c(x, NA)
  #  })
  #  unlist(chunks)
  #}
  
  #a2r_counter <<- 0
  #segmentListDend <- drawDendrogram(cluster = clusterDataList$cluster, index = rootIndex)
  #segmentListDend$x0 <- subDivide(segmentListDend$x0)
  #segmentListDend$x1 <- subDivide(segmentListDend$x1)
  #segmentListDend$y0 <- subDivide(segmentListDend$y0)
  #segmentListDend$y1 <- subDivide(segmentListDend$y1)
  
  a2r_counter <<- 0
  segmentListAnno <- colorSubTreeForAnnotations2(cluster = clusterDataList$cluster, index = rootIndex, dataList = dataList, filter = filterObj$filter)
  
  #segmentListAnno$x0 <- subDivide(segmentListAnno$x0)
  #segmentListAnno$x1 <- subDivide(segmentListAnno$x1)
  #segmentListAnno$y0 <- subDivide(segmentListAnno$y0)
  #segmentListAnno$y1 <- subDivide(segmentListAnno$y1)
  
  presentColors <- unique(segmentListAnno$col)
  #if("black" %in% presentColors)
  #  presentColors <- presentColors[-which(presentColors == "black")]
  
  ## list of lists
  annoByAnno <- sapply(X = presentColors, simplify = FALSE, FUN = function(color){
    indeces <- which(segmentListAnno$col == color)
    indeces <- unlist(sapply(X = indeces, simplify = FALSE, FUN = function(index){
      ((index - 1) * 3 + 1) : ((index - 1) * 3 + 3)
    }))
    list(
      x0=segmentListAnno$x0[indeces], 
      x1=segmentListAnno$x1[indeces], 
      y0=segmentListAnno$y0[indeces], 
      y1=segmentListAnno$y1[indeces]
    )
  })
  
  ##################################################################################
  ## plot
  curveNumberToCurveName <- data.frame(matrix(nrow = 0, ncol = 2))
  colnames(curveNumberToCurveName) <- c("curveNumber", "name")
  curveNumber <- -1 ## first curveNumber is 0
  
  ## create plot
  ## https://stackoverflow.com/questions/45861236/segments-prevent-the-display-of-tooltips-of-markers-in-r-plotly
  
  hoverlabel <- list(
    bgcolor = "grey",
    bordercolor = "black"
  )
  
  #p <- plot_ly(type = 'scatter', mode = 'lines')
  p <- plot_ly(source = "dendLabelsHeatmap")
  ## heatmap
  if(FALSE && numberOfGroupsLFC > 0){
    p <- add_heatmap(p, x = xCoordinates, y = labelsLFC, 
                     z = matrixLFC, name = 'heatmap_lfc', #type = 'heatmap', mode = NULL, 
                     #colors = palette(50),
                     colors = paletteLFC, zauto = FALSE, zmin = -dataList$logFoldChangeMax, zmax = dataList$logFoldChangeMax,
                     xaxis="x", yaxis="y4", showlegend = FALSE, showscale=FALSE
                     
    )
    curveNumberToCurveName[nrow(curveNumberToCurveName)+1, ] <- c(curveNumber <- curveNumber+1, "heatmap_lfc")
  }
  
  matrixForHeatmap <- rbind(
    matrixAbsLog,
    matrix(data=rep(x = 0, times = numberOfGroupsLFC * clusterDataList$numberOfPrecursorsFiltered), nrow=numberOfGroupsLFC, ncol=clusterDataList$numberOfPrecursorsFiltered)
  )
  p <- add_heatmap(p, x = xCoordinates, y = labels, 
                   z = matrixForHeatmap, name = 'heatmap_abs', #type = 'heatmap', mode = NULL, 
                   #colors = palette(50),
                   colors = paletteAbs, zauto = FALSE, zmin = 0, zmax = dataList$logAbsMax,
                   xaxis="x", yaxis="y3", showlegend = FALSE, showscale=FALSE
  )
  curveNumberToCurveName[nrow(curveNumberToCurveName)+1, ] <- c(curveNumber <- curveNumber+1, "heatmap_abs")
  if(FALSE){
    p <- add_heatmap(p, x = xCoordinates, y = labelsAbs, 
                     z = matrixAbs, name = 'abs', #type = 'heatmap', mode = NULL, 
                     #colors = palette(50),
                     colors = paletteAbs, zauto = FALSE, zmin = 0, zmax = 10^dataList$logAbsMax,
                     xaxis="x", yaxis="y3", showlegend = FALSE, showscale=FALSE
    )
    
    #p <- add_heatmap(p, x = xCoordinates, y = labels, 
    #                 z = valueMatrix, name = 'abs', #type = 'heatmap', mode = NULL, 
    #                 #colors = palette(50),
    #                 colors = colors, 
    #                 zauto = FALSE, zmin = 1, zmax = 10000,
    #                 #zauto = FALSE, zmin = -dataList$logFoldChangeMax, zmax = 10^dataList$logAbsMax,
    #                 xaxis="x", yaxis="y3", showlegend = FALSE#, showscale=FALSE
    #)
    p <- add_heatmap(p, x = xCoordinates, y = labels, 
                     z = m, name = 'abs', #type = 'heatmap', mode = NULL, 
                     #colors = palette(50),
                     color=colors,
                     #colorscale = colz, 
                     #zauto = FALSE, zmin = 1, zmax = 10000,
                     #zauto = FALSE, zmin = -dataList$logFoldChangeMax, zmax = 10^dataList$logAbsMax,
                     xaxis="x", yaxis="y3", showlegend = FALSE#, showscale=FALSE
    )
    #p <- add_heatmap(p, data=data.frame(x=xCoordinates, y=rep("bla",times=ncol(valueMatrix)),z=valueMatrix[1,],col=colors[valueMatrix[1,]], stringsAsFactors = F), x = ~x, y = ~y, 
    #                 z = ~z, name = 'abs', #type = 'heatmap', mode = NULL, 
    #                 #colors = palette(50),
    #                 colors = ~col, #zauto = FALSE, zmin = -dataList$logFoldChangeMax, zmax = 10^dataList$logAbsMax,
    #                 xaxis="x", yaxis="y3", showlegend = FALSE#, showscale=FALSE
    #)
    
    add_heatmap(p, x = xCoordinates, y = labels, 
                z = valueMatrix, name = 'abs', #type = 'heatmap', mode = NULL, 
                #colors = palette(50),
                colors = colors, #zauto = FALSE, zmin = -minLFCnew, zmax = 10^dataList$logAbsMax,
                xaxis="x", yaxis="y3", showlegend = FALSE#, showscale=FALSE
    )
  }
  
  
  ## draw dendrogram
  #print(paste("1", length(xDend), length(yDend), min(xDend, na.rm = TRUE), max(xDend, na.rm = TRUE)))
  #p <- add_trace(p, x = ~xDend, y = ~yDend, name = 'dend', mode = 'lines', 
  #               hoverinfo="none", line = list(color = "black")
  #)
  ## color dendrogram
  for(colorIdx in seq_along(annoByAnno)){
    curveName <- paste('dendAnno', presentColors[[colorIdx]], colorIdx, sep = "_")
    p <- add_segments(p, x = annoByAnno[[colorIdx]]$x0, y = annoByAnno[[colorIdx]]$y0, xend = annoByAnno[[colorIdx]]$x1, yend = annoByAnno[[colorIdx]]$y1,
                      name = curveName, 
                      mode = 'lines',
                      #mode = 'lines+markers',
                      #hoverinfo="skip", #"none", 
                      hoverinfo="text", hovertext=rep(x = "error", times = length(annoByAnno[[colorIdx]]$x0)), 
                      #hoverinfo="text", hovertext=seq_along(annoByAnno[[colorIdx]]$x0), 
                      #hoverinfo="text", hovertext=tooltip2, 
                      line = list(
                        color = presentColors[[colorIdx]]#,
                        
                        ## TODO for selections
                        #dash = "dash", ## ("solid", "dot", "dash", "longdash", "dashdot", or "longdashdot")
                        
                        #layer="below traces"
                        #hovermode = FALSE,
                        #layer="below"
                      ),
                      #captureevents = FALSE,
                      hoveron="fills",
                      xaxis="x", yaxis="y", showlegend = FALSE
    )
    curveNumberToCurveName[nrow(curveNumberToCurveName)+1, ] <- c(curveNumber <- curveNumber+1, curveName)
  }
  ## node labels
  if(FALSE){
  #print(paste("3", length(poisX), length(poisY), length(poiLabels), min(poisX), max(poisX)))
  xOffset <- 0.3#(xInterval[[2]] - xInterval[[1]] + 1) / 50
  yOffset <- max(clusterDataList$cluster$height) / 30
  p <- add_text(p, x = poisX + xOffset, y = poisY + yOffset, name = 'node labels', mode = 'text', 
                 hoverinfo="none", text=poiLabels, textposition="top right",#"middle center",#"middle right" #
                 xaxis="x", yaxis="y"
  )
  curveNumberToCurveName[nrow(curveNumberToCurveName)+1, ] <- c(curveNumber <- curveNumber+1, 'node labels')
  }
  
  ## nodes
  poiLabelsPoints <- c(rep(x = "", times = length(poisXpoints) - length(poiLabels)), poiHovers)
  #print(paste("4", length(poisXpoints), length(poisYpoints), length(pointColors), length(pointSizes), min(poisXpoints), max(poisXpoints)))
  p <- add_markers(p, x = poisXpoints, y = poisYpoints, name = 'nodes', #mode = 'markers', 
                 marker=list(
                   size = pointSizes*7., 
                   #sizeref = 1.,
                   color = pointColors,
                   opacity=1#,
                   #layer="above traces"
                   #layer="above"
                 ),
                 hoverinfo="text", hovertext=poiLabelsPoints, hoveron="points+fills", #, hoverlabel = list(bordercolor="blue")
                 hoverlabel = hoverlabel,
                 xaxis="x", yaxis="y", showlegend = FALSE
  )
  curveNumberToCurveName[nrow(curveNumberToCurveName)+1, ] <- c(curveNumber <- curveNumber+1, 'nodes')
  
  ## leaf labels
  if(FALSE){
  ## TODO repair
  xCoordinates <- seq_len(clusterDataList$numberOfPrecursorsFiltered)
  uniqueLeafLabelColors <- unique(leafLabelColors)
  leafLabelsList <- sapply(X = uniqueLeafLabelColors, FUN = function(x){
    which(leafLabelColors == x)
  })
  for(idx in seq_along(leafLabelsList)){
    leafLabelIndeces <- leafLabelsList[[idx]]
    leafLabelsName <- paste('leaf_labels', uniqueLeafLabelColors[[idx]], idx, sep = "_")
    p <- add_annotations(p, x = xCoordinates[leafLabelIndeces], y = 0, name = leafLabelsName, text = precursorLabels[leafLabelIndeces],
                    showarrow = FALSE, textangle = 270, font = list(color = uniqueLeafLabelColors[[idx]]),#bgcolor = uniqueLeafLabelColors[[idx]], 
                    xref = "x", yref = "y2"
    )
    curveNumberToCurveName[nrow(curveNumberToCurveName)+1, ] <- c(curveNumber <- curveNumber+1, leafLabelsName)
  }
  }
  
  ## plot config
  ## h 2.1 / l 3.4 / d 11
  ## 25 .. 25 .. 11 .. 11
  ## 1  ..  3 .. 10 ..  n
  labelsToDendrogramProportion <- 0.25
  dendrogramLabelsProportion <- 1 - heatmapProportion
  labelsProportion <- dendrogramLabelsProportion * labelsToDendrogramProportion
  dendrogramProportion <- dendrogramLabelsProportion * (1-labelsToDendrogramProportion)
  
  if(numberOfGroupsLFC > 0){
    heatmapProportionLFC <- heatmapProportion * numberOfGroupsLFC / numberOfGroups
    heatmapProportionAbs <- heatmapProportion - heatmapProportionLFC
  } else {
    heatmapProportionLFC <- 0
    heatmapProportionAbs <- heatmapProportion
  }
  
  p <- config(p, displayModeBar = FALSE)
  p <- plotly::layout(p=p,                        # all of layout's properties: /r/reference/#layout
              #showlegend = FALSE,
              #hovermode = F,#"closest",
              title = "Hierarchical cluster dendrogram",
              xaxis = list(
                visible = FALSE
                #scaleanchor = "TODO",
                #domain = xInterval
              ),
              yaxis = list(
                title = distanceMeasure,
                showgrid = FALSE,
                zeroline=FALSE,
                type = "linear",
                domain = c(heatmapProportion + labelsProportion, 1),
                rangemode="nonnegative"
              ),
              yaxis2 = list(
                #title = "TODO",
                #fixedrange = TRUE,
                showgrid = FALSE,
                zeroline=FALSE,
                type = "category",
                domain = c(heatmapProportion, heatmapProportion + labelsProportion)
              ),
              yaxis3 = list(
                title = "TODO",
                #fixedrange = TRUE,
                showgrid = FALSE,
                zeroline=FALSE,
                type = "category",
                domain = c(0, heatmapProportion)
              ),
              #yaxis4 = list(
              #  title = "TODO2",
              #  #fixedrange = TRUE,
              #  showgrid = FALSE,
              #  zeroline=FALSE,
              #  type = "category",
              #  domain = c(heatmapProportionAbs, heatmapProportion)
              #),
              ## heatmap selections
              #if(!is.null(selectedTreeNodeSet))
              #  apply(X = intervalMatrix, MARGIN = 2, FUN = function(x){
              #    rect(xleft = x[[1]] - 0.5, xright = x[[2]] + 0.5, ybottom = 0, ytop = numberOfGroups, border = frameColor, lwd = 2)
              #  })
              shapes = #list(
                c(
                ## LFC rects?
                {if(numberOfGroupsLFC > 0){
                  colorsHere <- colors[[columnsOfInterestLFC]]
                  lapply(X = seq_along(colorsHere), FUN = function(x){
                    list(type = "rect",
                         fillcolor = colorsHere[[x]], line = list(color="none", width=0), opacity = 1.,
                         x0 = x-0.5, x1 = x+0.5, xref = "x",
                         y0 = -0.5 + numberOfGroupsAbs, y1 = 0.5 + numberOfGroupsAbs, yref = "y3"
                    )
                  })
                  } else NULL
                },
                ## selections in the heatmap
                unname(apply(X = intervalMatrix, MARGIN = 2, FUN = function(x){
                  if(length(x) == 0)
                    return(list())
                  else
                    list(type = "rect",
                         fillcolor = "none", line = list(color=frameColor, width=2), opacity = 1.,
                         x0 = x[[1]]-0.5, x1 = x[[2]]+0.5, xref = "x",
                         y0 = -0.5, y1 = numberOfGroups - 0.5, yref = "y3"
                    )
                }))
                )
                #list(type = "rect",
                #     fillcolor = "none", line = list(color=frameColor, width=2), opacity = 1.,
                #     x0 = 3, x1 = 5, xref = "x",
                #     y0 = -0.5, y1 = numberOfGroupsAbs - 0.5, yref = "y2"
                #)
              #)
              #,
              #annotations = list(
              #  x = xCoordinates,
              #  y = m$mpg,
              #  text = rownames(m),
              #  xref = "x",
              #  yref = "y",
              #  showarrow = TRUE,
              #  arrowhead = 7,
              #  ax = 20,
              #  ay = -40
              #)
  )
  
  resultObj <- list()
  resultObj$curveNumberToCurveName <- curveNumberToCurveName
  resultObj$plotlyPlot             <- p
  resultObj$columnsOfInterest      <- columnsOfInterest
  
  return(resultObj)
  
  ## https://plot.ly/r/plotlyproxy/
  ## https://plot.ly/r/get-requests/
  ## https://cran.r-project.org/web/packages/plotly/plotly.pdf
  ## https://plot.ly/r/shinyapp-linked-click/
  ## https://plot.ly/r/reference/#Layout_and_layout_style_objects
  ## https://plot.ly/r/reference/#layout
  ## https://plot.ly/r/shinyapp-plotly-events/
  
  
  ## p.bars.text = p.bars %>%
  ## plotly::layout(annotations = list(x = 30, y = 0,  text = "Expected", textangle=270, showarrow=F, xanchor="center"))
  
  ## for PCA:
  ## zeroline = TRUE
  
}



calcPlotHeatmap <- function(dataList, filterObj, clusterDataList, selectedTreeNodeSet, frameColor, heatmapContent, heatmapOrdering, xInterval = NULL){
  
  if(FALSE){
    dataList_ <<- dataList
    filterObj_ <<- filterObj
    clusterDataList_ <<- clusterDataList
    selectedTreeNodeSet_ <<- selectedTreeNodeSet
    frameColor_ <<- frameColor
    heatmapContent_ <<- heatmapContent
    heatmapOrdering_ <<- heatmapOrdering
    xInterval_ <<- xInterval
  }
  if(FALSE){
    dataList <- dataList_
    filterObj <- filterObj_
    clusterDataList <- clusterDataList_
    selectedTreeNodeSet <- selectedTreeNodeSet_
    frameColor <- frameColor_
    heatmapContent <- heatmapContent_
    heatmapOrdering <- heatmapOrdering_
    xInterval <- xInterval_
  }
  
  if(is.null(xInterval))
    xInterval <- c(1, clusterDataList$numberOfPrecursorsFiltered)
  
  ####################
  ## heatmap
  grouXXXps <- dataList$grouXXXps
  switch(heatmapContent,
         "Log-fold-change"={## log-fold-change
           columnsOfInterest <- c(
             dataList$dataMeanColumnNameFunctionFromName(filterObj$grouXXXps[[1]]), 
             dataList$dataMeanColumnNameFunctionFromName(filterObj$grouXXXps[[2]]), 
             dataList$lfcColumnNameFunctionFromName(filterObj$grouXXXps[[1]], filterObj$grouXXXps[[2]])
           )
           labels = c(filterObj$grouXXXps[[1]], filterObj$grouXXXps[[2]], "LFC")
         },
         "Abundance by group"={## grouXXXps
           columnsOfInterest <- unlist(lapply(X = grouXXXps, FUN = function(x){
             dataList$dataMeanColumnNameFunctionFromName(x)
           }))
           #columnsOfInterest <- rev(columnsOfInterest) ## plot is bottom to top
           labels <- grouXXXps
         },
         "Abundance by sample"={## samples
           columnsOfInterest <- dataList$dataColumnsNameFunctionFromGroupNames(grouXXXps = grouXXXps, sampleNamesToExclude = dataList$excludedSamples(dataList$groupSampleDataFrame))
           columnsOfInterest <- dataList$orderColumnNames(groupSampleDataFrame = dataList$groupSampleDataFrame, columnNames = columnsOfInterest)
           #columnsOfInterest <- rev(columnsOfInterest) ## plot is bottom to top
           ### this is original labels
           #labels <- columnsOfInterest
           labels <- gsub("_SMneg","",columnsOfInterest)
           ### changing lables like this gsub("_SMneg","",columnsOfInterest)
           #print("it is entering the area ..plots.r ...line 1218")
           #print(labels)
         },
         {## unknown state
           stop(paste("Unknown heatmapContent value", heatmapContent))
         }
  )## end switch
  numberOfGroups <- length(columnsOfInterest)
  
  ## heatmap ordering
  switch(heatmapOrdering,
         "Specified order"={## no clustering
           doCalculateCluster <- FALSE
         },
         "MS1 clustering"={## do clustering
           if(heatmapContent == "Log-fold-change"){
             doCalculateCluster <- FALSE
           } else {
             doCalculateCluster <- TRUE
           }
         },
         {## unknown state
           stop(paste("Unknown heatmapOrdering value", heatmapOrdering))
         }
  )## end switch
  
  ## in case of tree selections compute leaf intervals
  if(!is.null(selectedTreeNodeSet)){
    clusterMemberList <- lapply(X = selectedTreeNodeSet, FUN = function(x){
      ifelse(test = x < 0, yes = -x, no = clusterDataList$innerNodeMembersTreeLeaves[x])[[1]]
    })
    positionsList <- lapply(X = clusterMemberList, FUN = function(x){
      match(x = x, table = clusterDataList$cluster$order)
    })
    intervals <- lapply(X = clusterMemberList, FUN = function(x){
      positions <- match(x = x, table = clusterDataList$cluster$order)
      c(min(positions), max(positions))
    })
    intervalMatrix <- as.matrix(as.data.frame(intervals))
  }
  
  ## MS1 clustering and colors
  if(doCalculateCluster){
    data_s_p <- t(as.matrix(as.data.frame(lapply(X = columnsOfInterest, FUN = function(x){
      values <- dataList$dataFrameMeasurements[filterObj$filter, x][clusterDataList$cluster$order]
      if(is.null(selectedTreeNodeSet))
        return(values)
      
      unlist(apply(X = intervalMatrix, MARGIN = 2, FUN = function(x){
        values[seq(from=x[[1]], to = x[[2]], by = 1)]
      }))
    }))))
    
    dist <- dist(data_s_p)
    cluster <- hclust(d = dist, method = "ward.D")
    
    ## optimal leaf ordering
    if(numberOfGroups > 2){
      opt <- cba::order.optimal(dist = dist, merge = cluster$merge)
      cluster$merge <- opt$merge
      cluster$order <- opt$order
    }
    
    labels            <- labels[cluster$order]
    columnsOfInterest <- columnsOfInterest[cluster$order]
    
    #colors <- lapply(X = columnsOfInterest[cluster$order], FUN = function(x){
    colors <- lapply(X = columnsOfInterest, FUN = function(x){
      dataList$colorMatrixDataFrame [filterObj$filter, x][clusterDataList$cluster$order]
    })
    #values <- lapply(X = columnsOfInterest[cluster$order], FUN = function(x){
    values <- lapply(X = columnsOfInterest, FUN = function(x){
      dataList$dataFrameMeasurements[filterObj$filter, x][clusterDataList$cluster$order]
    })
    
    columnOrder <- cluster$order
  } else {
    colors <- lapply(X = columnsOfInterest, FUN = function(x){
      dataList$colorMatrixDataFrame [filterObj$filter, x][clusterDataList$cluster$order]
    })
    values <- lapply(X = columnsOfInterest, FUN = function(x){
      dataList$dataFrameMeasurements[filterObj$filter, x][clusterDataList$cluster$order]
    })
    columnOrder <- seq_along(columnsOfInterest)
  }
  
  ## plot
  par(mar=c(0,dendrogramHeatmapLeftMargin,0,0), mgp = c(3, 1, 0))  ## c(bottom, left, top, right) ## c(title, axis, label)
  
  if(numberOfGroups == 0){
    ## nothing there
    print("### calcPlotHeatmap: no columnsOfInterest")
    plot.new()
    return()
  }
  
  if(TRUE){
  plot(x = c(1, clusterDataList$numberOfPrecursorsFiltered), y = c(0, numberOfGroups), type= "n", xlab = "", ylab = "", axes = FALSE, xlim = xInterval, ylim = c(0, numberOfGroups))
  rect(
    xleft   = rep(x = seq_len(clusterDataList$numberOfPrecursorsFiltered) - 0.5, times = numberOfGroups), 
    xright  = rep(x = seq_len(clusterDataList$numberOfPrecursorsFiltered) + 0.5, times = numberOfGroups), 
    ybottom = unlist(lapply(X = seq_len(numberOfGroups) - 1, FUN = function(x){rep(x = x, times = clusterDataList$numberOfPrecursorsFiltered)})),
    ytop    = unlist(lapply(X = seq_len(numberOfGroups)    , FUN = function(x){rep(x = x, times = clusterDataList$numberOfPrecursorsFiltered)})),
    col     = unlist(colors),
    border = NA
  )
  if(!is.null(selectedTreeNodeSet))
    apply(X = intervalMatrix, MARGIN = 2, FUN = function(x){
      rect(xleft = x[[1]] - 0.5, xright = x[[2]] + 0.5, ybottom = 0, ytop = numberOfGroups, border = frameColor, lwd = 2)
    })
  
  axis(side = 2, at = seq(from = 0.5, by = 1, length.out = numberOfGroups), labels = labels, las = 2, tick = TRUE)
  }
  
  if(FALSE){
    m <- matrix(data = unlist(values), nrow = clusterDataList$numberOfPrecursorsFiltered, ncol = numberOfGroups)
    col <- m[1, ]
    names(col) <- labels
    sort(col)
    colUnSorted <- col
  }
  
  if(FALSE){
    plot_ly(
      x = NULL, y = labels,
      z = t(matrix(data = unlist(colors), nrow = clusterDataList$numberOfPrecursorsFiltered, ncol = numberOfGroups)), 
      type = "heatmap"
    )
    
    m <- t(matrix(data = rgb(t(col2rgb(unlist(colors))), maxColorValue=255), nrow = numberOfPrecursorsFiltered, ncol = numberOfGroups))
    m <- matrix(data = c(1:6), nrow = 2, ncol = 3)
    
    
    palette <- colorRampPalette(rainbow(18)[10:1])
    vals <- unique(scales::rescale(c(m)))
  }
  
  if(FALSE){
  
  m <- log10(t(matrix(data = unlist(values), nrow = clusterDataList$numberOfPrecursorsFiltered, ncol = numberOfGroups)))
  m[is.infinite(m)] <- 0
  
  min <- min(m, na.rm = TRUE)
  max <- max(m, na.rm = TRUE)
  
  vals <- unlist(m)
  o <- order(vals, decreasing = FALSE)
  cols <- scales::col_numeric(palette = rainbow(18)[10:1], domain = c(min,max))(vals)
  colz <- setNames(object = data.frame(vals[o], cols[o]), nm = NULL)
  
  plot <- plot_ly(
    x = NULL, y = labels,
    z = m, colorscale = colz,# colors = colorRamp(colors = c("red", "green")),#palette,
    type = "heatmap"
  ) %>%
    plotly::layout(                        # all of layout's properties: /r/reference/#layout
      xaxis = list(
        visible = FALSE,
        showgrid = FALSE#,
        #scaleanchor = "TODO",
        #scaleratio = 1
        #domain = xInterval
      ),
      yaxis = list(
        fixedrange = TRUE,
        showgrid = FALSE,
        type = "category"#,
        #tickmode = "auto", #"array"
        #tickvals = 1:numberOfGroups,
        #nticks = numberOfGroups,
        #ticktext = TODO
        #ticklen = -1
        #zeroline = TRUE ## for pca
      )
      #title = "Unemployment", # layout's title: /r/reference/#layout-title
      #xaxis = list(           # layout's xaxis is a named list. List of valid keys: /r/reference/#layout-xaxis
      #  title = "Time",      # xaxis's title: /r/reference/#layout-xaxis-title
      #  showgrid = F),       # xaxis's showgrid: /r/reference/#layout-xaxis-showgrid
      #yaxis = list(           # layout's yaxis is a named list. List of valid keys: /r/reference/#layout-yaxis
      #  title = "uidx")     # yaxis's title: /r/reference/#layout-yaxis-title
    )
  
  ## https://plot.ly/r/plotlyproxy/
  ## https://plot.ly/r/get-requests/
  ## https://cran.r-project.org/web/packages/plotly/plotly.pdf
  ## https://plot.ly/r/shinyapp-linked-click/
  ## https://plot.ly/r/reference/#Layout_and_layout_style_objects
  ## https://plot.ly/r/reference/#layout
  ## https://plot.ly/r/shinyapp-plotly-events/
  return(list(plot=plot, columnsOfInterest=columnsOfInterest))
  }
  
  returnObj <- list()
  returnObj$columnsOfInterest <- columnsOfInterest
  returnObj$columnOrder <- columnOrder
  
  return(returnObj)
}


calcPlotHeatmapOld <- function(dataList, filterObj, clusterDataList, xInterval = NULL){
  if(is.null(xInterval))
    xInterval <- c(1, clusterDataList$numberOfPrecursorsFiltered)
  
  ####################
  ## heatmap
  columnsOfInterest <- c(
    dataList$dataMeanColumnNameFunctionFromName(filterObj$grouXXXps[[1]]), dataList$dataMeanColumnNameFunctionFromName(filterObj$grouXXXps[[2]]), 
    dataList$lfcColumnNameFunctionFromName(filterObj$grouXXXps[[1]], filterObj$grouXXXps[[2]])
  )
  
  par(mar=c(0,4,0,0), mgp = c(3, 1, 0))  ## c(bottom, left, top, right) ## c(title, axis, label)
  
  if(length(columnsOfInterest) == 0){
    plot.new()
  } else {
    colorOne <- dataList$colorMatrixDataFrame[filterObj$filter, columnsOfInterest[[1]]][clusterDataList$cluster$order]
    colorTwo <- dataList$colorMatrixDataFrame[filterObj$filter, columnsOfInterest[[2]]][clusterDataList$cluster$order]
    colorLFC <- dataList$colorMatrixDataFrame[filterObj$filter, columnsOfInterest[[3]]][clusterDataList$cluster$order]
    
    plot(x = c(1, clusterDataList$numberOfPrecursorsFiltered), y = c(0, 3), type= "n", xlab = "", ylab = "", axes = FALSE, xlim = xInterval, ylim = c(0, 3))
    rect(
      xleft   = rep(x = seq_len(clusterDataList$numberOfPrecursorsFiltered) - 0.5, times = 3), 
      xright  = rep(x = seq_len(clusterDataList$numberOfPrecursorsFiltered) + 0.5, times = 3), 
      ybottom = unlist(lapply(X = 0:2, FUN = function(x){rep(x = x, times = clusterDataList$numberOfPrecursorsFiltered)})),
      ytop    = unlist(lapply(X = 1:3, FUN = function(x){rep(x = x, times = clusterDataList$numberOfPrecursorsFiltered)})),
      col     = c(colorTwo, colorOne, colorLFC),
      border = NA
    )
    
    #for(i in seq_len(clusterDataList$numberOfPrecursorsFiltered)){
    #  rect(xleft = i - 0.5, xright = i + 0.5, ybottom = 2, ytop = 3, col = colorLFC[[i]], border = NA)
    #  rect(xleft = i - 0.5, xright = i + 0.5, ybottom = 1, ytop = 2, col = colorOne[[i]], border = NA)
    #  rect(xleft = i - 0.5, xright = i + 0.5, ybottom = 0, ytop = 1, col = colorTwo[[i]], border = NA)
    #}
    axis(side = 2, at = c(0.5, 1.5, 2.5), labels = c(filterObj$grouXXXps[[2]], filterObj$grouXXXps[[1]], "LFC"), las = 2, tick = TRUE)
  }
  
  return(columnsOfInterest)
}

reorderAnnotationsForLegend <- function(annoLabels, annoColors){
  if(FALSE){
    annoLabels_ <<- annoLabels
    annoColors_ <<- annoColors
  }
  if(FALSE){
    annoLabels <<- annoLabels_
    annoColors <<- annoColors_
  }
  
  
  ignoreThere  <- any(annoLabels == "Ignore")
  unknownThere <- any(annoLabels == "Unknown")
  numberOfRealAnnotations <- length(annoLabels)
  if(ignoreThere){
    idx <- which(annoLabels == "Ignore")
    annoLabels <- c(annoLabels[-idx], annoLabels[idx])
    annoColors <- c(annoColors[-idx], annoColors[idx])
    numberOfRealAnnotations <- numberOfRealAnnotations - 1
  }
  if(unknownThere){
    idx <- which(annoLabels == "Unknown")
    annoLabels <- c(annoLabels[-idx], annoLabels[idx])
    annoColors <- c(annoColors[-idx], annoColors[idx])
    numberOfRealAnnotations <- numberOfRealAnnotations - 1
  }
  
  if(numberOfRealAnnotations > 0){
    order <- order(annoLabels[seq_len(numberOfRealAnnotations)])
    annoLabels[seq_len(numberOfRealAnnotations)] <- annoLabels[seq_len(numberOfRealAnnotations)][order]
    annoColors[seq_len(numberOfRealAnnotations)] <- annoColors[seq_len(numberOfRealAnnotations)][order]
  }
  
  resultList <- list(
    annoLabels = annoLabels,
    annoColors = annoColors
  )
}
########################################

calcPlotAnnoLegend <- function(annoLabels, annoColors){
  if(is.null(annoLabels)){
    annoLabels <- vector(mode = "character")
    annoColors <- vector(mode = "character")
  }
  
  ## get and reorder annotations
  resultObj <- reorderAnnotationsForLegend(annoLabels, annoColors)
  annoLabels <- resultObj$annoLabels
  annoColors <- resultObj$annoColors
  
  calcPlotLegend(annoLabels, annoColors, "Annotations")
}
### I am adding this new 

calcPlotAnnoLegend1 <- function(annoLabels, annoColors){
  if(is.null(annoLabels)){
    annoLabels <- vector(mode = "character")
    annoColors <- vector(mode = "character")
  }
  
  ## get and reorder annotations
  resultObj <- reorderAnnotationsForLegend(annoLabels, annoColors)
  annoLabels <- resultObj$annoLabels
  annoColors <- resultObj$annoColors
  
  calcPlotLegend1(annoLabels, annoColors, "Loadings")
}


calcPlotScoresGroupsLegend <- function(grouXXXps, colors){
  ## get and reorder annotations
  calcPlotLegend(grouXXXps, colors, "Scores")
}


calcPlotLegend <- function(annoLabels, annoColors, title){
  ## layout
  numberOfLines <- length(annoLabels) + 1
  ySpacing <- 1 / (numberOfLines + 1)
  xSpacing <- 0.1
  
  labels <- c(paste(title, ":", sep = ""), annoLabels)
  xPositions <- c(-0.05, rep(x = xSpacing, times = length(annoLabels)))
  #yPositions <- seq(from = 1, to = 0, by = 1/(-length(xPositions)))
  yPositions <- seq(from = 1 - ySpacing, to = ySpacing, length.out = numberOfLines)
  
  symbolXPositions <- rep(x = xSpacing * 0.75, times = length(annoLabels))
  symbolYPositions <- yPositions[2:length(yPositions)]
  
  ##################################################################################################
  ## plot
  plotLegendWithBalls(labels, xPositions, yPositions, symbolXPositions, symbolYPositions, annoColors, xSpacing*0.075)
}

### I am adding this new 

calcPlotLegend1 <- function(annoLabels, annoColors, title){
  ## layout
  numberOfLines <- length(annoLabels) + 1
  ySpacing <- 1 / (numberOfLines + 1)
  xSpacing <- 0.1
  
  labels <- c(paste(title, ":", sep = ""), annoLabels)
  xPositions <- c(-0.05, rep(x = xSpacing, times = length(annoLabels)))
  #yPositions <- seq(from = 1, to = 0, by = 1/(-length(xPositions)))
  yPositions <- seq(from = 1 - ySpacing, to = ySpacing, length.out = numberOfLines)
  
  symbolXPositions <- rep(x = xSpacing * 0.75, times = length(annoLabels))
  symbolYPositions <- yPositions[2:length(yPositions)]
  
  ##################################################################################################
  ## plot
  plotLegendWithBalls(labels, xPositions, yPositions, symbolXPositions, symbolYPositions, annoColors, xSpacing*0.075)
}

##############

calcPlotAnnoLegendForImage <- function(annoLabels, annoColors, maximumNumberOfLines=20){
  ## get and reorder annotations
  resultObj <- reorderAnnotationsForLegend(annoLabels, annoColors)
  annoLabels <- resultObj$annoLabels
  annoColors <- resultObj$annoColors
  
  calcPlotLegendForImage(annoLabels, annoColors, "Annotations", maximumNumberOfLines)
}
##### I am adding this new 

calcPlotAnnoLegendForImage1 <- function(annoLabels, annoColors, maximumNumberOfLines=30){
  ## get and reorder annotations
  resultObj <- reorderAnnotationsForLegend(annoLabels, annoColors)
  annoLabels <- resultObj$annoLabels
  annoColors <- resultObj$annoColors
  
  calcPlotLegendForImage2(annoLabels, annoColors, "Loadings", maximumNumberOfLines)
}
#################


calcPlotScoresGroupsLegendForImage <- function(grouXXXps, colors, maximumNumberOfLines=20){
  ## get and reorder annotations
  calcPlotLegendForImage(grouXXXps, colors, "Scores", maximumNumberOfLines)
}
#### I am adding this new 
calcPlotScoresGroupsLegendForImage1 <- function(grouXXXps, colors, maximumNumberOfLines=30){
  ## get and reorder annotations
  calcPlotLegendForImage1(grouXXXps, colors, "Scores", maximumNumberOfLines)
}

###########


calcPlotLegendForImage <- function(annoLabels, annoColors, title, maximumNumberOfLines){
  ## layout
  numberOfLines <- length(annoLabels) + 1
  ySpacing <- 1 / maximumNumberOfLines
  xSpacing <- 0.1
  
  labels <- c(paste(title, ":", sep = ""), annoLabels)
  xPositions <- c(-0.05, rep(x = xSpacing, times = length(annoLabels)))
  #yPositions <- seq(from = 1, to = 0, by = 1/(-length(xPositions)))
  yPositions <- seq(from = 1 - ySpacing, to = ySpacing, length.out = maximumNumberOfLines)
  yPositions <- yPositions[seq_len(numberOfLines)]
  
  symbolXPositions <- rep(x = xSpacing * 0.75, times = length(annoLabels))
  symbolYPositions <- yPositions[2:length(yPositions)]
  symbolYPositions <- symbolYPositions[seq_len(length(symbolXPositions))]
  
  if(numberOfLines > maximumNumberOfLines){
    labels <- labels[seq_len(maximumNumberOfLines)]
    annoColors <- annoColors[seq_len((maximumNumberOfLines - 1))]
    xPositions <- xPositions[seq_len(maximumNumberOfLines)]
    yPositions <- yPositions[seq_len(maximumNumberOfLines)]
    
    labels[length(labels)] <- paste("...", (numberOfLines - maximumNumberOfLines + 1), " more", sep = "")
    annoColors <- annoColors[seq_len(length(annoColors) - 1)]
    symbolXPositions <- symbolXPositions[seq_len(length(symbolXPositions) - 1)]
    symbolYPositions <- symbolYPositions[seq_len(length(symbolYPositions) - 1)]
  }
  
  ##################################################################################################
  ## plot
  plotLegendWithBalls(labels, xPositions, yPositions, symbolXPositions, symbolYPositions, annoColors, xSpacing*0.075)
}
### I am adding this new line
calcPlotLegendForImage2 <- function(annoLabels, annoColors, title, maximumNumberOfLines){
  ## layout
  numberOfLines <- length(annoLabels) + 1
  ySpacing <- 1 / maximumNumberOfLines
  xSpacing <- 0.1
  
  labels <- c(paste(title, ":", sep = ""), annoLabels)
  xPositions <- c(-0.05, rep(x = xSpacing, times = length(annoLabels)))
  #yPositions <- seq(from = 1, to = 0, by = 1/(-length(xPositions)))
  yPositions <- seq(from = 1 - ySpacing, to = ySpacing, length.out = maximumNumberOfLines)
  yPositions <- yPositions[seq_len(numberOfLines)]
  
  symbolXPositions <- rep(x = xSpacing * 0.75, times = length(annoLabels))
  symbolYPositions <- yPositions[2:length(yPositions)]
  symbolYPositions <- symbolYPositions[seq_len(length(symbolXPositions))]
  
  if(numberOfLines > maximumNumberOfLines){
    labels <- labels[seq_len(maximumNumberOfLines)]
    annoColors <- annoColors[seq_len((maximumNumberOfLines - 1))]
    xPositions <- xPositions[seq_len(maximumNumberOfLines)]
    yPositions <- yPositions[seq_len(maximumNumberOfLines)]
    
    labels[length(labels)] <- paste("...", (numberOfLines - maximumNumberOfLines + 1), " more", sep = "")
    annoColors <- annoColors[seq_len(length(annoColors) - 1)]
    symbolXPositions <- symbolXPositions[seq_len(length(symbolXPositions) - 1)]
    symbolYPositions <- symbolYPositions[seq_len(length(symbolYPositions) - 1)]
  }
  
  ##################################################################################################
  ## plot
  
  plotLegendWithBalls(labels, xPositions, yPositions, symbolXPositions, symbolYPositions, annoColors, xSpacing*0.075)
}
###################################
##### I am adding this new 

calcPlotLegendForImage1 <- function(annoLabels, annoColors, title, maximumNumberOfLines){
  ## layout
  numberOfLines <- length(annoLabels) + 1
  ySpacing <- 1 / maximumNumberOfLines
  xSpacing <- 0.1
  
  labels <- c(paste(title, ":", sep = ""), annoLabels)
  xPositions <- c(-0.05, rep(x = xSpacing, times = length(annoLabels)))
  #yPositions <- seq(from = 1, to = 0, by = 1/(-length(xPositions)))
  yPositions <- seq(from = 1 - ySpacing, to = ySpacing, length.out = maximumNumberOfLines)
  yPositions <- yPositions[seq_len(numberOfLines)]
  
  symbolXPositions <- rep(x = xSpacing * 0.75, times = length(annoLabels))
  symbolYPositions <- yPositions[2:length(yPositions)]
  symbolYPositions <- symbolYPositions[seq_len(length(symbolXPositions))]
  
  if(numberOfLines > maximumNumberOfLines){
    labels <- labels[seq_len(maximumNumberOfLines)]
    annoColors <- annoColors[seq_len((maximumNumberOfLines - 1))]
    xPositions <- xPositions[seq_len(maximumNumberOfLines)]
    yPositions <- yPositions[seq_len(maximumNumberOfLines)]
    
    labels[length(labels)] <- paste("...", (numberOfLines - maximumNumberOfLines + 1), " more", sep = "")
    annoColors <- annoColors[seq_len(length(annoColors) - 1)]
    symbolXPositions <- symbolXPositions[seq_len(length(symbolXPositions) - 1)]
    symbolYPositions <- symbolYPositions[seq_len(length(symbolYPositions) - 1)]
  }
  
  ##################################################################################################
  ## plot
  plotLegendWithBalls1(labels, xPositions, yPositions, symbolXPositions, symbolYPositions, annoColors, xSpacing*0.075)
  #plotLegendWithBalls1(labels, xPositions, yPositions, symbolXPositions, symbolYPositions, annoColors, xSpacing*0.075,filterObj)
}




####  this is the original


plotLegendWithBalls <- function(labels, xPositions, yPositions, circleXPositions, circleYPositions, annoColors, radius){
  par(mar=c(0,0,0,0), mgp = c(3, 1, 0))  ## c(bottom, left, top, right)
  plot.new()
  plot.window(xlim = c(0, 1), ylim = c(0, 1))
  
  ## circles
  for(i in seq_len(length(annoColors)))
    draw.circle(x = circleXPositions[[i]], y = circleYPositions[[i]], radius = radius, nv=50, border=annoColors[[i]], col = annoColors[[i]], lty=1, lwd=5)
  
  ### adding the cex=0.5 #######
  ## labels
  graphics::text(x = xPositions, y = yPositions, labels = labels, pos = 4)
}
#################
plotLegendWithBalls1 <- function(labels, xPositions, yPositions, circleXPositions, circleYPositions, annoColors, radius){
  #plotLegendWithBalls1 <- function(labels, xPositions, yPositions, circleXPositions, circleYPositions, annoColors, radius,filterObj){
  palette <- colorPaletteScores()
  
  # if(filterObj$filterBySamples){
  #   colorsForReplicates <- palette[unlist(lapply(X = filterObj$grouXXXps, FUN = function(x){ 
  #     groupIdx <- dataList$groupIdxFromGroupName(x)
  #     samples <- dataList$dataColumnsNameFunctionFromGroupName(x, sampleNamesToExclude = dataList$excludedSamples(dataList$groupSampleDataFrame))
  #     samples <- intersect(samples, filterObj$sampleSet)
  #     rep(x = groupIdx, times = length(samples))
  #   }))]
  # } else {
  #   colorsForReplicates <- palette[unlist(lapply(X = filterObj$grouXXXps, FUN = function(x){ 
  #     groupIdx <- dataList$groupIdxFromGroupName(x)
  #     rep(x = groupIdx, times = length(dataList$dataColumnsNameFunctionFromGroupName(x, sampleNamesToExclude = dataList$excludedSamples(dataList$groupSampleDataFrame))))
  #   }))]
  # }
  
  par(mar=c(0,0,0,0), mgp = c(3, 1, 0),par(xpd=FALSE))  ## c(bottom, left, top, right)
  plot.new()
  plot.window(xlim = c(0, 1), ylim = c(0, 1))
  
  ## circles
  for(i in seq_len(length(annoColors))){
    
    ### I am changing the pch=i to labels[[i]]...col =colorsForReplicates[[i]]
    points(x=circleXPositions[[i]], y=circleYPositions[[i]],pch=i,col =annoColors[[i]],lty=1,lwd=2)
    ## labelscol = colorsForReplicates[[i]]
    graphics::text(x = xPositions, y = yPositions, labels = labels, pos = 4)}
}
######################################


calcPlotMS2Legend <- function(dataList){
  ####################
  ## heatmap legend
  par(mar=c(0,0,0,0), mgp = c(3, 1, 0))  ## c(bottom, left, top, right)
  
  xSpacing <- 0.1
  stickLabels <- c(
    paste("Presence >= ", minimumProportionOfLeafs, sep = ""), 
    paste("Presence > ", minimumProportionToShowFragment, sep = ""), 
    "Selected fragment"
  )
  annoColorsStick <- c("black", "grey", "green")
  annoColorsBallSmall <- c("grey", "grey", "grey")
  annoColorsBallBig <- c("black", "black", "green")
  labels <- c("Fragment stick colors", stickLabels)
  xPositions <- c(-0.05, rep(x = xSpacing, times = length(stickLabels)))
  #yPositions <- seq(from = 1, to = 0, by = 1/(-length(xPositions)))
  yPositions <- seq(from = 0.9, to = -0.1, by = -1/length(labels))[seq_len(length(xPositions))]
  
  symbolXPositions <- rep(x = xSpacing * 0.75, times = length(stickLabels))
  symbolYPositions <- yPositions[2:length(yPositions)]
  
  ##################################################################################################
  ## plot
  plot.new()
  plot.window(xlim = c(0, 1), ylim = c(0, 1))
  
  ## points
  pointSizes <- rep(x = ms2StickPointSizeInitial, times = length(stickLabels))
  pointSizesSmall <- rep(x = ms2StickPointSizeInitialSmall, times = length(stickLabels))
  
  delta <- 0.05
  segments(x0 = symbolXPositions, x1 = symbolXPositions, y0 = symbolYPositions - delta, y1 = symbolYPositions + delta, col = annoColorsStick, lwd = 3)
  points(x = symbolXPositions, y = symbolYPositions + delta, col = annoColorsBallBig, pch=19, cex=pointSizes)
  points(x = symbolXPositions, y = symbolYPositions + delta, col = annoColorsBallSmall, pch=19, cex=pointSizesSmall)
  
  ## labels
  graphics::text(x = xPositions, y = yPositions, labels = labels, pos = 4)
}



calcPlotDendrogramLegend <- function(){
  ####################
  ## heatmap legend
  par(mar=c(0,0,0,0), mgp = c(3, 1, 0))  ## c(bottom, left, top, right)
  
  xSpacing <- 0.1
  stickLabels <- c(
    "Selection by HCA/PCA", 
    ##"Selection by fragment", 
    "Selection by search"
  )
  selectionColors <- c("blue", "green", "red")
  labels <- c("Selection marks", stickLabels)
  xPositions <- c(-0.05, rep(x = xSpacing, times = length(stickLabels)))
  #yPositions <- seq(from = 1, to = 0, by = 1/(-length(xPositions)))
  yPositions <- seq(from = 0.9, to = -0.1, by = -1/length(labels))[seq_len(length(xPositions))]
  
  symbolXPositions <- rep(x = xSpacing * 0.75, times = length(stickLabels))
  symbolYPositions <- yPositions[2:length(yPositions)]
  
  ##################################################################################################
  ## plot
  plot.new()
  plot.window(xlim = c(0, 1), ylim = c(0, 1))
  
  ## points
  pointSizes      <- rep(x = clusterNodePointSize1, times = length(stickLabels))
  pointSizesSmall <- rep(x = clusterNodePointSize0, times = length(stickLabels))
  
  points(x = symbolXPositions, y = symbolYPositions, col = selectionColors, pch=19, cex=pointSizes)
  points(x = symbolXPositions, y = symbolYPositions, col = rep(x = "white", times = length(selectionColors)), pch=19, cex=pointSizesSmall)
  
  ## labels
  graphics::text(x = xPositions, y = yPositions, labels = labels, pos = 4)
}

calcPlotDiscriminativityLegend <- function(){
  ####################
  ## heatmap legend
  par(mar=c(0,0,0,0), mgp = c(3, 1, 0))  ## c(bottom, left, top, right)
  
  xSpacing <- 0.1
  stickLabels <- c(
    "0%", 
    "25%", 
    "50%", 
    "75%", 
    "100%"
  )
  labels <- c("Cluster-discriminating power", stickLabels)
  xPositions <- c(-0.05, rep(x = xSpacing, times = length(stickLabels)))
  #yPositions <- seq(from = 1, to = 0, by = 1/(-length(xPositions)))
  yPositions <- seq(from = 0.9, to = -0.1, by = -1/length(labels))[seq_len(length(xPositions))]
  
  symbolXPositions <- rep(x = xSpacing * 0.75, times = length(stickLabels))
  symbolYPositions <- yPositions[2:length(yPositions)]
  
  ##################################################################################################
  ## plot
  plot.new()
  plot.window(xlim = c(0, 1), ylim = c(0, 1))
  
  ## points
  pointSizes      <- ms2StickPointSizeInitialSmall + c(0, 0.25, 0.5, 0.75, 1) * ms2StickPointSizeMaximumMultiplier
  
  #dendrogramClusterPointSizeMaximumMultiplier <- 0.75
  points(x = symbolXPositions, y = symbolYPositions, col = "black", pch=19, cex=pointSizes)
  
  ## labels
  graphics::text(x = xPositions, y = yPositions, labels = labels, pos = 4)
  #graphics::text(x = xPositions[[1]], y = yPositions[[1]], labels = labels[[1]], pos = 4)
  #graphics::text(x = xPositions[2:length(xPositions)], y = yPositions[2:length(yPositions)], labels = labels[2:length(labels)], pos = 4, adj = 1)
}


#' Title
#'
#' @param dataList 
#'
#' @return
#' @export
#' @importsFrom grDevices as.raster
#'
#' @examples
calcPlotHeatmapLegend <- function(dataList){
  ####################
  ## heatmap legend
  par(mar=c(0,0,0,0), mgp = c(3, 1, 0))  ## c(bottom, left, top, right)
  
  legend_imageAbs <- as.raster(x = t(x = matrix(data = cmap(x = seq(from = dataList$logAbsMax,        to =  0,                         length.out = 100), map = dataList$colorMapAbsoluteData ), nrow=1)))
  legend_imageLFC <- as.raster(x = t(x = matrix(data = cmap(x = seq(from = dataList$logFoldChangeMax, to = -dataList$logFoldChangeMax, length.out = 100), map = dataList$colorMapLogFoldChange), nrow=1)))
  
  maximumNumberOfLabelsAbs <- 5
  maximumNumberOfLabelsLFC <- 2.5
  minY <- 0.0
  maxY <- 0.875
  epsilon <- 0.075
  middle <- ((maxY - minY) / 2)
  absMaxY <- middle - epsilon
  lfcMinY <- middle + epsilon
  
  ##############################################
  ## abs
  returnObj <- createTickLabels(maximumNumberOfLabelsAbs, dataList$logAbsMax, "10^")
  absLegendPositions <- returnObj$legendPositions
  absLegendLabels    <- returnObj$legendLabels
  
  absLegendPositions <- minY + absLegendPositions * (absMaxY - minY)
  
  ##############################################
  ## lfc
  returnObj <- createTickLabels(maximumNumberOfLabelsLFC, dataList$logFoldChangeMax, "")
  lfcLegendPositions <- returnObj$legendPositions
  lfcLegendLabels    <- returnObj$legendLabels
  
  ## double
  if(lfcLegendLabels[[1]] == "0"){
    ## do not copy zero
    lfcLegendPositions <- c(rev(lfcLegendPositions), -lfcLegendPositions[2:length(lfcLegendPositions)])
    revLabels <- lfcLegendLabels[2:length(lfcLegendLabels)]
    revLabels[revLabels != ""] <- paste("-", revLabels[revLabels != ""])
    lfcLegendLabels    <- c(rev(lfcLegendLabels   ), revLabels)
    lfcLegendLabels1 <-unname(sapply(lfcLegendLabels,function(y) gsub(" ","",y)))
  } else {
    lfcLegendPositions <- c(rev(lfcLegendPositions), -lfcLegendPositions)
    revLabels <- lfcLegendLabels
    revLabels[revLabels != ""] <- paste("-", revLabels[revLabels != ""])
    lfcLegendLabels    <- c(rev(lfcLegendLabels   ), revLabels)
    lfcLegendLabels1 <-unname(sapply(lfcLegendLabels,function(y) gsub(" ","",y)))
  }
  
  lfcLegendPositions <- lfcLegendPositions - min(lfcLegendPositions)
  lfcLegendPositions <- lfcLegendPositions / max(lfcLegendPositions)
  lfcLegendPositions <- lfcMinY + lfcLegendPositions * (maxY - lfcMinY)
  
  ##################################################################################################
  ## plot
  plot.new()
  plot.window(xlim = c(0, 3), ylim = c(0, 1))
  
  ## abs legend
  rasterImage(image = legend_imageAbs, xleft = 0, ybottom = minY, xright = 1, ytop = absMaxY)
  ### I am adding cex = 1 default to 0.8
  graphics::text(x = 1.2, y = absLegendPositions, labels = absLegendLabels, pos = 4)
  
  ## axis marks
  segments(
    x0  = rep(x = 0, times = length(absLegendPositions)),
    x1  = rep(x = 1.2, times = length(absLegendPositions)),
    y0  = absLegendPositions,
    y1  = absLegendPositions
  )
  ## frame
  segments(## lower hori; upper hori; left vert; right vert
    x0  = c(0, 0, 0, 1),
    x1  = c(1, 1, 0, 1),
    y0  = c(minY, absMaxY, minY   , minY   ),
    y1  = c(minY, absMaxY, absMaxY, absMaxY)
  )
  graphics::text(x = -0.2, y = absMaxY + 0.065, labels = "MS\u00B9 abundance", pos = 4)
  
  ## lfc legend
  rasterImage(image = legend_imageLFC, xleft = 0, ybottom = lfcMinY, xright = 1, ytop = maxY)
  ### changing that from 1.2 to 1.3
  graphics::text(x = 1.4, y = lfcLegendPositions, labels = lfcLegendLabels1, pos = 4,cex=1.04)
  #graphics::text(x = 2, y = seq(lfcMinY,maxY,l=5), labels = lfcLegendLabels)
  ## frame
  segments(## lower hori; upper hori; left vert; right vert
    x0  = c(0, 0, 0, 1),
    x1  = c(1, 1, 0, 1),
    y0  = c(lfcMinY, maxY, lfcMinY, lfcMinY),
    y1  = c(lfcMinY, maxY, maxY   , maxY   )
  )
  ## axis marks
  segments(
    x0  = rep(x = 0, times = length(lfcLegendPositions)),
    x1  = rep(x = 1.2, times = length(lfcLegendPositions)),
    y0  = lfcLegendPositions,
    y1  = lfcLegendPositions
  )
  graphics::text(x = -0.2, y = maxY + 0.09, labels = "log2(MS\u00B9 fold change)", pos = 4)
}
createTickLabels <- function(maximumNumberOfLabels, max, labelPrefix){
  if(max < 1)
    max <- 1
  maxInteger <- as.integer(max)
  numbers <- 0:maxInteger
  
  maxYlabelPosition <- maxInteger / max
  if(is.na(maxYlabelPosition))  ## data range is zero
    maxYlabelPosition <- 1
  legendPositions <- seq(from = 0, to = maxYlabelPosition, length.out = length(numbers))
  
  # if(length(legendPositions) > maximumNumberOfTicks){
  #   indeces <- rev(seq(from = length(numbers), to = 1, by = -ceiling( length(numbers) / maximumNumberOfTicks )))
  #   
  #   legendPositions <- legendPositions[indeces]
  #   numbers         <- numbers        [indeces]
  # }
  
  legendLabels    = paste(labelPrefix, numbers, sep = "")
  if(length(numbers) > maximumNumberOfLabels){
    indeces <- rev(seq(from = length(numbers), to = 1, by = -ceiling( length(numbers) / maximumNumberOfLabels )))
    
    legendLabels    <- legendLabels[indeces]
    legendPositions <- legendPositions[indeces]
  }
  
  returnObj <- list()
  returnObj$legendPositions <- legendPositions
  returnObj$legendLabels    <- legendLabels
  
  return(returnObj)
}

calcPlotMS2 <- function(dataList, fragmentsX = NULL, fragmentsY = NULL, fragmentsColor = NULL, fragmentsDiscriminativity = NULL, fragmentsX_02 = NULL, fragmentsY_02 = NULL, fragmentsColor_02 = NULL, xInterval = NULL, selectedFragmentIndex = NULL, dendrogramFragmentStatistics = FALSE){
  
  if(FALSE){
    dataList_ <<- dataList
    fragmentsX_ <<- fragmentsX
    fragmentsY_ <<- fragmentsY
    fragmentsColor_ <<- fragmentsColor
    fragmentsDiscriminativity_ <<- fragmentsDiscriminativity
    fragmentsX_02_ <<- fragmentsX_02
    fragmentsY_02_ <<- fragmentsY_02
    fragmentsColor_02_ <<- fragmentsColor_02
    xInterval_ <<- xInterval
    selectedFragmentIndex_ <<- selectedFragmentIndex
  }
  if(FALSE){
    dataList <<- dataList_
    fragmentsX <<- fragmentsX_
    fragmentsY <<- fragmentsY_
    fragmentsColor <<- fragmentsColor_
    fragmentsDiscriminativity <<- fragmentsDiscriminativity_
    fragmentsX_02 <<- fragmentsX_02_
    fragmentsY_02 <<- fragmentsY_02_
    fragmentsColor_02 <<- fragmentsColor_02_
    xInterval <<- xInterval_
    selectedFragmentIndex <<- selectedFragmentIndex_
  }
  
  
  ####################
  ## fragment spectrum
  if(is.null(xInterval))
    xInterval <- c(dataList$minimumMass, dataList$maximumMass)
  
  ## abundances greater one
  fragmentsY[fragmentsY > 1] <- 1
  
  ## y-axis
  if(is.null(fragmentsX_02)){
    ## nothing hovered; maybe something selected
    yInterval <- c(0, 1)
    #nodeColors <- rep(x = "black", times = length(fragmentsX))
    nodeColors <- fragmentsColor
    dataX <- fragmentsX
    dataY <- fragmentsY
    dataX2 <- fragmentsX
    dataY2 <- fragmentsY
    yTickPositions <- c(0, 0.25, 0.5, 0.75, 1)
    yTickLabels <- c(0, "", 0.5, "", 1)
  } else {
    ## something hovered; maybe something selected
    #nodeColors <- rep(x = "black", times = length(fragmentsX) + length(fragmentsX_02))
    nodeColors <- c(fragmentsColor, fragmentsColor_02)
    
    if(is.null(fragmentsX)){
      ## something hovered; nothing selected
      yInterval <- c(0, 1)
      dataX <- fragmentsX_02
      dataY <- fragmentsY_02
      dataX2 <- NULL
      dataY2 <- NULL
      yTickPositions <- c(0, 0.25, 0.5, 0.75, 1)
      yTickLabels <- c(0, "", 0.5, "", 1)
    } else {
      ## something hovered; something selected
      yInterval <- c(-1, 1)
      dataX <- c(fragmentsX, fragmentsX_02)
      dataY <- c(fragmentsY, -fragmentsY_02)
      dataX2 <- fragmentsX
      dataY2 <- fragmentsY
      yTickPositions <- c(-1, -0.75, -0.5, -0.25, 0, 0.25, 0.5, 0.75, 1)
      yTickLabels <- c(1, "", 0.5, "", 0, "", 0.5, "", 1)
    }
  }
  
  ## node selection
  if(!is.null(selectedFragmentIndex))
    nodeColors[[selectedFragmentIndex]] <- "green"
  
  par(mar=c(6,4,3,0), mgp = c(3, 1, 0))  ## c(bottom, left, top, right)
  plot(x = dataX, y = dataX, ylab = "Relative abundance", xlab = "m/z", xlim = xInterval, ylim = yInterval, xaxt='n', yaxt='n', col = nodeColors)
  axis(side = 2, at = yTickPositions, labels = yTickLabels)
  axis(side = 3)
  title("Fragment plot", line = 2)
  #mtext(side = 3, "m/z", line = 2)
  
  ## x-axis line
  if(!is.null(fragmentsX) & !is.null(fragmentsX_02)){
    xIntervalSize <- xInterval[[2]] - xInterval[[1]]
    xl <- xInterval[[1]] - xIntervalSize
    xr <- xInterval[[2]] + xIntervalSize
    segments(x0 = xl, x1 = xr, y0 = 0, y1 = 0, col = "black", lwd = 1)
  }
  
  ## label axis, fragment sticks with clickable points
  tickPositions <- dataX
  if(length(dataX) > 0){
    ## axis with the individual fragment m/z's (ticks, labels)
    axis(side = 1, at = dataX, labels = FALSE, las = 2)
    axis(side = 1, at = tickPositions, labels = format(x = dataX, digits = 1, nsmall = 4), las = 2, tick = FALSE)
    
    ## sticks
    points(x = dataX, y = dataY, col = nodeColors, type = "h", lwd=4)
    
    if(!is.null(dataX2)){
      ## clickable points
      pointSizes <- rep(x = ms2StickPointSizeInitial, times = length(dataX2))
      pointSizesSmall <- rep(x = ms2StickPointSizeInitialSmall, times = length(dataX2))
      pointColors <- rep(x = "black", times = length(dataX2))
      pointColorsSmall <- rep(x = "gray", times = length(dataX2))
      if(!is.null(selectedFragmentIndex)){
        pointSizes[[selectedFragmentIndex]] <- ms2StickPointSizeEmph
        pointSizesSmall[[selectedFragmentIndex]] <- ms2StickPointSizeEmphSmall
        pointColors[[selectedFragmentIndex]] <- "green"
        #pointColorsSmall[[selectedFragmentIndex]] <- "green"
      }
      pointSizeMultiplier <- fragmentsDiscriminativity * ms2StickPointSizeMaximumMultiplier
      pointSizes      <- pointSizes      + pointSizeMultiplier
      pointSizesSmall <- pointSizesSmall + pointSizeMultiplier
      
      points(x = dataX2, y = dataY2, col = pointColors,      pch=19, cex=pointSizes)
      points(x = dataX2, y = dataY2, col = pointColorsSmall, pch=19, cex=pointSizesSmall)
    }
  }
  
  if(!is.null(fragmentsX) & !is.null(fragmentsX_02)){
    graphics::text(labels = "Fragments from selection", x = xInterval[[2]], y = 0.9, pos = 2, adj = c(0,0))
    graphics::text(labels = "Fragments from mouse hover", x = xInterval[[2]], y = -0.9, pos = 2, adj = c(0,0))
  }
  if(!is.null(fragmentsX) & is.null(fragmentsX_02)){
    if(!dendrogramFragmentStatistics)
      graphics::text(labels = "Fragments from selection", x = xInterval[[2]], y = 0.95, pos = 2, adj = c(0,0))
    else
      graphics::text(labels = "Dendrogram statistics",    x = xInterval[[2]], y = 0.95, pos = 2, adj = c(0,0))
  }
  if(is.null(fragmentsX) & !is.null(fragmentsX_02)){
    graphics::text(labels = "Fragments from mouse hover", x = xInterval[[2]], y = 0.95, pos = 2, adj = c(0,0))
  }
}

getPcaPerformanceIndicator <- function(pcaObj, isScores){
  variableName <- ifelse(test = isScores, yes = "t", no = "p")
  variableName_dim <- paste(variableName, "_", pcaDimensionOne, sep = "")
  
  if("accurracyContribution" %in% names(pcaObj)){
    ## R2 and Q2 or accurracyContribution
    accOne <- format(x = pcaObj$accurracyContribution[[pcaDimensionOne]]*100, digits = 3)
    accTwo <- format(x = pcaObj$accurracyContribution[[pcaDimensionTwo]]*100, digits = 3)
    
    xAxisLabel  <- paste(variableName_dim, " (acc = ", accOne, "%)", sep = "")
    yAxisLabel  <- paste(variableName_dim, " (acc = ", accTwo, "%)", sep = "")
  } else {
    if(all(c("R2", "Q2") %in% names(pcaObj))){
      ## R2 and Q2
      r2One <- format(x = pcaObj$R2[[pcaDimensionOne]]*100, digits = 3)
      r2Two <- format(x = pcaObj$R2[[pcaDimensionTwo]]*100, digits = 3)
      q2One <- format(x = pcaObj$Q2[[pcaDimensionOne]]*100, digits = 3)
      q2Two <- format(x = pcaObj$Q2[[pcaDimensionTwo]]*100, digits = 3)
      
      xAxisLabel  <- paste(variableName_dim, " (R^2 = ", r2One, "%; Q^2 = ", q2One, "%)", sep = "")
      yAxisLabel  <- paste(variableName_dim, " (R^2 = ", r2Two, "%; Q^2 = ", q2Two, "%)", sep = "")
    } else {
      if("variance" %in% names(pcaObj)){
        ## explained variance
        varianceOne <- format(x = pcaObj$variance[[pcaDimensionOne]]*100, digits = 3)
        varianceTwo <- format(x = pcaObj$variance[[pcaDimensionTwo]]*100, digits = 3)
        xAxisLabel  <- paste(variableName_dim, " (var = ", varianceOne, "%)", sep = "")
        yAxisLabel  <- paste(variableName_dim, " (var = ", varianceTwo, "%)", sep = "")
      } else {
        ## no performace indicator there
        xAxisLabel  <- paste(variableName_dim, sep = "")
        yAxisLabel  <- paste(variableName_dim, sep = "")
      }
    }
  }
  
  resultObj <- list()
  resultObj$xAxisLabel <- xAxisLabel
  resultObj$yAxisLabel <- yAxisLabel
  return(resultObj)
}

###### this is original one
calcPlotPCAscores <- function(pcaObj, dataList, filterObj, pcaDimensionOne, pcaDimensionTwo, showScoresLabels, xInterval = NULL, yInterval = NULL){
  palette <- colorPaletteScores()
  
  if(filterObj$filterBySamples){
    colorsForReplicates <- palette[unlist(lapply(X = filterObj$grouXXXps, FUN = function(x){ 
      groupIdx <- dataList$groupIdxFromGroupName(x)
      samples <- dataList$dataColumnsNameFunctionFromGroupName(x, sampleNamesToExclude = dataList$excludedSamples(dataList$groupSampleDataFrame))
      samples <- intersect(samples, filterObj$sampleSet)
      rep(x = groupIdx, times = length(samples))
    }))]
  } else {
    colorsForReplicates <- palette[unlist(lapply(X = filterObj$grouXXXps, FUN = function(x){ 
      groupIdx <- dataList$groupIdxFromGroupName(x)
      rep(x = groupIdx, times = length(dataList$dataColumnsNameFunctionFromGroupName(x, sampleNamesToExclude = dataList$excludedSamples(dataList$groupSampleDataFrame))))
    }))]
  }
  
  ## data
  dataDimOne <- pcaObj$scores[, pcaDimensionOne]
  dataDimTwo <- pcaObj$scores[, pcaDimensionTwo]
  
  ## performance
  resultObj <- getPcaPerformanceIndicator(pcaObj = pcaObj, isScores = TRUE)
  xAxisLabel <- resultObj$xAxisLabel
  yAxisLabel <- resultObj$yAxisLabel
  
  ## xlim / ylim
  xMin <- min(dataDimOne)
  xMax <- max(dataDimOne)
  yMin <- min(dataDimTwo)
  yMax <- max(dataDimTwo)
  
  if(any(is.na(c(xMin, xMax, yMin, yMax)))){
    xMin <- -1
    xMax <- 1
    yMin <- -1
    yMax <- 1
  }
  
  if(is.null(xInterval))
    xInterval <- c(xMin, xMax)
  if(is.null(yInterval))
    yInterval <- c(yMin, yMax)
  
  par(mar=c(3 + 0.35, 3, 2, 1), mgp = c(2, 1, 0))  ## c(bottom, left, top, right)
  plot(
    x = dataDimOne, y = dataDimTwo, 
    xlim = xInterval, ylim = yInterval, 
    xlab = xAxisLabel, ylab = yAxisLabel, main = "Scores", 
    #### changing from cex=1. to 0.8
    col = colorsForReplicates, pch=19, cex=1.
  )
  
  ## axis
  xInt <- xMax - xMin
  yInt <- yMax - yMin
  xl <- xMin - xInt
  xr <- xMax + xInt
  yl <- yMin - yInt
  yr <- yMax + yInt
  segments(x0 = xl, x1 = xr, y0 = 0, y1 = 0, col = "black", lwd = 1)
  segments(x0 = 0, x1 = 0, y0 = yl, y1 = yr, col = "black", lwd = 1)
  
  if(showScoresLabels){
    
    if(filterObj$filterBySamples){
      labels <- dataList$dataColumnsNameFunctionFromGroupNames(filterObj$grouXXXps, sampleNamesToExclude = dataList$excludedSamples(dataList$groupSampleDataFrame))
      labels <- intersect(labels, filterObj$sampleSet)
    } else {
      labels <- dataList$dataColumnsNameFunctionFromGroupNames(filterObj$grouXXXps, sampleNamesToExclude = dataList$excludedSamples(dataList$groupSampleDataFrame))
    }
    graphics::text(x = dataDimOne, y = dataDimTwo, labels = labels, pos = 4)
  }
}

#### I am adding this new line

calcPlotPCAscores1 <- function(pcaObj, dataList, filterObj, pcaDimensionOne, pcaDimensionTwo, showScoresLabels, xInterval = NULL, yInterval = NULL){
  palette <- colorPaletteScores()
  
  #### add this new line ########
  
  if(filterObj$filterBySamples){
    colorsForReplicates <- palette[unlist(lapply(X = filterObj$grouXXXps, FUN = function(x){ 
      groupIdx <- dataList$groupIdxFromGroupName(x)
      samples <- dataList$dataColumnsNameFunctionFromGroupName(x, sampleNamesToExclude = dataList$excludedSamples(dataList$groupSampleDataFrame))
      samples <- intersect(samples, filterObj$sampleSet)
      rep(x = groupIdx, times = length(samples))
    }))]
    
    symbolsforreplicates<-unlist(lapply(X = filterObj$grouXXXps, FUN = function(x){ 
      groupIdx <- dataList$groupIdxFromGroupName(x)
      samples <- dataList$dataColumnsNameFunctionFromGroupName(x, sampleNamesToExclude = dataList$excludedSamples(dataList$groupSampleDataFrame))
      samples <- intersect(samples, filterObj$sampleSet)
      rep(x = groupIdx, times = length(samples))
    }))
    
  } else {
    colorsForReplicates <- palette[unlist(lapply(X = filterObj$grouXXXps, FUN = function(x){ 
      groupIdx <- dataList$groupIdxFromGroupName(x)
      rep(x = groupIdx, times = length(dataList$dataColumnsNameFunctionFromGroupName(x, sampleNamesToExclude = dataList$excludedSamples(dataList$groupSampleDataFrame))))
    }))]
    
    symbolsforreplicates<-unlist(lapply(X = filterObj$grouXXXps, FUN = function(x){ 
      groupIdx <- dataList$groupIdxFromGroupName(x)
      rep(x = groupIdx, times = length(dataList$dataColumnsNameFunctionFromGroupName(x, sampleNamesToExclude = dataList$excludedSamples(dataList$groupSampleDataFrame))))
    }))
  }
  
  
  
  ## data
  dataDimOne <- pcaObj$scores[, pcaDimensionOne]
  dataDimTwo <- pcaObj$scores[, pcaDimensionTwo]
  
  ## performance
  resultObj <- getPcaPerformanceIndicator(pcaObj = pcaObj, isScores = TRUE)
  xAxisLabel <- resultObj$xAxisLabel
  yAxisLabel <- resultObj$yAxisLabel
  
  ## xlim / ylim
  xMin <- min(dataDimOne)
  xMax <- max(dataDimOne)
  yMin <- min(dataDimTwo)
  yMax <- max(dataDimTwo)
  
  if(any(is.na(c(xMin, xMax, yMin, yMax)))){
    xMin <- -1
    xMax <- 1
    yMin <- -1
    yMax <- 1
  }
  
  if(is.null(xInterval))
    xInterval <- c(xMin, xMax)
  if(is.null(yInterval))
    yInterval <- c(yMin, yMax)
  ### commenting the original
  ##par(mar=c(3 + 0.35, 3, 2, 1), mgp = c(2, 1, 0))  ## c(bottom, left, top, right)
  par(mar=c(3+0.015 , 3, 2, 1), mgp = c(2.0, 1, 0))
  plot(
    x = dataDimOne, y = dataDimTwo, 
    xlim = xInterval, ylim = yInterval, 
    xlab = xAxisLabel, ylab = yAxisLabel, main = "Scores", 
    col = colorsForReplicates, pch=symbolsforreplicates,lty=1,lwd=2, cex=1.
  )
  
  ## axis
  xInt <- xMax - xMin 
  yInt <- yMax - yMin 
  xl <- xMin - xInt
  xr <- xMax + xInt
  yl <- yMin - yInt
  yr <- yMax + yInt
  segments(x0 = xl, x1 = xr, y0 = 0, y1 = 0, col = "black", lwd = 1)
  segments(x0 = 0, x1 = 0, y0 = yl, y1 = yr, col = "black", lwd = 1)
  
  if(showScoresLabels){
    
    if(filterObj$filterBySamples){
      labels <- dataList$dataColumnsNameFunctionFromGroupNames(filterObj$grouXXXps, sampleNamesToExclude = dataList$excludedSamples(dataList$groupSampleDataFrame))
      labels <- intersect(labels, filterObj$sampleSet)
    } else {
      labels <- dataList$dataColumnsNameFunctionFromGroupNames(filterObj$grouXXXps, sampleNamesToExclude = dataList$excludedSamples(dataList$groupSampleDataFrame))
    }
    ### changing the pos= 3 from 4 and will see what happens
    graphics::text(x = dataDimOne, y = dataDimTwo, labels = labels, pos = 2)
  }
}

#######################
calcPlotPCAscores2 <- function(pcaObj, dataList, filterObj, pcaDimensionOne, pcaDimensionTwo, showScoresLabels, xInterval = NULL, yInterval = NULL){
  #### changing this to 1
  palette <- colorPaletteScores()
  #dev.new(width=15,height=15)
  if(filterObj$filterBySamples){
    colorsForReplicates <- palette[unlist(lapply(X = filterObj$grouXXXps, FUN = function(x){ 
      groupIdx <- dataList$groupIdxFromGroupName(x)
      samples <- dataList$dataColumnsNameFunctionFromGroupName(x, sampleNamesToExclude = dataList$excludedSamples(dataList$groupSampleDataFrame))
      samples <- intersect(samples, filterObj$sampleSet)
      rep(x = groupIdx, times = length(samples))
    }))]
  } else {
    colorsForReplicates <- palette[unlist(lapply(X = filterObj$grouXXXps, FUN = function(x){ 
      groupIdx <- dataList$groupIdxFromGroupName(x)
      rep(x = groupIdx, times = length(dataList$dataColumnsNameFunctionFromGroupName(x, sampleNamesToExclude = dataList$excludedSamples(dataList$groupSampleDataFrame))))
    }))]
  }
  
  ## data
  dataDimOne <- pcaObj$scores[, pcaDimensionOne]
  dataDimTwo <- pcaObj$scores[, pcaDimensionTwo]
  
  ## performance
  resultObj <- getPcaPerformanceIndicator(pcaObj = pcaObj, isScores = TRUE)
  xAxisLabel <- resultObj$xAxisLabel
  yAxisLabel <- resultObj$yAxisLabel
  
  ## xlim / ylim
  xMin <- min(dataDimOne)
  xMax <- max(dataDimOne)
  yMin <- min(dataDimTwo)
  yMax <- max(dataDimTwo)
  
  if(any(is.na(c(xMin, xMax, yMin, yMax)))){
    xMin <- -1
    xMax <- 1
    yMin <- -1
    yMax <- 1
    #### I am changing this 
    # xMin <- -0.05
    # xMax <- -0.05
    # yMin <- -0.5
    # yMax <-  -0.5
    ##############
    
  }
  
  if(is.null(xInterval))
    xInterval <- c(xMin, xMax)
  if(is.null(yInterval))
    yInterval <- c(yMin, yMax)
  #### this is the original one 
  #par(mar=c(3 + 0.35, 3, 2, 1), mgp = c(2, 1, 0))  ## c(bottom, left, top, right)
  par(mar=c(3+0.0125, 3+0.125, 2, 1), mgp = c(2, 1, 0),par(xpd=FALSE))  ## c(bottom, left, top, right)
  #par(mar=c(3,0,2,1), mgp = c(2, 1, 0))
  plot(
    x = dataDimOne, y = dataDimTwo, 
    xlim = xInterval, ylim = yInterval, 
    xlab = xAxisLabel, ylab = yAxisLabel, main = "Scores", 
    #### this is my blind test changing from 19 to 19:22
    #ntemp<-length(filterObj$grouXXXps),
    #ntemp1<-sum(ntemp,1),
    ### I am testing the filterObj$grouXXXps... This is fine .. will test the 
    col = colorsForReplicates, pch=1:length(filterObj$grouXXXps),lty=1,lwd=2,cex=1.
    ### checking the colorsForReplicates
    
  )
  
  ## axis
  xInt <- xMax - xMin
  yInt <- yMax - yMin
  xl <- xMin - xInt
  xr <- xMax + xInt
  yl <- yMin - yInt
  yr <- yMax + yInt
  ###checking what happens if i comment this...this is original 
  #segments(x0 = xl, x1 = xr, y0 = 0, y1 = 0, col = "black", lwd = 1)
  #segments(x0 = 0, x1 = 0, y0 = yl, y1 = yr, col = "black", lwd = 1)
  ##############
  
  #############
  
  if(showScoresLabels){
    
    if(filterObj$filterBySamples){
      labels <- dataList$dataColumnsNameFunctionFromGroupNames(filterObj$grouXXXps, sampleNamesToExclude = dataList$excludedSamples(dataList$groupSampleDataFrame))
      labels <- intersect(labels, filterObj$sampleSet)
    } else {
      labels <- dataList$dataColumnsNameFunctionFromGroupNames(filterObj$grouXXXps, sampleNamesToExclude = dataList$excludedSamples(dataList$groupSampleDataFrame))
    }
    graphics::text(x = dataDimOne, y = dataDimTwo, labels = labels, pos = 4)
  }
}

########################################### adding this new line 

calcPlotPCAloadings <- function(
  pcaObj, dataList, filter, 
  pcaDimensionOne, pcaDimensionTwo, 
  selectionFragmentPcaLoadingSet = NULL, selectionAnalysisPcaLoadingSet = NULL, selectionSearchPcaLoadingSet = NULL, 
  xInterval = NULL, yInterval = NULL, 
  loadingsLabels = "None", showLoadingsAbundance = FALSE,
  showLoadingsFeaturesAnnotated = TRUE, showLoadingsFeaturesUnannotated = TRUE, showLoadingsFeaturesSelected = TRUE, showLoadingsFeaturesUnselected = TRUE
){
  if(FALSE){
    pcaObj_ <<- pcaObj
    dataList_ <<- dataList
    filter__ <<- filter
    pcaDimensionOne_ <<- pcaDimensionOne
    pcaDimensionTwo_ <<- pcaDimensionTwo
    selectionFragmentPcaLoadingSet_ <<- selectionFragmentPcaLoadingSet
    selectionAnalysisPcaLoadingSet_ <<- selectionAnalysisPcaLoadingSet
    selectionSearchPcaLoadingSet_ <<- selectionSearchPcaLoadingSet
    xInterval_ <<- xInterval
    yInterval_ <<- yInterval
    loadingsLabels_ <<- loadingsLabels
    showLoadingsAbundance_ <<- showLoadingsAbundance
    showLoadingsFeaturesAnnotated_ <<- showLoadingsFeaturesAnnotated
    showLoadingsFeaturesUnannotated_ <<- showLoadingsFeaturesUnannotated
    showLoadingsFeaturesSelected_ <<- showLoadingsFeaturesSelected
    showLoadingsFeaturesUnselected_ <<- showLoadingsFeaturesUnselected
  }
  if(FALSE){
    pcaObj <- pcaObj_
    dataList <- dataList_
    filter <- filter__
    pcaDimensionOne <- pcaDimensionOne_
    pcaDimensionTwo <- pcaDimensionTwo_
    selectionFragmentPcaLoadingSet <- selectionFragmentPcaLoadingSet_
    selectionAnalysisPcaLoadingSet <- selectionAnalysisPcaLoadingSet_
    selectionSearchPcaLoadingSet <- selectionSearchPcaLoadingSet_
    xInterval <- xInterval_
    yInterval <- yInterval_
    loadingsLabels <- loadingsLabels_
    showLoadingsAbundance <- showLoadingsAbundance_
    showLoadingsFeaturesAnnotated <- showLoadingsFeaturesAnnotated_
    showLoadingsFeaturesUnannotated <- showLoadingsFeaturesUnannotated_
    showLoadingsFeaturesSelected <- showLoadingsFeaturesSelected_
    showLoadingsFeaturesUnselected <- showLoadingsFeaturesUnselected_
  }
  ###################################################
  ########## this is new line I added################
  TNF<-pcaObj$filterObj$filter_averageOriginal
  TNF1<-apply(as.data.frame(dataList$dataFrameMeasurements[, sapply(X = as.vector(pcaObj$filterObj$grouXXXps), FUN = dataList$dataMeanColumnNameFunctionFromName)]),MARGIN = 1,FUN = mean) >= as.double(TNF)
  TNF2<-names(TNF1)[unname(TNF1)]
  TNF3<-trimws(TNF2)
  TNF4<-str_squish(TNF3)
  ################################
  T1NF<-dataList$colorMatrixDataFrame
  T1NF1<-rownames(T1NF)
  T1NF2<-trimws(T1NF1)
  T1NF3<-str_squish(T1NF2)
  ###### addding this new
  if(rlang::is_empty(TNF4) || rlang::is_empty(TNF4))
  {
    #print(TNF4)
    #print("need to induce old code here")
    resultObjAnno <- getPrecursorColors(dataList, filter)
    
    ## shown loadings features
    allFeatures <- seq_len(dataList$numberOfPrecursors)
    annotatedFeatures <- which(resultObjAnno$setOfColors != "black")
    selectedLoadingsFeatures <- union(union(selectionAnalysisPcaLoadingSet, selectionFragmentPcaLoadingSet), selectionSearchPcaLoadingSet)
    filter2 <- NULL
    if(showLoadingsFeaturesAnnotated)
      ## annotated features
      filter2 <- c(filter2, annotatedFeatures)
    if(showLoadingsFeaturesUnannotated)
      ## unannotated features
      filter2 <- c(filter2, setdiff(allFeatures, annotatedFeatures))
    if(showLoadingsFeaturesSelected)
      ## selected features
      filter2 <- c(filter2, selectedLoadingsFeatures)
    if(showLoadingsFeaturesUnselected)
      ## unselected features
      filter2 <- c(filter2, setdiff(allFeatures, selectedLoadingsFeatures))
    
    filter <- intersect(filter, unique(filter2))
    
    resultObjAnno <- getPrecursorColors(dataList, filter)
    #resultObjAnno$setOfAnnotations <- resultObjAnno$setOfAnnotations[filter]
    #resultObjAnno$setOfColors      <- resultObjAnno$setOfColors[filter]
    
    ## data
    dataDimOne <- pcaObj$loadings[, pcaDimensionOne]
    dataDimTwo <- pcaObj$loadings[, pcaDimensionTwo]
    
    ## performance
    resultObj <- getPcaPerformanceIndicator(pcaObj = pcaObj, isScores = TRUE)
    xAxisLabel <- resultObj$xAxisLabel
    yAxisLabel <- resultObj$yAxisLabel
    
    ## xlim / ylim
    xMin <- min(dataDimOne)
    xMax <- max(dataDimOne)
    yMin <- min(dataDimTwo)
    yMax <- max(dataDimTwo)
    
    if(any(is.na(c(xMin, xMax, yMin, yMax)))){
      xMin <- -1
      xMax <- 1
      yMin <- -1
      yMax <- 1
    }
    
    if(is.null(xInterval))
      xInterval <- c(xMin, xMax)
    if(is.null(yInterval))
      yInterval <- c(yMin, yMax)
    
    dataDimOne <- dataDimOne[filter]
    dataDimTwo <- dataDimTwo[filter]
    selectionFragmentPcaLoadingSet <- intersect(selectionFragmentPcaLoadingSet, filter)
    selectionAnalysisPcaLoadingSet <- intersect(selectionAnalysisPcaLoadingSet, filter)
    selectionSearchPcaLoadingSet   <- intersect(selectionSearchPcaLoadingSet  , filter)
    
    numberOfPrecursors <- length(dataDimOne)
    poisX <- dataDimOne
    poisY <- dataDimTwo
    
    pointSizesAnno  <- rep(x = clusterNodePointSize0, times = numberOfPrecursors)
    pointColorsAnno <- resultObjAnno$setOfColors
    
    pointsAnalysis <- vector(mode = "logical", length = numberOfPrecursors)
    pointsAnalysis[match(x = selectionAnalysisPcaLoadingSet, table = filter)] <- TRUE
    pointsFragment <- vector(mode = "logical", length = numberOfPrecursors)
    pointsFragment[match(x = selectionFragmentPcaLoadingSet, table = filter)] <- TRUE
    pointsSearch <- vector(mode = "logical", length = numberOfPrecursors)
    pointsSearch[match(x = selectionSearchPcaLoadingSet, table = filter)] <- TRUE
    
    annotatedPoints <- pointColorsAnno != "black"
    selectedPoints  <- pointsAnalysis | pointsFragment | pointsSearch
    lv1points <-   annotatedPoints  &   selectedPoints
    lv2points <- (!annotatedPoints) &   selectedPoints
    lv3points <-   annotatedPoints  & (!selectedPoints)
    lv4points <- (!annotatedPoints) & (!selectedPoints)
    
    #poisX <- c(poisX[!annotatedPoints], poisX[annotatedPoints])
    #poisY <- c(poisY[!annotatedPoints], poisY[annotatedPoints])
    #pointSizesAnno <- c(pointSizesAnno[!annotatedPoints], pointSizesAnno[annotatedPoints])
    #pointColorsAnno <- c(pointColorsAnno[!annotatedPoints], pointColorsAnno[annotatedPoints])
    #pointsAnalysis <- c(pointsAnalysis[!annotatedPoints], pointsAnalysis[annotatedPoints])
    #pointsFragment <- c(pointsFragment[!annotatedPoints], pointsFragment[annotatedPoints])
    #pointsSearch <- c(pointsSearch[!annotatedPoints], pointsSearch[annotatedPoints])
    
    poisX           <- c(poisX          [lv4points], poisX          [lv3points], poisX          [lv2points], poisX          [lv1points])
    poisY           <- c(poisY          [lv4points], poisY          [lv3points], poisY          [lv2points], poisY          [lv1points])
    pointSizesAnno  <- c(pointSizesAnno [lv4points], pointSizesAnno [lv3points], pointSizesAnno [lv2points], pointSizesAnno [lv1points])
    pointColorsAnno <- c(pointColorsAnno[lv4points], pointColorsAnno[lv3points], pointColorsAnno[lv2points], pointColorsAnno[lv1points])
    pointsAnalysis  <- c(pointsAnalysis [lv4points], pointsAnalysis [lv3points], pointsAnalysis [lv2points], pointsAnalysis [lv1points])
    pointsFragment  <- c(pointsFragment [lv4points], pointsFragment [lv3points], pointsFragment [lv2points], pointsFragment [lv1points])
    pointsSearch    <- c(pointsSearch   [lv4points], pointsSearch   [lv3points], pointsSearch   [lv2points], pointsSearch   [lv1points])
    
    resultObjPoints <- generatePoints(
      poisX = poisX, poisY = poisY, 
      pointSizesAnno = pointSizesAnno, pointColorsAnno = pointColorsAnno, 
      pointsAnalysis = pointsAnalysis, pointsFragment = pointsFragment, pointsSearch = pointsSearch,
      pointSizeModifier = NULL
    )
    pointSizes    <- resultObjPoints$pointSizes
    pointColors   <- resultObjPoints$pointColors
    poisXpoints   <- resultObjPoints$poisXpoints
    poisYpoints   <- resultObjPoints$poisYpoints
    mappingToData <- resultObjPoints$mappingToData
    
    switch(loadingsLabels,
           "None"={## no labels
             labels <- NULL
           },
           "m/z / RT"={## mz/rt
             labels <- dataList$precursorLabels[filter]
             labels <- c(labels[lv4points], labels[lv3points], labels[lv2points], labels[lv1points])
             #labels <- c(labels[!annotatedPoints], labels[annotatedPoints])
           },
           "Metabolite name"={## name
             labels <- dataList$dataFrameInfos[filter, "Metabolite name"]
             labels <- c(labels[lv4points], labels[lv3points], labels[lv2points], labels[lv1points])
             #labels <- c(labels[!annotatedPoints], labels[annotatedPoints])
           },
           "Metabolite family"={## family
             featureFamilies <- dataList$annoArrayOfLists[filter]
             labels <- unlist(lapply(X = featureFamilies, FUN = function(x){
               ifelse(
                 test = length(x) == 0, 
                 yes = "-", 
                 no = paste(unlist(x), collapse = ", ")
               )
             }))
             labels <- c(labels[lv4points], labels[lv3points], labels[lv2points], labels[lv1points])
           },
           {## unknown state
             stop(paste("Unknown loadingsLabels value", loadingsLabels))
           }
    )## end switch
    
    ## points
    #points(x = poisXpoints, y = poisYpoints, col = pointColors, pch=19, cex=pointSizes)
    if(showLoadingsAbundance){
      precursorMeansNorm <- dataList$dataFrameMeasurements[filter, "meanAllNormed"]
      precursorMeansNorm <- c(precursorMeansNorm[lv4points], precursorMeansNorm[lv3points], precursorMeansNorm[lv2points], precursorMeansNorm[lv1points])
      #precursorMeansNorm <- c(precursorMeansNorm[!annotatedPoints], precursorMeansNorm[annotatedPoints])
      precursorMeansNorm <- precursorMeansNorm[mappingToData]
      pointSizes <- pointSizes * 2 * precursorMeansNorm
    }
    
    ############################################################################################
    ## plot
    par(mar=c(3 + 0.35, 3, 2, 1), mgp = c(2, 1, 0))  ## c(bottom, left, top, right)
    #plot(x = dataDimOne, y = dataDimTwo, xlim = xInterval, ylim = yInterval, xlab = xAxisLabel, ylab = yAxisLabel, main = "Loadings", pch=19, cex=0.7, col = nodeColors)
    plot(x = NULL, y = NULL, xlim = xInterval, ylim = yInterval, xlab = xAxisLabel, ylab = yAxisLabel, main = "Loadings")
    points(x = poisXpoints, y = poisYpoints, col = pointColors, pch=19, cex=pointSizes)
    
    ## axis
    xInt <- xMax - xMin
    yInt <- yMax - yMin
    xl <- xMin - xInt
    xr <- xMax + xInt
    yl <- yMin - yInt
    yr <- yMax + yInt
    segments(x0 = xl, x1 = xr, y0 = 0, y1 = 0, col = "black", lwd = 1)
    segments(x0 = 0, x1 = 0, y0 = yl, y1 = yr, col = "black", lwd = 1)
    
    if(all(!is.null(labels), length(labels) > 0))
      graphics::text(  x = poisX - 0.0, y = poisY + 0.0, labels = labels, pos = 4)
    
    uniqueIndeces     <- which(!duplicated(resultObjAnno$setOfAnnotations))
    uniqueAnnotations <- resultObjAnno$setOfAnnotations[uniqueIndeces]
    uniqueColors      <- resultObjAnno$setOfColors[uniqueIndeces]
    
    resultList <- list(
      setOfAnnotations = uniqueAnnotations,
      setOfColors      = uniqueColors
    )
    return(resultList)
  }else{
  #print(T1NF3)
  ###############
  Nind<-which(T1NF3 %in% TNF4)
  names(TNF4)<-Nind
  TNF5<-invert(TNF4)
  TNF6<-as.integer(unname(TNF5))
  names(TNF6)<-names(TNF5)
  TNF7<-TNF6
  ###############################
  resultObjAnno <- getPrecursorColors(dataList,TNF7)
  ####################################
  #print("enter the line ...2544")
  #print(pcaObj)
  #NGpc<-names(TNF1)
  #names(NGpc)<-seq(1,length(TNF1))
  #NGpc1<-invert(NGpc)
  #print(TNF2)
  #print(T1NF)
  #print(typeof(T1NF))
  #print(TNF1)
  #print(TNF7)
  #$annoArrayOfLists
  #T1pl<-dataList$ precursorLabels
  #T1pl1<-trimws(T1pl)
  #T1pl2<-str_squish(T1pl1)
  #names(T1pl2)<-seq(1,length(T1pl))
  #T1pl3<-invert(T1pl2)
  #T1pl4<-as.integer(unname(T1pl3))
  #names(T1pl4)<-names(T1pl3)
  ###########
  #print("entering the line ...2552")
  ##################################
  ## shown loadings features
  allFeatures <- seq_len(dataList$numberOfPrecursors)
  annotatedFeatures <- which(resultObjAnno$setOfColors != "black")
  selectedLoadingsFeatures <- union(union(selectionAnalysisPcaLoadingSet, selectionFragmentPcaLoadingSet), selectionSearchPcaLoadingSet)
  ############################################
  #print(annotatedFeatures)
  #print(resultObjAnno$setOfColors)
  #print(selectionAnalysisPcaLoadingSet)
  #print(selectionFragmentPcaLoadingSet)
  #print(selectionSearchPcaLoadingSet)
  #print(selectedLoadingsFeatures)
  #print("entering the line...2559")
  ##################################
  
  ##################################
  filter2 <- NULL
  if(showLoadingsFeaturesAnnotated)
    ########
  filter2 <- c(filter2, annotatedFeatures)
  #####
  if(showLoadingsFeaturesUnannotated)
    ########
  NsLFU<-which(allFeatures %in%  unname(annotatedFeatures))
  #####
  filter2 <- c(filter2, setdiff(allFeatures, annotatedFeatures))
  #######################
  #########################
  if(showLoadingsFeaturesSelected)
    ######
  filter2 <- c(filter2, selectedLoadingsFeatures)
  ###############
  if(showLoadingsFeaturesUnselected)
    ##########
  ## unselected features
  filter2 <- c(filter2, setdiff(allFeatures, selectedLoadingsFeatures))
  #######
  #############################################################
  ############## This is the original one 
  resultObjAnno <- getPrecursorColors(dataList,TNF7)
  #resultObjAnno <- getPrecursorColors(dataList, filter)
  filter <- TNF7
  ########################
  #print("entering the line ...2643")
  #print(resultObjAnno)
  ########################
  Tdf<-as.data.frame(apply(dataList$colorMatrixDataFrame, 2, unlist))
  TDF1<-Tdf[,1]
  TCol<-as.character(TDF1)
  TDval<-names(TDF1)
  TDval1<-trimws(TDval)
  TDval1<-str_squish(TDval1)
  TDval2<-TDval1
  names(TCol)<-TDval2
  #print(TCol) ## it is the dataframe Color
  #####################
  #print(union(colnames(dataList$colorMatrixDataFrame)))
  ##############
  ## data
  dataDimOne <- pcaObj$loadings[, pcaDimensionOne]
  dataDimTwo <- pcaObj$loadings[, pcaDimensionTwo]
  ###################### This is the one i am adding
  #print("entering the line ...2674")
  dataDimOne1 <- dataDimOne 
  dataDimTwo1 <-  dataDimTwo 
  #################
  #print(dataDimOne1)
  #print(dataDimTwo1)
  #print(typeof(dataDimOne1))
  #print(typeof(dataDimTwo1))
  #print(names(dataDimOne1))
  #print(names(dataDimTwo1))
  #########################
  dataDimOne2 <- str_squish(trimws(names(dataDimOne1)))
  names(dataDimOne2)<-as.double(unname(dataDimOne1))
  dataDimOne3 <- invert(dataDimOne2)
  #############
  #print("entering the line ... 2634")
  #print(dataDimOne2)
  #print(dataDimOne3)
  ###########
  dataDimOne4 <- str_squish(trimws(names(dataDimTwo1)))
  names(dataDimOne4)<-as.double(unname(dataDimTwo1))
  dataDimOne5 <- invert(dataDimOne4)
  #####################################################
  ## performance
  resultObj <- getPcaPerformanceIndicator(pcaObj = pcaObj, isScores = TRUE)
  #print(resultObj)
  ##########
  xAxisLabel <- resultObj$xAxisLabel
  yAxisLabel <- resultObj$yAxisLabel
  #################### 
  ## xlim / ylim
  xMin <- min(dataDimOne)
  xMax <- max(dataDimOne)
  yMin <- min(dataDimTwo)
  yMax <- max(dataDimTwo)
  ##################### 
  if(any(is.na(c(xMin, xMax, yMin, yMax)))){
    xMin <- -1
    xMax <- 1
    yMin <- -1
    yMax <- 1
  }
  ####################### 
  if(is.null(xInterval))
    xInterval <- c(xMin, xMax)
  if(is.null(yInterval))
    yInterval <- c(yMin, yMax)
  ################# 
  #print(dataDimOne)
  #print(TNF7)
  ########## This is change ###########
  d1ataDimOne1 <-dataDimOne[which(names(dataDimOne3) %in% names(TNF7))]
  d1ataDimTwo1<-dataDimTwo[which(names(dataDimOne5) %in% names(TNF7))]
  ########## This is the I need to test
  #print(d1ataDimOne1)
  #print(TNF7[which(names(TNF7) %in% names(dataDimOne3))])
  TNF8<-TNF7[which(names(TNF7) %in% names(dataDimOne3))]
  resultObjAnno1 <- getPrecursorColors(dataList,TNF8)
  ###############
  #print(TNF8)
  #print(length(TNF8))
  #print(TNF7)
  #print(length(TNF7))
  ####################################################
  selectionFragmentPcaLoadingSet <- intersect(selectionFragmentPcaLoadingSet, filter)
  selectionAnalysisPcaLoadingSet <- intersect(selectionAnalysisPcaLoadingSet, filter)
  selectionSearchPcaLoadingSet   <- intersect(selectionSearchPcaLoadingSet  , filter)
  ###################################################
  numberOfPrecursors <- length(dataDimOne)
  ### This is Original
  #poisX <- dataDimOne
  #poisY <- dataDimTwo
  #################
  poisX <- d1ataDimOne1
  poisY <- d1ataDimTwo1
  ###############################
  pointSizesAnno  <- rep(x = clusterNodePointSize0, times = numberOfPrecursors)
  ##### this is original one 
  #pointColorsAnno <- resultObjAnno$setOfColors
  pointColorsAnno <- resultObjAnno1$setOfColors
  print("entering the line ...2686")
  #print(pointColorsAnno)
  #print(length(pointColorsAnno))
  ############################
  ####################################################
  pointsAnalysis <- vector(mode = "logical", length = numberOfPrecursors)
  pointsAnalysis[match(x = selectionAnalysisPcaLoadingSet, table = filter)] <- TRUE
  pointsFragment <- vector(mode = "logical", length = numberOfPrecursors)
  pointsFragment[match(x = selectionFragmentPcaLoadingSet, table = filter)] <- TRUE
  pointsSearch <- vector(mode = "logical", length = numberOfPrecursors)
  pointsSearch[match(x = selectionSearchPcaLoadingSet, table = filter)] <- TRUE
  ######################################
  annotatedPoints <- pointColorsAnno != "black"
  selectedPoints  <- pointsAnalysis | pointsFragment | pointsSearch
  ####################################
  #print("entering the line ...2762")
  
  lv1points <-   annotatedPoints  &   selectedPoints
  lv2points <- (!annotatedPoints) &   selectedPoints
  lv3points <-   annotatedPoints  & (!selectedPoints)
  lv4points <- (!annotatedPoints) & (!selectedPoints)
  
  ##############################
  poisX           <- c(poisX          [lv4points], poisX          [lv3points], poisX          [lv2points], poisX          [lv1points])
  poisY           <- c(poisY          [lv4points], poisY          [lv3points], poisY          [lv2points], poisY          [lv1points])
  pointSizesAnno  <- c(pointSizesAnno [lv4points], pointSizesAnno [lv3points], pointSizesAnno [lv2points], pointSizesAnno [lv1points])
  pointColorsAnno <- c(pointColorsAnno[lv4points], pointColorsAnno[lv3points], pointColorsAnno[lv2points], pointColorsAnno[lv1points])
  pointsAnalysis  <- c(pointsAnalysis [lv4points], pointsAnalysis [lv3points], pointsAnalysis [lv2points], pointsAnalysis [lv1points])
  pointsFragment  <- c(pointsFragment [lv4points], pointsFragment [lv3points], pointsFragment [lv2points], pointsFragment [lv1points])
  pointsSearch    <- c(pointsSearch   [lv4points], pointsSearch   [lv3points], pointsSearch   [lv2points], pointsSearch   [lv1points])
  ##############
  resultObjPoints <- generatePoints(
    poisX = poisX, poisY = poisY, 
    pointSizesAnno = pointSizesAnno, pointColorsAnno = pointColorsAnno, 
    pointsAnalysis = pointsAnalysis, pointsFragment = pointsFragment, pointsSearch = pointsSearch,
    pointSizeModifier = NULL
  )
  #####################
  pointSizes    <- resultObjPoints$pointSizes
  pointColors   <- resultObjPoints$pointColors
  poisXpoints   <- resultObjPoints$poisXpoints
  poisYpoints   <- resultObjPoints$poisYpoints
  mappingToData <- resultObjPoints$mappingToData
  ############
  switch(loadingsLabels,
         "None"={## no labels
           labels <- NULL
         },
         "m/z / RT"={## mz/rt
           labels <- dataList$precursorLabels[filter]
           labels <- c(labels[lv4points], labels[lv3points], labels[lv2points], labels[lv1points])
           #labels <- c(labels[!annotatedPoints], labels[annotatedPoints])
         },
         "Metabolite name"={## name
           labels <- dataList$dataFrameInfos[filter, "Metabolite name"]
           labels <- c(labels[lv4points], labels[lv3points], labels[lv2points], labels[lv1points])
           #labels <- c(labels[!annotatedPoints], labels[annotatedPoints])
         },
         "Metabolite family"={## family
           featureFamilies <- dataList$annoArrayOfLists[filter]
           labels <- unlist(lapply(X = featureFamilies, FUN = function(x){
             ifelse(
               test = length(x) == 0, 
               yes = "-", 
               no = paste(unlist(x), collapse = ", ")
             )
           }))
           labels <- c(labels[lv4points], labels[lv3points], labels[lv2points], labels[lv1points])
         },
         {## unknown state
           stop(paste("Unknown loadingsLabels value", loadingsLabels))
         }
  )## end switch
  
  ## points###########
  #points(x = poisXpoints, y = poisYpoints, col = pointColors, pch=19, cex=pointSizes)
  if(showLoadingsAbundance){
    precursorMeansNorm <- dataList$dataFrameMeasurements[filter, "meanAllNormed"]
    precursorMeansNorm <- c(precursorMeansNorm[lv4points], precursorMeansNorm[lv3points], precursorMeansNorm[lv2points], precursorMeansNorm[lv1points])
    #precursorMeansNorm <- c(precursorMeansNorm[!annotatedPoints], precursorMeansNorm[annotatedPoints])
    precursorMeansNorm <- precursorMeansNorm[mappingToData]
    pointSizes <- pointSizes * 2 * precursorMeansNorm
  }
  
  ############################################################################################
  ## plot
  ### commenting the original value for the par
  ##par(mar=c(3 + 0.35, 3, 2, 1), mgp = c(2, 1, 0))  ## c(bottom, left, top, right)
  par(mar=c(3+0.15 , 3, 2, 1), mgp = c(2.0, 1, 0))
  
  #plot(x = dataDimOne, y = dataDimTwo, xlim = xInterval, ylim = yInterval, xlab = xAxisLabel, ylab = yAxisLabel, main = "Loadings", pch=19, cex=0.7, col = nodeColors)
  plot(x = NULL, y = NULL, xlim = xInterval, ylim = yInterval, xlab = xAxisLabel, ylab = yAxisLabel, main = "Loadings")
  points(x = poisXpoints, y = poisYpoints, col = pointColors, pch=19, cex=pointSizes)
  
  ## axis
  ### changing 
  #xInt <- xMax - xMin
  #yInt <- yMax - yMin
  xInt <- xMax - xMin
  yInt <- yMax - yMin
  xl <- xMin - xInt
  xr <- xMax + xInt
  yl <- yMin - yInt
  yr <- yMax + yInt
  segments(x0 = xl, x1 = xr, y0 = 0, y1 = 0, col = "black", lwd = 1)
  segments(x0 = 0, x1 = 0, y0 = yl, y1 = yr, col = "black", lwd = 1)
  
  if(all(!is.null(labels), length(labels) > 0))
    ### changing pos = 4 to pos =3 
    graphics::text(  x = poisX - 0.0, y = poisY + 0.0, labels = labels, pos = 2)
  
  uniqueIndeces     <- which(!duplicated(resultObjAnno$setOfAnnotations))
  uniqueAnnotations <- resultObjAnno$setOfAnnotations[uniqueIndeces]
  uniqueColors      <- resultObjAnno$setOfColors[uniqueIndeces]
  
  resultList <- list(
    setOfAnnotations = uniqueAnnotations,
    setOfColors      = uniqueColors
  )
  return(resultList)
  }  ### enter the line
}

###########################################
# calcPlotPCAloadings <- function(
#   pcaObj, dataList, filter, 
#   pcaDimensionOne, pcaDimensionTwo, 
#   selectionFragmentPcaLoadingSet = NULL, selectionAnalysisPcaLoadingSet = NULL, selectionSearchPcaLoadingSet = NULL, 
#   xInterval = NULL, yInterval = NULL, 
#   loadingsLabels = "None", showLoadingsAbundance = FALSE,
#   showLoadingsFeaturesAnnotated = TRUE, showLoadingsFeaturesUnannotated = TRUE, showLoadingsFeaturesSelected = TRUE, showLoadingsFeaturesUnselected = TRUE
# ){
#   if(FALSE){
#     pcaObj_ <<- pcaObj
#     dataList_ <<- dataList
#     filter__ <<- filter
#     pcaDimensionOne_ <<- pcaDimensionOne
#     pcaDimensionTwo_ <<- pcaDimensionTwo
#     selectionFragmentPcaLoadingSet_ <<- selectionFragmentPcaLoadingSet
#     selectionAnalysisPcaLoadingSet_ <<- selectionAnalysisPcaLoadingSet
#     selectionSearchPcaLoadingSet_ <<- selectionSearchPcaLoadingSet
#     xInterval_ <<- xInterval
#     yInterval_ <<- yInterval
#     loadingsLabels_ <<- loadingsLabels
#     showLoadingsAbundance_ <<- showLoadingsAbundance
#     showLoadingsFeaturesAnnotated_ <<- showLoadingsFeaturesAnnotated
#     showLoadingsFeaturesUnannotated_ <<- showLoadingsFeaturesUnannotated
#     showLoadingsFeaturesSelected_ <<- showLoadingsFeaturesSelected
#     showLoadingsFeaturesUnselected_ <<- showLoadingsFeaturesUnselected
#   }
#   if(FALSE){
#     pcaObj <- pcaObj_
#     dataList <- dataList_
#     filter <- filter__
#     pcaDimensionOne <- pcaDimensionOne_
#     pcaDimensionTwo <- pcaDimensionTwo_
#     selectionFragmentPcaLoadingSet <- selectionFragmentPcaLoadingSet_
#     selectionAnalysisPcaLoadingSet <- selectionAnalysisPcaLoadingSet_
#     selectionSearchPcaLoadingSet <- selectionSearchPcaLoadingSet_
#     xInterval <- xInterval_
#     yInterval <- yInterval_
#     loadingsLabels <- loadingsLabels_
#     showLoadingsAbundance <- showLoadingsAbundance_
#     showLoadingsFeaturesAnnotated <- showLoadingsFeaturesAnnotated_
#     showLoadingsFeaturesUnannotated <- showLoadingsFeaturesUnannotated_
#     showLoadingsFeaturesSelected <- showLoadingsFeaturesSelected_
#     showLoadingsFeaturesUnselected <- showLoadingsFeaturesUnselected_
#   }
#   ###################################################
#   ########## this is new line I added################
#   TNF<-pcaObj$filterObj$filter_averageOriginal
#   print("enter the line ...line 2524")
#   TNF1<-apply(as.data.frame(dataList$dataFrameMeasurements[, sapply(X = as.vector(pcaObj$filterObj$grouXXXps), FUN = dataList$dataMeanColumnNameFunctionFromName)]),MARGIN = 1,FUN = mean) >= as.double(TNF)
#   TNF2<-names(TNF1)[unname(TNF1)]
#   TNF3<-trimws(TNF2)
#   TNF4<-str_squish(TNF3)
#   #print(TNF4)
#   #print(rlang::is_empty(TNF4))
#   ################################
#   T1NF<-dataList$colorMatrixDataFrame
#   T1NF1<-rownames(T1NF)
#   T1NF2<-trimws(T1NF1)
#   T1NF3<-str_squish(T1NF2)
#   #print(T1NF3)
#   #print(rlang::is_empty(T1NF3))
#   ###############
#   Nind<-which(T1NF3 %in% TNF4)
#   names(TNF4)<-Nind
#   TNF5<-invert(TNF4)
#   TNF6<-as.integer(unname(TNF5))
#   names(TNF6)<-names(TNF5)
#   TNF7<-TNF6
#   ###############################
#   resultObjAnno <- getPrecursorColors(dataList,TNF7)
#   ####################################
#   #print("enter the line ...2544")
#   #print(pcaObj)
#   #NGpc<-names(TNF1)
#   #names(NGpc)<-seq(1,length(TNF1))
#   #NGpc1<-invert(NGpc)
#   #print(TNF2)
#   #print(T1NF)
#   #print(typeof(T1NF))
#   #print(TNF1)
#   #print(TNF7)
#   #$annoArrayOfLists
#   #T1pl<-dataList$ precursorLabels
#   #T1pl1<-trimws(T1pl)
#   #T1pl2<-str_squish(T1pl1)
#   #names(T1pl2)<-seq(1,length(T1pl))
#   #T1pl3<-invert(T1pl2)
#   #T1pl4<-as.integer(unname(T1pl3))
#   #names(T1pl4)<-names(T1pl3)
#   ###########
#   #print("entering the line ...2552")
#   ##################################
#   ## shown loadings features
#   allFeatures <- seq_len(dataList$numberOfPrecursors)
#   annotatedFeatures <- which(resultObjAnno$setOfColors != "black")
#   selectedLoadingsFeatures <- union(union(selectionAnalysisPcaLoadingSet, selectionFragmentPcaLoadingSet), selectionSearchPcaLoadingSet)
#   ############################################
#   #print(annotatedFeatures)
#   #print(resultObjAnno$setOfColors)
#   #print(selectionAnalysisPcaLoadingSet)
#   #print(selectionFragmentPcaLoadingSet)
#   #print(selectionSearchPcaLoadingSet)
#   #print(selectedLoadingsFeatures)
#   #print("entering the line...2559")
#   ##################################
#  
#   ##################################
#   filter2 <- NULL
#   if(showLoadingsFeaturesAnnotated)
#     ########
#     filter2 <- c(filter2, annotatedFeatures)
#     #####
#   if(showLoadingsFeaturesUnannotated)
#     ########
#     NsLFU<-which(allFeatures %in%  unname(annotatedFeatures))
#     #####
#     filter2 <- c(filter2, setdiff(allFeatures, annotatedFeatures))
#     #######################
#     #########################
#   if(showLoadingsFeaturesSelected)
#     ######
#     filter2 <- c(filter2, selectedLoadingsFeatures)
#     ###############
#   if(showLoadingsFeaturesUnselected)
#     ##########
#     ## unselected features
#     filter2 <- c(filter2, setdiff(allFeatures, selectedLoadingsFeatures))
#     #######
# #############################################################
#   ############## This is the original one 
#   resultObjAnno <- getPrecursorColors(dataList,TNF7)
#   #resultObjAnno <- getPrecursorColors(dataList, filter)
#   filter <- TNF7
#   ########################
#   #print("entering the line ...2643")
#   #print(resultObjAnno)
#   ########################
#   Tdf<-as.data.frame(apply(dataList$colorMatrixDataFrame, 2, unlist))
#   TDF1<-Tdf[,1]
#   TCol<-as.character(TDF1)
#   TDval<-names(TDF1)
#   TDval1<-trimws(TDval)
#   TDval1<-str_squish(TDval1)
#   TDval2<-TDval1
#   names(TCol)<-TDval2
#   #print(TCol) ## it is the dataframe Color
#   #####################
#   #print(union(colnames(dataList$colorMatrixDataFrame)))
#   ##############
#   ## data
#   dataDimOne <- pcaObj$loadings[, pcaDimensionOne]
#   dataDimTwo <- pcaObj$loadings[, pcaDimensionTwo]
#   ###################### This is the one i am adding
#   #print("entering the line ...2674")
#   dataDimOne1 <- dataDimOne 
#   dataDimTwo1 <-  dataDimTwo 
#   #################
#   #print(dataDimOne1)
#   #print(dataDimTwo1)
#   #print(typeof(dataDimOne1))
#   #print(typeof(dataDimTwo1))
#   #print(names(dataDimOne1))
#   #print(names(dataDimTwo1))
#   dD1<-checkmate::test_numeric(dataDimOne1, names = "named")
#   dD2<-checkmate::test_numeric(dataDimTwo1, names = "named")
#   #########################
#   if(dD1 & dD2 ) {
#   dataDimOne2 <- str_squish(trimws(names(dataDimOne1)))
#   names(dataDimOne2)<-as.double(unname(dataDimOne1))
#   dataDimOne3 <- invert(dataDimOne2)
#   #########################
#   #print("entering the line ... 2634")
#   #print(dataDimOne2)
#   #print(dataDimOne3)
#   ###########
#   dataDimOne4 <- str_squish(trimws(names(dataDimTwo1)))
#   names(dataDimOne4)<-as.double(unname(dataDimTwo1))
#   dataDimOne5 <- invert(dataDimOne4)
#   #####################################################
#   ## performance
#   resultObj <- getPcaPerformanceIndicator(pcaObj = pcaObj, isScores = TRUE)
#   #print(resultObj)
#   ##########
#   xAxisLabel <- resultObj$xAxisLabel
#   yAxisLabel <- resultObj$yAxisLabel
#  #################### 
#   ## xlim / ylim
#   xMin <- min(dataDimOne)
#   xMax <- max(dataDimOne)
#   yMin <- min(dataDimTwo)
#   yMax <- max(dataDimTwo)
#  ##################### 
#   if(any(is.na(c(xMin, xMax, yMin, yMax)))){
#     xMin <- -1
#     xMax <- 1
#     yMin <- -1
#     yMax <- 1
#   }
#  ####################### 
#   if(is.null(xInterval))
#     xInterval <- c(xMin, xMax)
#   if(is.null(yInterval))
#     yInterval <- c(yMin, yMax)
#  ################# 
#   #print(dataDimOne)
#   #print(TNF7)
#   ########## This is change ###########
#   d1ataDimOne1 <-dataDimOne[which(names(dataDimOne3) %in% names(TNF7))]
#   d1ataDimTwo1<-dataDimTwo[which(names(dataDimOne5) %in% names(TNF7))]
#   ########## This is the I need to test
#   #print(d1ataDimOne1)
#   #print(TNF7[which(names(TNF7) %in% names(dataDimOne3))])
#   TNF8<-TNF7[which(names(TNF7) %in% names(dataDimOne3))]
#   resultObjAnno1 <- getPrecursorColors(dataList,TNF8)
#   ###############
#   #print(TNF8)
#   #print(length(TNF8))
#   #print(TNF7)
#   #print(length(TNF7))
#   ####################################################
#   selectionFragmentPcaLoadingSet <- intersect(selectionFragmentPcaLoadingSet, filter)
#   selectionAnalysisPcaLoadingSet <- intersect(selectionAnalysisPcaLoadingSet, filter)
#   selectionSearchPcaLoadingSet   <- intersect(selectionSearchPcaLoadingSet  , filter)
#   ###################################################
#   numberOfPrecursors <- length(dataDimOne)
#   ### This is Original
#   #poisX <- dataDimOne
#   #poisY <- dataDimTwo
#   #################
#   poisX <- d1ataDimOne1
#   poisY <- d1ataDimTwo1
#   ###############################
#   pointSizesAnno  <- rep(x = clusterNodePointSize0, times = numberOfPrecursors)
#   ##### this is original one 
#   #pointColorsAnno <- resultObjAnno$setOfColors
#   pointColorsAnno <- resultObjAnno1$setOfColors
#   print("entering the line ...2686")
#   #print(pointColorsAnno)
#   #print(length(pointColorsAnno))
#   ############################
#   ####################################################
#   pointsAnalysis <- vector(mode = "logical", length = numberOfPrecursors)
#   pointsAnalysis[match(x = selectionAnalysisPcaLoadingSet, table = filter)] <- TRUE
#   pointsFragment <- vector(mode = "logical", length = numberOfPrecursors)
#   pointsFragment[match(x = selectionFragmentPcaLoadingSet, table = filter)] <- TRUE
#   pointsSearch <- vector(mode = "logical", length = numberOfPrecursors)
#   pointsSearch[match(x = selectionSearchPcaLoadingSet, table = filter)] <- TRUE
#   ######################################
#   annotatedPoints <- pointColorsAnno != "black"
#   selectedPoints  <- pointsAnalysis | pointsFragment | pointsSearch
#   ####################################
#   #print("entering the line ...2762")
#   
#   lv1points <-   annotatedPoints  &   selectedPoints
#   lv2points <- (!annotatedPoints) &   selectedPoints
#   lv3points <-   annotatedPoints  & (!selectedPoints)
#   lv4points <- (!annotatedPoints) & (!selectedPoints)
#   
#   ##############################
#   poisX           <- c(poisX          [lv4points], poisX          [lv3points], poisX          [lv2points], poisX          [lv1points])
#   poisY           <- c(poisY          [lv4points], poisY          [lv3points], poisY          [lv2points], poisY          [lv1points])
#   pointSizesAnno  <- c(pointSizesAnno [lv4points], pointSizesAnno [lv3points], pointSizesAnno [lv2points], pointSizesAnno [lv1points])
#   pointColorsAnno <- c(pointColorsAnno[lv4points], pointColorsAnno[lv3points], pointColorsAnno[lv2points], pointColorsAnno[lv1points])
#   pointsAnalysis  <- c(pointsAnalysis [lv4points], pointsAnalysis [lv3points], pointsAnalysis [lv2points], pointsAnalysis [lv1points])
#   pointsFragment  <- c(pointsFragment [lv4points], pointsFragment [lv3points], pointsFragment [lv2points], pointsFragment [lv1points])
#   pointsSearch    <- c(pointsSearch   [lv4points], pointsSearch   [lv3points], pointsSearch   [lv2points], pointsSearch   [lv1points])
#   ##############
#   resultObjPoints <- generatePoints(
#     poisX = poisX, poisY = poisY, 
#     pointSizesAnno = pointSizesAnno, pointColorsAnno = pointColorsAnno, 
#     pointsAnalysis = pointsAnalysis, pointsFragment = pointsFragment, pointsSearch = pointsSearch,
#     pointSizeModifier = NULL
#   )
#   #####################
#   pointSizes    <- resultObjPoints$pointSizes
#   pointColors   <- resultObjPoints$pointColors
#   poisXpoints   <- resultObjPoints$poisXpoints
#   poisYpoints   <- resultObjPoints$poisYpoints
#   mappingToData <- resultObjPoints$mappingToData
#   ############
#   switch(loadingsLabels,
#          "None"={## no labels
#            labels <- NULL
#          },
#          "m/z / RT"={## mz/rt
#            labels <- dataList$precursorLabels[filter]
#            labels <- c(labels[lv4points], labels[lv3points], labels[lv2points], labels[lv1points])
#            #labels <- c(labels[!annotatedPoints], labels[annotatedPoints])
#          },
#          "Metabolite name"={## name
#            labels <- dataList$dataFrameInfos[filter, "Metabolite name"]
#            labels <- c(labels[lv4points], labels[lv3points], labels[lv2points], labels[lv1points])
#            #labels <- c(labels[!annotatedPoints], labels[annotatedPoints])
#          },
#          "Metabolite family"={## family
#            featureFamilies <- dataList$annoArrayOfLists[filter]
#            labels <- unlist(lapply(X = featureFamilies, FUN = function(x){
#              ifelse(
#                test = length(x) == 0, 
#                yes = "-", 
#                no = paste(unlist(x), collapse = ", ")
#              )
#            }))
#            labels <- c(labels[lv4points], labels[lv3points], labels[lv2points], labels[lv1points])
#          },
#          {## unknown state
#            stop(paste("Unknown loadingsLabels value", loadingsLabels))
#          }
#   )## end switch
#   
#   ## points###########
#   #points(x = poisXpoints, y = poisYpoints, col = pointColors, pch=19, cex=pointSizes)
#   if(showLoadingsAbundance){
#     precursorMeansNorm <- dataList$dataFrameMeasurements[filter, "meanAllNormed"]
#     precursorMeansNorm <- c(precursorMeansNorm[lv4points], precursorMeansNorm[lv3points], precursorMeansNorm[lv2points], precursorMeansNorm[lv1points])
#     #precursorMeansNorm <- c(precursorMeansNorm[!annotatedPoints], precursorMeansNorm[annotatedPoints])
#     precursorMeansNorm <- precursorMeansNorm[mappingToData]
#     pointSizes <- pointSizes * 2 * precursorMeansNorm
#   }
#   
#   ############################################################################################
#   ## plot
#   ### commenting the original value for the par
#   ##par(mar=c(3 + 0.35, 3, 2, 1), mgp = c(2, 1, 0))  ## c(bottom, left, top, right)
#   par(mar=c(3+0.15 , 3, 2, 1), mgp = c(2.0, 1, 0))
#   
#   #plot(x = dataDimOne, y = dataDimTwo, xlim = xInterval, ylim = yInterval, xlab = xAxisLabel, ylab = yAxisLabel, main = "Loadings", pch=19, cex=0.7, col = nodeColors)
#   plot(x = NULL, y = NULL, xlim = xInterval, ylim = yInterval, xlab = xAxisLabel, ylab = yAxisLabel, main = "Loadings")
#   points(x = poisXpoints, y = poisYpoints, col = pointColors, pch=19, cex=pointSizes)
#   
#   ## axis
#   ### changing 
#   #xInt <- xMax - xMin
#   #yInt <- yMax - yMin
#   xInt <- xMax - xMin
#   yInt <- yMax - yMin
#   xl <- xMin - xInt
#   xr <- xMax + xInt
#   yl <- yMin - yInt
#   yr <- yMax + yInt
#   segments(x0 = xl, x1 = xr, y0 = 0, y1 = 0, col = "black", lwd = 1)
#   segments(x0 = 0, x1 = 0, y0 = yl, y1 = yr, col = "black", lwd = 1)
#   
#   if(all(!is.null(labels), length(labels) > 0))
#     ### changing pos = 4 to pos =3 
#     graphics::text(  x = poisX - 0.0, y = poisY + 0.0, labels = labels, pos = 2)
#   
#   uniqueIndeces     <- which(!duplicated(resultObjAnno$setOfAnnotations))
#   uniqueAnnotations <- resultObjAnno$setOfAnnotations[uniqueIndeces]
#   uniqueColors      <- resultObjAnno$setOfColors[uniqueIndeces]
#   
#   resultList <- list(
#     setOfAnnotations = uniqueAnnotations,
#     setOfColors      = uniqueColors
#   )
#   return(resultList)
#   #### this is my check
#   } else {
#     
#     ## performance
#     resultObj <- getPcaPerformanceIndicator(pcaObj = pcaObj, isScores = TRUE)
#     xAxisLabel <- resultObj$xAxisLabel
#     yAxisLabel <- resultObj$yAxisLabel
#     
#     ## xlim / ylim
#     xMin <- min(dataDimOne)
#     xMax <- max(dataDimOne)
#     yMin <- min(dataDimTwo)
#     yMax <- max(dataDimTwo)
#     
#     if(any(is.na(c(xMin, xMax, yMin, yMax)))){
#       xMin <- -1
#       xMax <- 1
#       yMin <- -1
#       yMax <- 1
#     }
#     
#     if(is.null(xInterval))
#       xInterval <- c(xMin, xMax)
#     if(is.null(yInterval))
#       yInterval <- c(yMin, yMax)
#     
#     dataDimOne <- dataDimOne[filter]
#     dataDimTwo <- dataDimTwo[filter]
#     selectionFragmentPcaLoadingSet <- intersect(selectionFragmentPcaLoadingSet, filter)
#     selectionAnalysisPcaLoadingSet <- intersect(selectionAnalysisPcaLoadingSet, filter)
#     selectionSearchPcaLoadingSet   <- intersect(selectionSearchPcaLoadingSet  , filter)
#     
#     numberOfPrecursors <- length(dataDimOne)
#     poisX <- dataDimOne
#     poisY <- dataDimTwo
#     
#     pointSizesAnno  <- rep(x = clusterNodePointSize0, times = numberOfPrecursors)
#     pointColorsAnno <- resultObjAnno$setOfColors
#     
#     pointsAnalysis <- vector(mode = "logical", length = numberOfPrecursors)
#     pointsAnalysis[match(x = selectionAnalysisPcaLoadingSet, table = filter)] <- TRUE
#     pointsFragment <- vector(mode = "logical", length = numberOfPrecursors)
#     pointsFragment[match(x = selectionFragmentPcaLoadingSet, table = filter)] <- TRUE
#     pointsSearch <- vector(mode = "logical", length = numberOfPrecursors)
#     pointsSearch[match(x = selectionSearchPcaLoadingSet, table = filter)] <- TRUE
#     
#     annotatedPoints <- pointColorsAnno != "black"
#     selectedPoints  <- pointsAnalysis | pointsFragment | pointsSearch
#     lv1points <-   annotatedPoints  &   selectedPoints
#     lv2points <- (!annotatedPoints) &   selectedPoints
#     lv3points <-   annotatedPoints  & (!selectedPoints)
#     lv4points <- (!annotatedPoints) & (!selectedPoints)
#     
#     #poisX <- c(poisX[!annotatedPoints], poisX[annotatedPoints])
#     #poisY <- c(poisY[!annotatedPoints], poisY[annotatedPoints])
#     #pointSizesAnno <- c(pointSizesAnno[!annotatedPoints], pointSizesAnno[annotatedPoints])
#     #pointColorsAnno <- c(pointColorsAnno[!annotatedPoints], pointColorsAnno[annotatedPoints])
#     #pointsAnalysis <- c(pointsAnalysis[!annotatedPoints], pointsAnalysis[annotatedPoints])
#     #pointsFragment <- c(pointsFragment[!annotatedPoints], pointsFragment[annotatedPoints])
#     #pointsSearch <- c(pointsSearch[!annotatedPoints], pointsSearch[annotatedPoints])
#     
#     poisX           <- c(poisX          [lv4points], poisX          [lv3points], poisX          [lv2points], poisX          [lv1points])
#     poisY           <- c(poisY          [lv4points], poisY          [lv3points], poisY          [lv2points], poisY          [lv1points])
#     pointSizesAnno  <- c(pointSizesAnno [lv4points], pointSizesAnno [lv3points], pointSizesAnno [lv2points], pointSizesAnno [lv1points])
#     pointColorsAnno <- c(pointColorsAnno[lv4points], pointColorsAnno[lv3points], pointColorsAnno[lv2points], pointColorsAnno[lv1points])
#     pointsAnalysis  <- c(pointsAnalysis [lv4points], pointsAnalysis [lv3points], pointsAnalysis [lv2points], pointsAnalysis [lv1points])
#     pointsFragment  <- c(pointsFragment [lv4points], pointsFragment [lv3points], pointsFragment [lv2points], pointsFragment [lv1points])
#     pointsSearch    <- c(pointsSearch   [lv4points], pointsSearch   [lv3points], pointsSearch   [lv2points], pointsSearch   [lv1points])
#     
#     resultObjPoints <- generatePoints(
#       poisX = poisX, poisY = poisY, 
#       pointSizesAnno = pointSizesAnno, pointColorsAnno = pointColorsAnno, 
#       pointsAnalysis = pointsAnalysis, pointsFragment = pointsFragment, pointsSearch = pointsSearch,
#       pointSizeModifier = NULL
#     )
#     pointSizes    <- resultObjPoints$pointSizes
#     pointColors   <- resultObjPoints$pointColors
#     poisXpoints   <- resultObjPoints$poisXpoints
#     poisYpoints   <- resultObjPoints$poisYpoints
#     mappingToData <- resultObjPoints$mappingToData
#     
#     switch(loadingsLabels,
#            "None"={## no labels
#              labels <- NULL
#            },
#            "m/z / RT"={## mz/rt
#              labels <- dataList$precursorLabels[filter]
#              labels <- c(labels[lv4points], labels[lv3points], labels[lv2points], labels[lv1points])
#              #labels <- c(labels[!annotatedPoints], labels[annotatedPoints])
#            },
#            "Metabolite name"={## name
#              labels <- dataList$dataFrameInfos[filter, "Metabolite name"]
#              labels <- c(labels[lv4points], labels[lv3points], labels[lv2points], labels[lv1points])
#              #labels <- c(labels[!annotatedPoints], labels[annotatedPoints])
#            },
#            "Metabolite family"={## family
#              featureFamilies <- dataList$annoArrayOfLists[filter]
#              labels <- unlist(lapply(X = featureFamilies, FUN = function(x){
#                ifelse(
#                  test = length(x) == 0, 
#                  yes = "-", 
#                  no = paste(unlist(x), collapse = ", ")
#                )
#              }))
#              labels <- c(labels[lv4points], labels[lv3points], labels[lv2points], labels[lv1points])
#            },
#            {## unknown state
#              stop(paste("Unknown loadingsLabels value", loadingsLabels))
#            }
#     )## end switch
#     
#     ## points
#     #points(x = poisXpoints, y = poisYpoints, col = pointColors, pch=19, cex=pointSizes)
#     if(showLoadingsAbundance){
#       precursorMeansNorm <- dataList$dataFrameMeasurements[filter, "meanAllNormed"]
#       precursorMeansNorm <- c(precursorMeansNorm[lv4points], precursorMeansNorm[lv3points], precursorMeansNorm[lv2points], precursorMeansNorm[lv1points])
#       #precursorMeansNorm <- c(precursorMeansNorm[!annotatedPoints], precursorMeansNorm[annotatedPoints])
#       precursorMeansNorm <- precursorMeansNorm[mappingToData]
#       pointSizes <- pointSizes * 2 * precursorMeansNorm
#     }
#     
#     ############################################################################################
#     ## plot
#     par(mar=c(3 + 0.35, 3, 2, 1), mgp = c(2, 1, 0))  ## c(bottom, left, top, right)
#     #plot(x = dataDimOne, y = dataDimTwo, xlim = xInterval, ylim = yInterval, xlab = xAxisLabel, ylab = yAxisLabel, main = "Loadings", pch=19, cex=0.7, col = nodeColors)
#     plot(x = NULL, y = NULL, xlim = xInterval, ylim = yInterval, xlab = xAxisLabel, ylab = yAxisLabel, main = "Loadings")
#     points(x = poisXpoints, y = poisYpoints, col = pointColors, pch=19, cex=pointSizes)
#     
#     ## axis
#     xInt <- xMax - xMin
#     yInt <- yMax - yMin
#     xl <- xMin - xInt
#     xr <- xMax + xInt
#     yl <- yMin - yInt
#     yr <- yMax + yInt
#     segments(x0 = xl, x1 = xr, y0 = 0, y1 = 0, col = "black", lwd = 1)
#     segments(x0 = 0, x1 = 0, y0 = yl, y1 = yr, col = "black", lwd = 1)
#     
#     if(all(!is.null(labels), length(labels) > 0))
#       graphics::text(  x = poisX - 0.0, y = poisY + 0.0, labels = labels, pos = 4)
#     
#     uniqueIndeces     <- which(!duplicated(resultObjAnno$setOfAnnotations))
#     uniqueAnnotations <- resultObjAnno$setOfAnnotations[uniqueIndeces]
#     uniqueColors      <- resultObjAnno$setOfColors[uniqueIndeces]
#     
#     resultList <- list(
#       setOfAnnotations = uniqueAnnotations,
#       setOfColors      = uniqueColors
#     )
#     return(resultList)
#     
#     
#     
#     print("check the data file")
#   }
#   
# }

########################################################################################

# calcPlotPCAloadings <- function(
#   pcaObj, dataList, filter, 
#   pcaDimensionOne, pcaDimensionTwo, 
#   selectionFragmentPcaLoadingSet = NULL, selectionAnalysisPcaLoadingSet = NULL, selectionSearchPcaLoadingSet = NULL, 
#   xInterval = NULL, yInterval = NULL, 
#   loadingsLabels = "None", showLoadingsAbundance = FALSE,
#   showLoadingsFeaturesAnnotated = TRUE, showLoadingsFeaturesUnannotated = TRUE, showLoadingsFeaturesSelected = TRUE, showLoadingsFeaturesUnselected = TRUE
# ){
#   if(FALSE){
#     pcaObj_ <<- pcaObj
#     dataList_ <<- dataList
#     filter__ <<- filter
#     pcaDimensionOne_ <<- pcaDimensionOne
#     pcaDimensionTwo_ <<- pcaDimensionTwo
#     selectionFragmentPcaLoadingSet_ <<- selectionFragmentPcaLoadingSet
#     selectionAnalysisPcaLoadingSet_ <<- selectionAnalysisPcaLoadingSet
#     selectionSearchPcaLoadingSet_ <<- selectionSearchPcaLoadingSet
#     xInterval_ <<- xInterval
#     yInterval_ <<- yInterval
#     loadingsLabels_ <<- loadingsLabels
#     showLoadingsAbundance_ <<- showLoadingsAbundance
#     showLoadingsFeaturesAnnotated_ <<- showLoadingsFeaturesAnnotated
#     showLoadingsFeaturesUnannotated_ <<- showLoadingsFeaturesUnannotated
#     showLoadingsFeaturesSelected_ <<- showLoadingsFeaturesSelected
#     showLoadingsFeaturesUnselected_ <<- showLoadingsFeaturesUnselected
#   }
#   if(FALSE){
#     pcaObj <- pcaObj_
#     dataList <- dataList_
#     filter <- filter__
#     pcaDimensionOne <- pcaDimensionOne_
#     pcaDimensionTwo <- pcaDimensionTwo_
#     selectionFragmentPcaLoadingSet <- selectionFragmentPcaLoadingSet_
#     selectionAnalysisPcaLoadingSet <- selectionAnalysisPcaLoadingSet_
#     selectionSearchPcaLoadingSet <- selectionSearchPcaLoadingSet_
#     xInterval <- xInterval_
#     yInterval <- yInterval_
#     loadingsLabels <- loadingsLabels_
#     showLoadingsAbundance <- showLoadingsAbundance_
#     showLoadingsFeaturesAnnotated <- showLoadingsFeaturesAnnotated_
#     showLoadingsFeaturesUnannotated <- showLoadingsFeaturesUnannotated_
#     showLoadingsFeaturesSelected <- showLoadingsFeaturesSelected_
#     showLoadingsFeaturesUnselected <- showLoadingsFeaturesUnselected_
#   }
#   
#   resultObjAnno <- getPrecursorColors(dataList, filter)
#   ##############################
#   ########## this is new line I added
#   TNF<-pcaObj$filterObj$filter_averageOriginal
#   TNF1<-apply(as.data.frame(dataList$dataFrameMeasurements[, sapply(X = as.vector(pcaObj$filterObj$grouXXXps), FUN = dataList$dataMeanColumnNameFunctionFromName)]),MARGIN = 1,FUN = mean) >= as.double(TNF)
#   TNF2<-names(TNF1)[unname(TNF1)]
#   TNF3<-trimws(TNF2)
#   TNF4<-str_squish(TNF3)
#   ################################
#   T1NF<-dataList$colorMatrixDataFrame
#   T1NF1<-rownames(T1NF)
#   T1NF2<-trimws(T1NF1)
#   T1NF3<-str_squish(T1NF2)
#   #print(T1NF3)
#   ###############
#   Nind<-which(T1NF3 %in% TNF4)
#   names(TNF4)<-Nind
#   TNF5<-invert(TNF4)
#   print("entering the line ...2540")
#   print(TNF5)
#   print(filter)
#   ######
#  #print("coming to this line ...line 2326")
# #  print("printing the first filter")
#  # print(filter)
#  
#   ########################################################
#   #print(resultObjAnno)
#  # print(resultObjAnno[[1]])
#  ################################################################################ 
#   ## shown loadings features
#   allFeatures <- seq_len(dataList$numberOfPrecursors)
#   #print("coming to this line ...line 2330")
#   
#   annotatedFeatures <- which(resultObjAnno$setOfColors != "black")
#   selectedLoadingsFeatures <- union(union(selectionAnalysisPcaLoadingSet, selectionFragmentPcaLoadingSet), selectionSearchPcaLoadingSet)
#   filter2 <- NULL
#   if(showLoadingsFeaturesAnnotated)
#     ## annotated features
#     filter2 <- c(filter2, annotatedFeatures)
#   if(showLoadingsFeaturesUnannotated)
#     ## unannotated features
#     filter2 <- c(filter2, setdiff(allFeatures, annotatedFeatures))
#   if(showLoadingsFeaturesSelected)
#     ## selected features
#     filter2 <- c(filter2, selectedLoadingsFeatures)
#   if(showLoadingsFeaturesUnselected)
#     ## unselected features
#     filter2 <- c(filter2, setdiff(allFeatures, selectedLoadingsFeatures))
#   #############
#   filter <- intersect(filter, unique(filter2))
#   ###########################################
#   #print("coming to this line ...line 2347...to print the filter")
#   #print(filter)
#   ###########
#   resultObjAnno <- getPrecursorColors(dataList, filter)
#   ############
#   #print("coming to this line ...line 2350")
#   #print(resultObjAnno)
#   #resultObjAnno$setOfAnnotations <- resultObjAnno$setOfAnnotations[filter]
#   #resultObjAnno$setOfColors      <- resultObjAnno$setOfColors[filter]
#   
#   ## data
#   dataDimOne <- pcaObj$loadings[, pcaDimensionOne]
#   dataDimTwo <- pcaObj$loadings[, pcaDimensionTwo]
#   
#   ## performance
#   resultObj <- getPcaPerformanceIndicator(pcaObj = pcaObj, isScores = TRUE)
#   print("coming to this line ...line 2363")
#   
#   #print(resultObj)
#   xAxisLabel <- resultObj$xAxisLabel
#   yAxisLabel <- resultObj$yAxisLabel
#   
#   ## xlim / ylim
#   xMin <- min(dataDimOne)
#   xMax <- max(dataDimOne)
#   yMin <- min(dataDimTwo)
#   yMax <- max(dataDimTwo)
#   
#   if(any(is.na(c(xMin, xMax, yMin, yMax)))){
#     xMin <- -1
#     xMax <- 1
#     yMin <- -1
#     yMax <- 1
#   }
#   
#   if(is.null(xInterval))
#     xInterval <- c(xMin, xMax)
#   if(is.null(yInterval))
#     yInterval <- c(yMin, yMax)
#  
#   
#   dataDimOne <- dataDimOne[filter]
#   dataDimTwo <- dataDimTwo[filter]
#   
#   selectionFragmentPcaLoadingSet <- intersect(selectionFragmentPcaLoadingSet, filter)
#   selectionAnalysisPcaLoadingSet <- intersect(selectionAnalysisPcaLoadingSet, filter)
#   selectionSearchPcaLoadingSet   <- intersect(selectionSearchPcaLoadingSet  , filter)
#   
#   
#   numberOfPrecursors <- length(dataDimOne)
#  # print("entering the line ...2389")
#   #print(numberOfPrecursors)
#   
#   poisX <- dataDimOne
#   poisY <- dataDimTwo
#   
#   pointSizesAnno  <- rep(x = clusterNodePointSize0, times = numberOfPrecursors)
#   print("entering the line ...2399")
#  # print(pointSizesAnno)
#   ### this is area that I need to focous
#   pointColorsAnno <- resultObjAnno$setOfColors
#   print("entering the line ...2402")
#   #print(pointColorsAnno)
#   
#   pointsAnalysis <- vector(mode = "logical", length = numberOfPrecursors)
#   pointsAnalysis[match(x = selectionAnalysisPcaLoadingSet, table = filter)] <- TRUE
#   pointsFragment <- vector(mode = "logical", length = numberOfPrecursors)
#   pointsFragment[match(x = selectionFragmentPcaLoadingSet, table = filter)] <- TRUE
#   pointsSearch <- vector(mode = "logical", length = numberOfPrecursors)
#   pointsSearch[match(x = selectionSearchPcaLoadingSet, table = filter)] <- TRUE
#   
#   
#   annotatedPoints <- pointColorsAnno != "black"
#   selectedPoints  <- pointsAnalysis | pointsFragment | pointsSearch
#   print("entering this line ..2418")
#   lv1points <-   annotatedPoints  &   selectedPoints
#   print("enterng this area ...line ...2420")
#   #print(lv1points)
#   lv2points <- (!annotatedPoints) &   selectedPoints
#   print("enterng this area ...line ...2422")
#   #print(lv2points)
#   lv3points <-   annotatedPoints  & (!selectedPoints)
#   print("enterng this area ...line ...2426")
#   #print(lv3points)
#   lv4points <- (!annotatedPoints) & (!selectedPoints)
#   print("enterng this area ...line ...2429")
#   #print(lv4points)
#   
#   #poisX <- c(poisX[!annotatedPoints], poisX[annotatedPoints])
#   #poisY <- c(poisY[!annotatedPoints], poisY[annotatedPoints])
#   #pointSizesAnno <- c(pointSizesAnno[!annotatedPoints], pointSizesAnno[annotatedPoints])
#   #pointColorsAnno <- c(pointColorsAnno[!annotatedPoints], pointColorsAnno[annotatedPoints])
#   #pointsAnalysis <- c(pointsAnalysis[!annotatedPoints], pointsAnalysis[annotatedPoints])
#   #pointsFragment <- c(pointsFragment[!annotatedPoints], pointsFragment[annotatedPoints])
#   #pointsSearch <- c(pointsSearch[!annotatedPoints], pointsSearch[annotatedPoints])
#   
#   poisX           <- c(poisX          [lv4points], poisX          [lv3points], poisX          [lv2points], poisX          [lv1points])
#   print("entering this line ..2440")
#   #print(poisX)
#   poisY           <- c(poisY          [lv4points], poisY          [lv3points], poisY          [lv2points], poisY          [lv1points])
#   print("entering this line ..2444")
#   #print(poisY)
#   pointSizesAnno  <- c(pointSizesAnno [lv4points], pointSizesAnno [lv3points], pointSizesAnno [lv2points], pointSizesAnno [lv1points])
#   print("entering this line ..2433")
#   #print(pointSizesAnno)
#   #print(lv4points)
#   #print(lv3points)
#   #print(lv2points)
#   pointColorsAnno <- c(pointColorsAnno[lv4points], pointColorsAnno[lv3points], pointColorsAnno[lv2points], pointColorsAnno[lv1points])
#   print("entering this line ..2436")
#   #print(pointColorsAnno)
#   #print(lv4points)
#   #print(lv3points)
#   #print(lv2points)
#   #print(lv1points)
#   pointsAnalysis  <- c(pointsAnalysis [lv4points], pointsAnalysis [lv3points], pointsAnalysis [lv2points], pointsAnalysis [lv1points])
#   print("entering this line ..2459")
#   #print(pointsAnalysis )
#   pointsFragment  <- c(pointsFragment [lv4points], pointsFragment [lv3points], pointsFragment [lv2points], pointsFragment [lv1points])
#   print("entering this line ..2462")
#   #print(pointsFragment )
#   pointsSearch    <- c(pointsSearch   [lv4points], pointsSearch   [lv3points], pointsSearch   [lv2points], pointsSearch   [lv1points])
#   print("entering this line ..2466")
#   #print(pointsSearch )
#   
#   resultObjPoints <- generatePoints(
#     poisX = poisX, poisY = poisY, 
#     pointSizesAnno = pointSizesAnno, pointColorsAnno = pointColorsAnno, 
#     pointsAnalysis = pointsAnalysis, pointsFragment = pointsFragment, pointsSearch = pointsSearch,
#     pointSizeModifier = NULL
#   )
#   ####################################
#   print("entering this area ..line 2474")
#   #print(resultObjPoints)
#   pointSizes    <- resultObjPoints$pointSizes
#   #### changing the pointColors to TcolR1
#   #pointColors   <- TcolR1
#   pointColors   <- resultObjPoints$pointColors
#   poisXpoints   <- resultObjPoints$poisXpoints
#   TepoisXpoints   <-names(poisXpoints)
#   ##########################
#   print("entering this area..line 2488")
#   #print(poisXpoints)
#   #print(TepoisXpoints)
#   #print(TcolR)
#   #print(TcolR[intersect(names(TcolR),names(poisXpoints))])
#   ####### I am adding this new
#   # TCol<-TcolR[intersect(names(TcolR),names(poisXpoints))]
#   # T1Col<-poisXpoints[intersect(names(poisXpoints),names(TcolR))]
#   # TCol1<-TcolR[setdiff(names(TcolR),names(poisXpoints))]
#   # T1Col1<-poisXpoints[setdiff(names(poisXpoints),names(TcolR))]
#   # #################################
#   # TCOl2<-unname(TCol)
#   # T1COl2<-unname(T1Col)
#   # TCOl3<-unname(TCol1)
#   # T1COl3<-unname(T1Col1)
#   # #################
#   # #####################################
#   # poisYpoints   <- resultObjPoints$poisYpoints
#   # TCol4<-TcolR[intersect(names(TcolR),names(poisYpoints))]
#   # TCol5<-TcolR[setdiff(names(TcolR),names(poisYpoints))]
#   # TCOl6<-unname(TCol4)
#   # TCOl7<-unname(TCol5)
#   # #### adding this new lines
#   # TcolR<-resultObjAnno$setOfColors
#   # TcolR1<-unname(TcolR)
#   # TannR<-resultObjAnno$setOfAnnotations
#   # TannR1<-unname(TannR)
#   ###############################################
#   ### I am adding this new line
#   #print("entering this area...line 2503")
#   #print(TannR[intersect(names(TcolR),names(TannR))])
#   #print(TcolR1)
#   #print(TCOl2)
#   #print(pointColors)
#   #print(poisXpoints)
#   #print(length(pointColors))
#   #print(length(TCOl2))
#   #print(length(TcolR1))
#   #print(TCol)
#   #print(T1Col)
#   #print(TCOl2)
#   #print(length(TCOl7))
#   #print(length(TCOl2))
#   #print(length(poisYpoints))
#   #print(TCOl2)
#   #print(poisYpoints)
#  # print(length(poisXpoints))
#   #print(T1Col1)
#   #print(TCOl2)
#   #print(T1CO2)
#   #print(TCOl3)
#   #print(T1COl3)
#   #print(setequal(names(poisXpoints),names(poisYpoints)))
#   #print(length(TcolR))
#   #print(names(poisXpoints))
#   #print(names(TcolR))
#   #print(unname(TcolR))
#   #print(length(poisXpoints))
#   #print(length(poisYpoints))
#   #print(length(TCOl1))
#   ##############################################
#   mappingToData <- resultObjPoints$mappingToData
#   #############
#   #print("entering this area ..line 2485")
#   #print(dataList$precursorLabels)
#   #########################
#   # TEM<-dataList$precursorLabels
#   # TEM1<-which(names(TcolR) %in% TEM)
#   # TEM2<-TcolR[TEM1]
#   # TEM3<-which(names(TEM2) %in% names(poisXpoints))
#   # TEM4<-TEM2[TEM3]
#   # '%ni%' <- Negate('%in%')
#   # TEM5<-rbind.fill.matrix(t(poisXpoints), t(TEM4))
#   # TEM6<-TEM5[2,]
#   # TEM7<-as.vector(TEM6)
#   
#   
#   #print(typeof(unname(TNF5)))
#   #print(TNF4)
#   #print(str(dataList))
#   #print(dataList$colorMatrixDataFrame)
#   ###############################
#   print("entring the line ...line 2566")
#   #print(TEM7)
#   #print(length(poisXpoints))
#   #print(length(TEM6))
#   #TEM3<-which[names(poisXpoints) %ni% names(TEM2)]
#   #print(which(names(poisXpoints) %ni% names(TEM2)))
#   #print(TEM3)
#   #TEM1<-TcolR[intersect(names(TcolR),TEM)]
#   #TEM2<-TEM1[names(TEM1) %in%  names(poisXpoints)]
#   #TEM3<-TEM1[intersect(names(TEM1),names(poisXpoints))]
#   #### CHECK 
#   #print(poisXpoints[1:10])
#   #print(head(TEM5,10))
#  # print(rbind.fill.matrix(t(poisXpoints), t(TEM4)))
#   #print(poisXpoints[which(names(poisXpoints) %in% names(TEM4))])
#   #print(TEM)
#   #print(TEM1)
#   #print(poisXpoints[1:20])
#   #print(TEM4[1:20])
#   #print(TcolR)
#   #print(match('132.921 / 19.19',names(TcolR)))
#   #print(match('122.032 /   5.97',names(TcolR)))
#   #print(TEM2)
#   #print(TcolR)
#   #print(TEM2)
#   #print(TEM3)
#   #b[names(b) %in%  names(a)]
#   #print(poisXpoints)
#   #print("entring the line ...line 2564")
#   #print(TEM1[names(TEM1) %in%  names(poisXpoints)])
#   #TEM3<-TEM2[sort(names(TEM2))]
#   #tspoisXpoints<-poisXpoints[sort(names(poisXpoints))]
#   #tspoisYpoints<-poisXpoints[sort(names(poisYpoints))]
#   ##############################################################
#   #print(TEM3)
#   #print("enter the poisXpoints ")
#   #print(tspoisXpoints)
#   #print("enter the poisypoints ")
#   #print(tspoisYpoints)
#   #print(unname(TEM3))
#   ########################################
#   #a[sort(names(a))]
#   #print(length(TEM2))
#   #print(TEM1)
#   #print(length(poisXpoints))
#   #print(length(TEM1))
#   #print(showLoadingsAbundance)
#   #print(TcolR[intersect(names(TcolR),TEM)])
#   #print(TcolR[intersect(names(TcolR),names(TEM))])
#   #print(length(dataList$precursorLabels))
#   #print(length(pointColors))
#   #print(length(poisXpoints))
#   #print(mappingToData)
#   #print(typeof(mappingToData))
#   #print(pointColors)
#   #print(unname(TcolR))
#   #print(unname(TannR))
#   #print(TcolR[1])
#   ##############################
#   switch(loadingsLabels,
#          "None"={## no labels
#            labels <- NULL
#          },
#          "m/z / RT"={## mz/rt
#            labels <- dataList$precursorLabels[filter]
#            print("this is entering this area ...2505")
#            print(labels)
#            labels <- c(labels[lv4points], labels[lv3points], labels[lv2points], labels[lv1points])
#            print("this is entering this area ...2508")
#            print(labels)
#            #labels <- c(labels[!annotatedPoints], labels[annotatedPoints])
#          },
#          "Metabolite name"={## name
#            labels <- dataList$dataFrameInfos[filter, "Metabolite name"]
#            print("this is entering this area ...2514")
#            print(labels)
#            labels <- c(labels[lv4points], labels[lv3points], labels[lv2points], labels[lv1points])
#            print("this is entering this area ...2517")
#            print(labels)
#            #labels <- c(labels[!annotatedPoints], labels[annotatedPoints])
#          },
#          "Metabolite family"={## family
#            featureFamilies <- dataList$annoArrayOfLists[filter]
#            labels <- unlist(lapply(X = featureFamilies, FUN = function(x){
#              ifelse(
#                test = length(x) == 0, 
#                yes = "-", 
#                no = paste(unlist(x), collapse = ", ")
#              )
#            }))
#            labels <- c(labels[lv4points], labels[lv3points], labels[lv2points], labels[lv1points])
#            print("this is entering this area ...2531")
#            print(labels)
#          },
#          {## unknown state
#            stop(paste("Unknown loadingsLabels value", loadingsLabels))
#          }
#   )## end switch
#   
#   ## points
#   #points(x = poisXpoints, y = poisYpoints, col = pointColors, pch=19, cex=pointSizes)
#   if(showLoadingsAbundance){
#     print("entering this line ...2542")
#     #print(showLoadingsAbundance)
#     precursorMeansNorm <- dataList$dataFrameMeasurements[filter, "meanAllNormed"]
#     precursorMeansNorm <- c(precursorMeansNorm[lv4points], precursorMeansNorm[lv3points], precursorMeansNorm[lv2points], precursorMeansNorm[lv1points])
#     #precursorMeansNorm <- c(precursorMeansNorm[!annotatedPoints], precursorMeansNorm[annotatedPoints])
#     precursorMeansNorm <- precursorMeansNorm[mappingToData]
#     #print("entering this line ...2548")
#     #print(precursorMeansNorm)
#     pointSizes <- pointSizes * 2 * precursorMeansNorm
#   }
#   
#   ############################################################################################
#   ## plot
#   par(mar=c(3 + 0.35, 3, 2, 1), mgp = c(2, 1, 0))  ## c(bottom, left, top, right)
#   #plot(x = dataDimOne, y = dataDimTwo, xlim = xInterval, ylim = yInterval, xlab = xAxisLabel, ylab = yAxisLabel, main = "Loadings", pch=19, cex=0.7, col = nodeColors)
#   plot(x = NULL, y = NULL, xlim = xInterval, ylim = yInterval, xlab = xAxisLabel, ylab = yAxisLabel, main = "Loadings")
#   ######TCOl2 ..changing ...col = pointColors ### this is original ....2650...TEM7
#   points(x = poisXpoints, y = poisYpoints, col =pointColors, pch=19, cex=pointSizes)
#   #############
#   print("entering the line ....2652")
#   #print(poisXpoints)
#   #print(TEM1[intersect(names(TEM1),names(poisXpoints))])
#   #print(setequal(names(poisXpoints),names(TEM2)))
#   #points(x = poisXpoints, y = poisYpoints, col =unname(TEM3), pch=19, cex=pointSizes)
#   #points(x = tspoisXpoints, y = tspoisYpoints , col = unname(TEM3) , pch=19, cex=pointSizes)
#   #################################
#   
#   ## axis
#   xInt <- xMax - xMin
#   yInt <- yMax - yMin
#   xl <- xMin - xInt
#   xr <- xMax + xInt
#   yl <- yMin - yInt
#   yr <- yMax + yInt
#   segments(x0 = xl, x1 = xr, y0 = 0, y1 = 0, col = "black", lwd = 1)
#   segments(x0 = 0, x1 = 0, y0 = yl, y1 = yr, col = "black", lwd = 1)
#   
#   if(all(!is.null(labels), length(labels) > 0))
#     graphics::text(  x = poisX - 0.0, y = poisY + 0.0, labels = labels, pos = 4)
#   
#   uniqueIndeces     <- which(!duplicated(resultObjAnno$setOfAnnotations))
#   print("entering this area ...line 2570")
#   #print(uniqueIndeces)
#   uniqueAnnotations <- resultObjAnno$setOfAnnotations[uniqueIndeces]
#   print("entering this area ...line 2573")
#   #print( uniqueAnnotations)
#   uniqueColors      <- resultObjAnno$setOfColors[uniqueIndeces]
#   print("entering this area ...line 2576")
#   #print(uniqueColors)
#   
#   resultList <- list(
#     setOfAnnotations = uniqueAnnotations,
#     setOfColors      = uniqueColors
#   )
#   return(resultList)
# }
# generatePoints <- function(poisX, poisY, pointSizesAnno, pointColorsAnno, pointsAnalysis, pointsFragment, pointsSearch, pointSizeModifier){
#   numberOfPoisDrawn <- length(poisX)
#   #pointIndeces <- seq_len(numberOfPoisDrawn)
#   
#   ## analysis
#   pointSizesAnalysis  <- vector(mode = "numeric", length = numberOfPoisDrawn)
#   pointColorsAnalysis <- vector(length = numberOfPoisDrawn)
#   pointSizesAnalysis [pointsAnalysis] <- clusterNodePointSize1
#   pointColorsAnalysis[pointsAnalysis] <- "blue"
#   
#   ## fragment
#   pointSizesFragment  <- vector(mode = "numeric", length = numberOfPoisDrawn)
#   pointColorsFragment <- vector(length = numberOfPoisDrawn)
#   print("entering this area ...line 2601")
#   print(pointColorsFragment)
#   intersection <- pointsAnalysis & pointsFragment
#   difference   <- pointsFragment & (!intersection)
#   pointSizesFragment[intersection] <- clusterNodePointSize2
#   pointSizesFragment[difference] <- clusterNodePointSize1
#   pointColorsFragment[pointsFragment] <- "green"
#   
#   ## search
#   pointSizesSearch  <- vector(mode = "numeric", length = numberOfPoisDrawn)
#   pointColorsSearch <- vector(length = numberOfPoisDrawn)
#   print("entering this area ...line 2612")
#   print(pointColorsSearch)
#   intersection  <- pointsAnalysis & pointsFragment & pointsSearch
#   intersection2 <- (pointsSearch & pointsAnalysis | pointsSearch & pointsFragment) & (!intersection)
#   difference   <- pointsSearch & (!intersection) & (!intersection2)
#   pointSizesSearch[intersection]  <- clusterNodePointSize3
#   pointSizesSearch[intersection2] <- clusterNodePointSize2
#   pointSizesSearch[difference] <- clusterNodePointSize1
#   pointColorsSearch[pointsSearch] <- "red"
#   
#   if(!is.null(pointSizeModifier)){
#     pointSizesSearch   <- pointSizesSearch   + pointSizeModifier * dendrogramClusterPointSizeMaximumMultiplier
#     pointSizesFragment <- pointSizesFragment + pointSizeModifier * dendrogramClusterPointSizeMaximumMultiplier
#     pointSizesAnalysis <- pointSizesAnalysis + pointSizeModifier * dendrogramClusterPointSizeMaximumMultiplier
#     pointSizesAnno     <- pointSizesAnno     + pointSizeModifier * dendrogramClusterPointSizeMaximumMultiplier
#     #pointSizesSearch   <- pointSizesSearch   * (1 + pointSizeModifier * dendrogramClusterPointSizeMaximumMultiplier)
#     #pointSizesFragment <- pointSizesFragment * (1 + pointSizeModifier * dendrogramClusterPointSizeMaximumMultiplier)
#     #pointSizesAnalysis <- pointSizesAnalysis * (1 + pointSizeModifier * dendrogramClusterPointSizeMaximumMultiplier)
#     #pointSizesAnno     <- pointSizesAnno     * (1 + pointSizeModifier * dendrogramClusterPointSizeMaximumMultiplier)
#   }
#   
#   pointSizes        <- c(pointSizesSearch[pointsSearch], pointSizesFragment[pointsFragment], pointSizesAnalysis[pointsAnalysis], pointSizesAnno)
#   pointColors       <- c(pointColorsSearch[pointsSearch], pointColorsFragment[pointsFragment], pointColorsAnalysis[pointsAnalysis], pointColorsAnno)
#   print("entering this area ...line 2635")
#   print(pointColors)
#   poisXpoints       <- c(poisX[pointsSearch], poisX[pointsFragment], poisX[pointsAnalysis], poisX)
#   poisYpoints       <- c(poisY[pointsSearch], poisY[pointsFragment], poisY[pointsAnalysis], poisY)
#   #pointIndecesPoints<- c(pointIndeces[pointsSearch], pointIndeces[pointsFragment], pointIndeces[pointsAnalysis], pointIndeces)
#   
#   mappingToData <- c(which(pointsSearch), which(pointsFragment), which(pointsAnalysis), seq_len(length(poisY)))
#   
#   resultObj <- list(
#     mappingToData  = mappingToData,
#     pointSizes  = pointSizes,
#     pointColors = pointColors,
#     poisXpoints = poisXpoints,
#     poisYpoints = poisYpoints
#   )
#   
#   return(resultObj)
# }

##########################################################################
calcPlotPCAloadings1 <- function(
  pcaObj, dataList, filter, 
  pcaDimensionOne, pcaDimensionTwo, 
  selectionFragmentPcaLoadingSet = NULL, selectionAnalysisPcaLoadingSet = NULL, selectionSearchPcaLoadingSet = NULL, 
  xInterval = NULL, yInterval = NULL, 
  loadingsLabels = "None", showLoadingsAbundance = FALSE,
  showLoadingsFeaturesAnnotated = TRUE, showLoadingsFeaturesUnannotated = TRUE, showLoadingsFeaturesSelected = TRUE, showLoadingsFeaturesUnselected = TRUE
){
  if(FALSE){
    pcaObj_ <<- pcaObj
    dataList_ <<- dataList
    filter__ <<- filter
    pcaDimensionOne_ <<- pcaDimensionOne
    pcaDimensionTwo_ <<- pcaDimensionTwo
    selectionFragmentPcaLoadingSet_ <<- selectionFragmentPcaLoadingSet
    selectionAnalysisPcaLoadingSet_ <<- selectionAnalysisPcaLoadingSet
    selectionSearchPcaLoadingSet_ <<- selectionSearchPcaLoadingSet
    xInterval_ <<- xInterval
    yInterval_ <<- yInterval
    loadingsLabels_ <<- loadingsLabels
    showLoadingsAbundance_ <<- showLoadingsAbundance
    showLoadingsFeaturesAnnotated_ <<- showLoadingsFeaturesAnnotated
    showLoadingsFeaturesUnannotated_ <<- showLoadingsFeaturesUnannotated
    showLoadingsFeaturesSelected_ <<- showLoadingsFeaturesSelected
    showLoadingsFeaturesUnselected_ <<- showLoadingsFeaturesUnselected
  }
  if(FALSE){
    pcaObj <- pcaObj_
    dataList <- dataList_
    filter <- filter__
    pcaDimensionOne <- pcaDimensionOne_
    pcaDimensionTwo <- pcaDimensionTwo_
    selectionFragmentPcaLoadingSet <- selectionFragmentPcaLoadingSet_
    selectionAnalysisPcaLoadingSet <- selectionAnalysisPcaLoadingSet_
    selectionSearchPcaLoadingSet <- selectionSearchPcaLoadingSet_
    xInterval <- xInterval_
    yInterval <- yInterval_
    loadingsLabels <- loadingsLabels_
    showLoadingsAbundance <- showLoadingsAbundance_
    showLoadingsFeaturesAnnotated <- showLoadingsFeaturesAnnotated_
    showLoadingsFeaturesUnannotated <- showLoadingsFeaturesUnannotated_
    showLoadingsFeaturesSelected <- showLoadingsFeaturesSelected_
    showLoadingsFeaturesUnselected <- showLoadingsFeaturesUnselected_
  }
  
  resultObjAnno <- getPrecursorColors(dataList, filter)
  
  ## shown loadings features
  allFeatures <- seq_len(dataList$numberOfPrecursors)
  annotatedFeatures <- which(resultObjAnno$setOfColors != "black")
  selectedLoadingsFeatures <- union(union(selectionAnalysisPcaLoadingSet, selectionFragmentPcaLoadingSet), selectionSearchPcaLoadingSet)
  filter2 <- NULL
  if(showLoadingsFeaturesAnnotated)
    ## annotated features
    filter2 <- c(filter2, annotatedFeatures)
  if(showLoadingsFeaturesUnannotated)
    ## unannotated features
    filter2 <- c(filter2, setdiff(allFeatures, annotatedFeatures))
  if(showLoadingsFeaturesSelected)
    ## selected features
    filter2 <- c(filter2, selectedLoadingsFeatures)
  if(showLoadingsFeaturesUnselected)
    ## unselected features
    filter2 <- c(filter2, setdiff(allFeatures, selectedLoadingsFeatures))
  
  filter <- intersect(filter, unique(filter2))
  
  resultObjAnno <- getPrecursorColors(dataList, filter)
  #resultObjAnno$setOfAnnotations <- resultObjAnno$setOfAnnotations[filter]
  #resultObjAnno$setOfColors      <- resultObjAnno$setOfColors[filter]
  
  ## data
  dataDimOne <- pcaObj$loadings[, pcaDimensionOne]
  dataDimTwo <- pcaObj$loadings[, pcaDimensionTwo]
  
  ## performance
  resultObj <- getPcaPerformanceIndicator(pcaObj = pcaObj, isScores = TRUE)
  xAxisLabel <- resultObj$xAxisLabel
  yAxisLabel <- resultObj$yAxisLabel
  
  ## xlim / ylim
  xMin <- min(dataDimOne)
  xMax <- max(dataDimOne)
  yMin <- min(dataDimTwo)
  yMax <- max(dataDimTwo)
  
  if(any(is.na(c(xMin, xMax, yMin, yMax)))){
    xMin <- 0
    xMax <- -1
    yMin <- 0
    yMax <- -1
  }
  
  if(is.null(xInterval))
    xInterval <- c(xMin, xMax)
  if(is.null(yInterval))
    yInterval <- c(yMin, yMax)
  
  dataDimOne <- dataDimOne[filter]
  dataDimTwo <- dataDimTwo[filter]
  selectionFragmentPcaLoadingSet <- intersect(selectionFragmentPcaLoadingSet, filter)
  selectionAnalysisPcaLoadingSet <- intersect(selectionAnalysisPcaLoadingSet, filter)
  selectionSearchPcaLoadingSet   <- intersect(selectionSearchPcaLoadingSet  , filter)
  
  numberOfPrecursors <- length(dataDimOne)
  poisX <- dataDimOne
  poisY <- dataDimTwo
  
  pointSizesAnno  <- rep(x = clusterNodePointSize0, times = numberOfPrecursors)
  pointColorsAnno <- resultObjAnno$setOfColors
  
  pointsAnalysis <- vector(mode = "logical", length = numberOfPrecursors)
  pointsAnalysis[match(x = selectionAnalysisPcaLoadingSet, table = filter)] <- TRUE
  pointsFragment <- vector(mode = "logical", length = numberOfPrecursors)
  pointsFragment[match(x = selectionFragmentPcaLoadingSet, table = filter)] <- TRUE
  pointsSearch <- vector(mode = "logical", length = numberOfPrecursors)
  pointsSearch[match(x = selectionSearchPcaLoadingSet, table = filter)] <- TRUE
  
  annotatedPoints <- pointColorsAnno != "black"
  selectedPoints  <- pointsAnalysis | pointsFragment | pointsSearch
  lv1points <-   annotatedPoints  &   selectedPoints
  lv2points <- (!annotatedPoints) &   selectedPoints
  lv3points <-   annotatedPoints  & (!selectedPoints)
  lv4points <- (!annotatedPoints) & (!selectedPoints)
  
  #poisX <- c(poisX[!annotatedPoints], poisX[annotatedPoints])
  #poisY <- c(poisY[!annotatedPoints], poisY[annotatedPoints])
  #pointSizesAnno <- c(pointSizesAnno[!annotatedPoints], pointSizesAnno[annotatedPoints])
  #pointColorsAnno <- c(pointColorsAnno[!annotatedPoints], pointColorsAnno[annotatedPoints])
  #pointsAnalysis <- c(pointsAnalysis[!annotatedPoints], pointsAnalysis[annotatedPoints])
  #pointsFragment <- c(pointsFragment[!annotatedPoints], pointsFragment[annotatedPoints])
  #pointsSearch <- c(pointsSearch[!annotatedPoints], pointsSearch[annotatedPoints])
  
  poisX           <- c(poisX          [lv4points], poisX          [lv3points], poisX          [lv2points], poisX          [lv1points])
  poisY           <- c(poisY          [lv4points], poisY          [lv3points], poisY          [lv2points], poisY          [lv1points])
  pointSizesAnno  <- c(pointSizesAnno [lv4points], pointSizesAnno [lv3points], pointSizesAnno [lv2points], pointSizesAnno [lv1points])
  pointColorsAnno <- c(pointColorsAnno[lv4points], pointColorsAnno[lv3points], pointColorsAnno[lv2points], pointColorsAnno[lv1points])
  pointsAnalysis  <- c(pointsAnalysis [lv4points], pointsAnalysis [lv3points], pointsAnalysis [lv2points], pointsAnalysis [lv1points])
  pointsFragment  <- c(pointsFragment [lv4points], pointsFragment [lv3points], pointsFragment [lv2points], pointsFragment [lv1points])
  pointsSearch    <- c(pointsSearch   [lv4points], pointsSearch   [lv3points], pointsSearch   [lv2points], pointsSearch   [lv1points])
  
  resultObjPoints <- generatePoints(
    poisX = poisX, poisY = poisY, 
    pointSizesAnno = pointSizesAnno, pointColorsAnno = pointColorsAnno, 
    pointsAnalysis = pointsAnalysis, pointsFragment = pointsFragment, pointsSearch = pointsSearch,
    pointSizeModifier = NULL
  )
  pointSizes    <- resultObjPoints$pointSizes
  pointColors   <- resultObjPoints$pointColors
  poisXpoints   <- resultObjPoints$poisXpoints
  poisYpoints   <- resultObjPoints$poisYpoints
  mappingToData <- resultObjPoints$mappingToData
  
  switch(loadingsLabels,
         "None"={## no labels
           labels <- NULL
         },
         "m/z / RT"={## mz/rt
           labels <- dataList$precursorLabels[filter]
           labels <- c(labels[lv4points], labels[lv3points], labels[lv2points], labels[lv1points])
           #labels <- c(labels[!annotatedPoints], labels[annotatedPoints])
         },
         "Metabolite name"={## name
           labels <- dataList$dataFrameInfos[filter, "Metabolite name"]
           labels <- c(labels[lv4points], labels[lv3points], labels[lv2points], labels[lv1points])
           #labels <- c(labels[!annotatedPoints], labels[annotatedPoints])
         },
         "Metabolite family"={## family
           featureFamilies <- dataList$annoArrayOfLists[filter]
           labels <- unlist(lapply(X = featureFamilies, FUN = function(x){
             ifelse(
               test = length(x) == 0, 
               yes = "-", 
               no = paste(unlist(x), collapse = ", ")
             )
           }))
           labels <- c(labels[lv4points], labels[lv3points], labels[lv2points], labels[lv1points])
         },
         {## unknown state
           stop(paste("Unknown loadingsLabels value", loadingsLabels))
         }
  )## end switch
  
  ## points
  #points(x = poisXpoints, y = poisYpoints, col = pointColors, pch=19, cex=pointSizes)
  if(showLoadingsAbundance){
    precursorMeansNorm <- dataList$dataFrameMeasurements[filter, "meanAllNormed"]
    precursorMeansNorm <- c(precursorMeansNorm[lv4points], precursorMeansNorm[lv3points], precursorMeansNorm[lv2points], precursorMeansNorm[lv1points])
    #precursorMeansNorm <- c(precursorMeansNorm[!annotatedPoints], precursorMeansNorm[annotatedPoints])
    precursorMeansNorm <- precursorMeansNorm[mappingToData]
    pointSizes <- pointSizes * 2 * precursorMeansNorm
  }
  
  ############################################################################################
  ## plot
  ### commenting the original value for the par
  ##par(mar=c(3 + 0.35, 3, 2, 1), mgp = c(2, 1, 0))  ## c(bottom, left, top, right)
  par(mar=c(3+0.15 , 3, 2, 1), mgp = c(2.0, 1, 0))
  
  #plot(x = dataDimOne, y = dataDimTwo, xlim = xInterval, ylim = yInterval, xlab = xAxisLabel, ylab = yAxisLabel, main = "Loadings", pch=19, cex=0.7, col = nodeColors)
  plot(x = NULL, y = NULL, xlim = xInterval, ylim = yInterval, xlab = xAxisLabel, ylab = yAxisLabel, main = "Loadings")
  points(x = poisXpoints, y = poisYpoints, col = pointColors, pch=19, cex=pointSizes)
  
  ## axis
  ### changing 
  #xInt <- xMax - xMin
  #yInt <- yMax - yMin
  xInt <- xMax - xMin
  yInt <- yMax - yMin
  xl <- xMin - xInt
  xr <- xMax + xInt
  yl <- yMin - yInt
  yr <- yMax + yInt
  segments(x0 = xl, x1 = xr, y0 = 0, y1 = 0, col = "black", lwd = 1)
  segments(x0 = 0, x1 = 0, y0 = yl, y1 = yr, col = "black", lwd = 1)
  
  if(all(!is.null(labels), length(labels) > 0))
    ### changing pos = 4 to pos =3 
    graphics::text(  x = poisX - 0.0, y = poisY + 0.0, labels = labels, pos = 2)
  
  uniqueIndeces     <- which(!duplicated(resultObjAnno$setOfAnnotations))
  uniqueAnnotations <- resultObjAnno$setOfAnnotations[uniqueIndeces]
  uniqueColors      <- resultObjAnno$setOfColors[uniqueIndeces]
  
  resultList <- list(
    setOfAnnotations = uniqueAnnotations,
    setOfColors      = uniqueColors
  )
  return(resultList)
}

##### adding this new 



############
calcPlotPCAloadings2 <- function(
  pcaObj, dataList, filter, 
  pcaDimensionOne, pcaDimensionTwo, 
  selectionFragmentPcaLoadingSet = NULL, selectionAnalysisPcaLoadingSet = NULL, selectionSearchPcaLoadingSet = NULL, 
  xInterval = NULL, yInterval = NULL, 
  loadingsLabels = "None", showLoadingsAbundance = FALSE,
  showLoadingsFeaturesAnnotated = TRUE, showLoadingsFeaturesUnannotated = TRUE, showLoadingsFeaturesSelected = TRUE, showLoadingsFeaturesUnselected = TRUE
){
  if(FALSE){
    pcaObj_ <<- pcaObj
    dataList_ <<- dataList
    filter__ <<- filter
    pcaDimensionOne_ <<- pcaDimensionOne
    pcaDimensionTwo_ <<- pcaDimensionTwo
    selectionFragmentPcaLoadingSet_ <<- selectionFragmentPcaLoadingSet
    selectionAnalysisPcaLoadingSet_ <<- selectionAnalysisPcaLoadingSet
    selectionSearchPcaLoadingSet_ <<- selectionSearchPcaLoadingSet
    xInterval_ <<- xInterval
    yInterval_ <<- yInterval
    loadingsLabels_ <<- loadingsLabels
    showLoadingsAbundance_ <<- showLoadingsAbundance
    showLoadingsFeaturesAnnotated_ <<- showLoadingsFeaturesAnnotated
    showLoadingsFeaturesUnannotated_ <<- showLoadingsFeaturesUnannotated
    showLoadingsFeaturesSelected_ <<- showLoadingsFeaturesSelected
    showLoadingsFeaturesUnselected_ <<- showLoadingsFeaturesUnselected
  }
  if(FALSE){
    pcaObj <- pcaObj_
    dataList <- dataList_
    filter <- filter__
    pcaDimensionOne <- pcaDimensionOne_
    pcaDimensionTwo <- pcaDimensionTwo_
    selectionFragmentPcaLoadingSet <- selectionFragmentPcaLoadingSet_
    selectionAnalysisPcaLoadingSet <- selectionAnalysisPcaLoadingSet_
    selectionSearchPcaLoadingSet <- selectionSearchPcaLoadingSet_
    xInterval <- xInterval_
    yInterval <- yInterval_
    loadingsLabels <- loadingsLabels_
    showLoadingsAbundance <- showLoadingsAbundance_
    showLoadingsFeaturesAnnotated <- showLoadingsFeaturesAnnotated_
    showLoadingsFeaturesUnannotated <- showLoadingsFeaturesUnannotated_
    showLoadingsFeaturesSelected <- showLoadingsFeaturesSelected_
    showLoadingsFeaturesUnselected <- showLoadingsFeaturesUnselected_
  }
  
  resultObjAnno <- getPrecursorColors(dataList, filter)
  
  ## shown loadings features
  allFeatures <- seq_len(dataList$numberOfPrecursors)
  annotatedFeatures <- which(resultObjAnno$setOfColors != "black")
  selectedLoadingsFeatures <- union(union(selectionAnalysisPcaLoadingSet, selectionFragmentPcaLoadingSet), selectionSearchPcaLoadingSet)
  filter2 <- NULL
  if(showLoadingsFeaturesAnnotated)
    ## annotated features
    filter2 <- c(filter2, annotatedFeatures)
  if(showLoadingsFeaturesUnannotated)
    ## unannotated features
    filter2 <- c(filter2, setdiff(allFeatures, annotatedFeatures))
  if(showLoadingsFeaturesSelected)
    ## selected features
    filter2 <- c(filter2, selectedLoadingsFeatures)
  if(showLoadingsFeaturesUnselected)
    ## unselected features
    filter2 <- c(filter2, setdiff(allFeatures, selectedLoadingsFeatures))
  
  filter <- intersect(filter, unique(filter2))
  
  resultObjAnno <- getPrecursorColors(dataList, filter)
  #resultObjAnno$setOfAnnotations <- resultObjAnno$setOfAnnotations[filter]
  #resultObjAnno$setOfColors      <- resultObjAnno$setOfColors[filter]
  
  ## data
  dataDimOne <- pcaObj$loadings[, pcaDimensionOne]
  dataDimTwo <- pcaObj$loadings[, pcaDimensionTwo]
  
  ## performance
  resultObj <- getPcaPerformanceIndicator(pcaObj = pcaObj, isScores = TRUE)
  xAxisLabel <- resultObj$xAxisLabel
  yAxisLabel <- resultObj$yAxisLabel
  
  ## xlim / ylim
  xMin <- min(dataDimOne)
  xMax <- max(dataDimOne)
  yMin <- min(dataDimTwo)
  yMax <- max(dataDimTwo)
  
  if(any(is.na(c(xMin, xMax, yMin, yMax)))){
    xMin <- -1
    xMax <- 1
    yMin <- -1
    yMax <- 1
  }
  
  if(is.null(xInterval))
    xInterval <- c(xMin, xMax)
  if(is.null(yInterval))
    yInterval <- c(yMin, yMax)
  
  dataDimOne <- dataDimOne[filter]
  dataDimTwo <- dataDimTwo[filter]
  selectionFragmentPcaLoadingSet <- intersect(selectionFragmentPcaLoadingSet, filter)
  selectionAnalysisPcaLoadingSet <- intersect(selectionAnalysisPcaLoadingSet, filter)
  selectionSearchPcaLoadingSet   <- intersect(selectionSearchPcaLoadingSet  , filter)
  
  numberOfPrecursors <- length(dataDimOne)
  poisX <- dataDimOne
  poisY <- dataDimTwo
  
  pointSizesAnno  <- rep(x = clusterNodePointSize0, times = numberOfPrecursors)
  pointColorsAnno <- resultObjAnno$setOfColors
  
  pointsAnalysis <- vector(mode = "logical", length = numberOfPrecursors)
  pointsAnalysis[match(x = selectionAnalysisPcaLoadingSet, table = filter)] <- TRUE
  pointsFragment <- vector(mode = "logical", length = numberOfPrecursors)
  pointsFragment[match(x = selectionFragmentPcaLoadingSet, table = filter)] <- TRUE
  pointsSearch <- vector(mode = "logical", length = numberOfPrecursors)
  pointsSearch[match(x = selectionSearchPcaLoadingSet, table = filter)] <- TRUE
  
  annotatedPoints <- pointColorsAnno != "black"
  selectedPoints  <- pointsAnalysis | pointsFragment | pointsSearch
  lv1points <-   annotatedPoints  &   selectedPoints
  lv2points <- (!annotatedPoints) &   selectedPoints
  lv3points <-   annotatedPoints  & (!selectedPoints)
  lv4points <- (!annotatedPoints) & (!selectedPoints)
  
  #poisX <- c(poisX[!annotatedPoints], poisX[annotatedPoints])
  #poisY <- c(poisY[!annotatedPoints], poisY[annotatedPoints])
  #pointSizesAnno <- c(pointSizesAnno[!annotatedPoints], pointSizesAnno[annotatedPoints])
  #pointColorsAnno <- c(pointColorsAnno[!annotatedPoints], pointColorsAnno[annotatedPoints])
  #pointsAnalysis <- c(pointsAnalysis[!annotatedPoints], pointsAnalysis[annotatedPoints])
  #pointsFragment <- c(pointsFragment[!annotatedPoints], pointsFragment[annotatedPoints])
  #pointsSearch <- c(pointsSearch[!annotatedPoints], pointsSearch[annotatedPoints])
  
  poisX           <- c(poisX          [lv4points], poisX          [lv3points], poisX          [lv2points], poisX          [lv1points])
  poisY           <- c(poisY          [lv4points], poisY          [lv3points], poisY          [lv2points], poisY          [lv1points])
  pointSizesAnno  <- c(pointSizesAnno [lv4points], pointSizesAnno [lv3points], pointSizesAnno [lv2points], pointSizesAnno [lv1points])
  pointColorsAnno <- c(pointColorsAnno[lv4points], pointColorsAnno[lv3points], pointColorsAnno[lv2points], pointColorsAnno[lv1points])
  pointsAnalysis  <- c(pointsAnalysis [lv4points], pointsAnalysis [lv3points], pointsAnalysis [lv2points], pointsAnalysis [lv1points])
  pointsFragment  <- c(pointsFragment [lv4points], pointsFragment [lv3points], pointsFragment [lv2points], pointsFragment [lv1points])
  pointsSearch    <- c(pointsSearch   [lv4points], pointsSearch   [lv3points], pointsSearch   [lv2points], pointsSearch   [lv1points])
  
  resultObjPoints <- generatePoints(
    poisX = poisX, poisY = poisY, 
    pointSizesAnno = pointSizesAnno, pointColorsAnno = pointColorsAnno, 
    pointsAnalysis = pointsAnalysis, pointsFragment = pointsFragment, pointsSearch = pointsSearch,
    pointSizeModifier = NULL
  )
  pointSizes    <- resultObjPoints$pointSizes
  pointColors   <- resultObjPoints$pointColors
  poisXpoints   <- resultObjPoints$poisXpoints
  poisYpoints   <- resultObjPoints$poisYpoints
  mappingToData <- resultObjPoints$mappingToData
  
  switch(loadingsLabels,
         "None"={## no labels
           labels <- NULL
         },
         "m/z / RT"={## mz/rt
           labels <- dataList$precursorLabels[filter]
           labels <- c(labels[lv4points], labels[lv3points], labels[lv2points], labels[lv1points])
           #labels <- c(labels[!annotatedPoints], labels[annotatedPoints])
         },
         "Metabolite name"={## name
           labels <- dataList$dataFrameInfos[filter, "Metabolite name"]
           labels <- c(labels[lv4points], labels[lv3points], labels[lv2points], labels[lv1points])
           #labels <- c(labels[!annotatedPoints], labels[annotatedPoints])
         },
         "Metabolite family"={## family
           featureFamilies <- dataList$annoArrayOfLists[filter]
           labels <- unlist(lapply(X = featureFamilies, FUN = function(x){
             ifelse(
               test = length(x) == 0, 
               yes = "-", 
               no = paste(unlist(x), collapse = ", ")
             )
           }))
           labels <- c(labels[lv4points], labels[lv3points], labels[lv2points], labels[lv1points])
         },
         {## unknown state
           stop(paste("Unknown loadingsLabels value", loadingsLabels))
         }
  )## end switch
  
  ## points
  #points(x = poisXpoints, y = poisYpoints, col = pointColors, pch=19, cex=pointSizes)
  if(showLoadingsAbundance){
    precursorMeansNorm <- dataList$dataFrameMeasurements[filter, "meanAllNormed"]
    precursorMeansNorm <- c(precursorMeansNorm[lv4points], precursorMeansNorm[lv3points], precursorMeansNorm[lv2points], precursorMeansNorm[lv1points])
    #precursorMeansNorm <- c(precursorMeansNorm[!annotatedPoints], precursorMeansNorm[annotatedPoints])
    precursorMeansNorm <- precursorMeansNorm[mappingToData]
    pointSizes <- pointSizes * 2 * precursorMeansNorm
  }
  
  ############################################################################################
  ## plot
  par(mar=c(3 + 0.5125, 3+0.125, 2, 1), mgp = c(2, 1, 0))  ## c(bottom, left, top, right)
  #plot(x = dataDimOne, y = dataDimTwo, xlim = xInterval, ylim = yInterval, xlab = xAxisLabel, ylab = yAxisLabel, main = "Loadings", pch=19, cex=0.7, col = nodeColors)
  plot(x = NULL, y = NULL, xlim = xInterval, ylim = yInterval, xlab = xAxisLabel, ylab = yAxisLabel, main = "Loadings")
  ### changing this to 22 and will see what happens...1:length(filterObj$grouXXXps),lty=1,lwd=2
  points(x = poisXpoints, y = poisYpoints, col = pointColors, pch=19, cex=pointSizes)
  
  ## axis
  xInt <- xMax - xMin
  yInt <- yMax - yMin
  xl <- xMin - xInt
  xr <- xMax + xInt
  yl <- yMin - yInt
  yr <- yMax + yInt
  ##############
  #segments(x0 = xl, x1 = xr, y0 = 0, y1 = 0, col = "black", lwd = 1)
  #segments(x0 = 0, x1 = 0, y0 = yl, y1 = yr, col = "black", lwd = 1)
  #############
  
  
  
  if(all(!is.null(labels), length(labels) > 0))
    graphics::text(  x = poisX - 0.0, y = poisY + 0.0, labels = labels, pos = 4)
  
  uniqueIndeces     <- which(!duplicated(resultObjAnno$setOfAnnotations))
  uniqueAnnotations <- resultObjAnno$setOfAnnotations[uniqueIndeces]
  uniqueColors      <- resultObjAnno$setOfColors[uniqueIndeces]
  
  resultList <- list(
    setOfAnnotations = uniqueAnnotations,
    setOfColors      = uniqueColors
  )
  return(resultList)
}
##### adding end ##########



generatePoints <- function(poisX, poisY, pointSizesAnno, pointColorsAnno, pointsAnalysis, pointsFragment, pointsSearch, pointSizeModifier){
  numberOfPoisDrawn <- length(poisX)
  #pointIndeces <- seq_len(numberOfPoisDrawn)
  
  ## analysis
  pointSizesAnalysis  <- vector(mode = "numeric", length = numberOfPoisDrawn)
  pointColorsAnalysis <- vector(length = numberOfPoisDrawn)
  pointSizesAnalysis [pointsAnalysis] <- clusterNodePointSize1
  pointColorsAnalysis[pointsAnalysis] <- "blue"
  
  ## fragment
  pointSizesFragment  <- vector(mode = "numeric", length = numberOfPoisDrawn)
  pointColorsFragment <- vector(length = numberOfPoisDrawn)
  intersection <- pointsAnalysis & pointsFragment
  difference   <- pointsFragment & (!intersection)
  pointSizesFragment[intersection] <- clusterNodePointSize2
  pointSizesFragment[difference] <- clusterNodePointSize1
  pointColorsFragment[pointsFragment] <- "green"
  
  ## search
  pointSizesSearch  <- vector(mode = "numeric", length = numberOfPoisDrawn)
  pointColorsSearch <- vector(length = numberOfPoisDrawn)
  intersection  <- pointsAnalysis & pointsFragment & pointsSearch
  intersection2 <- (pointsSearch & pointsAnalysis | pointsSearch & pointsFragment) & (!intersection)
  difference   <- pointsSearch & (!intersection) & (!intersection2)
  pointSizesSearch[intersection]  <- clusterNodePointSize3
  pointSizesSearch[intersection2] <- clusterNodePointSize2
  pointSizesSearch[difference] <- clusterNodePointSize1
  pointColorsSearch[pointsSearch] <- "red"
  
  if(!is.null(pointSizeModifier)){
    pointSizesSearch   <- pointSizesSearch   + pointSizeModifier * dendrogramClusterPointSizeMaximumMultiplier
    pointSizesFragment <- pointSizesFragment + pointSizeModifier * dendrogramClusterPointSizeMaximumMultiplier
    pointSizesAnalysis <- pointSizesAnalysis + pointSizeModifier * dendrogramClusterPointSizeMaximumMultiplier
    pointSizesAnno     <- pointSizesAnno     + pointSizeModifier * dendrogramClusterPointSizeMaximumMultiplier
    #pointSizesSearch   <- pointSizesSearch   * (1 + pointSizeModifier * dendrogramClusterPointSizeMaximumMultiplier)
    #pointSizesFragment <- pointSizesFragment * (1 + pointSizeModifier * dendrogramClusterPointSizeMaximumMultiplier)
    #pointSizesAnalysis <- pointSizesAnalysis * (1 + pointSizeModifier * dendrogramClusterPointSizeMaximumMultiplier)
    #pointSizesAnno     <- pointSizesAnno     * (1 + pointSizeModifier * dendrogramClusterPointSizeMaximumMultiplier)
  }
  
  pointSizes        <- c(pointSizesSearch[pointsSearch], pointSizesFragment[pointsFragment], pointSizesAnalysis[pointsAnalysis], pointSizesAnno)
  pointColors       <- c(pointColorsSearch[pointsSearch], pointColorsFragment[pointsFragment], pointColorsAnalysis[pointsAnalysis], pointColorsAnno)
  poisXpoints       <- c(poisX[pointsSearch], poisX[pointsFragment], poisX[pointsAnalysis], poisX)
  poisYpoints       <- c(poisY[pointsSearch], poisY[pointsFragment], poisY[pointsAnalysis], poisY)
  #pointIndecesPoints<- c(pointIndeces[pointsSearch], pointIndeces[pointsFragment], pointIndeces[pointsAnalysis], pointIndeces)
  
  mappingToData <- c(which(pointsSearch), which(pointsFragment), which(pointsAnalysis), seq_len(length(poisY)))
  
  resultObj <- list(
    mappingToData  = mappingToData,
    pointSizes  = pointSizes,
    pointColors = pointColors,
    poisXpoints = poisXpoints,
    poisYpoints = poisYpoints
  )
  
  return(resultObj)
}
#####################################
colorPalette2 <- function(){
  ## http://tools.medialab.sciences-po.fr/iwanthue/
  ## 20 colors
  ## or
  ## https://github.com/johnbaums/hues/blob/master/R/iwanthue.R
  ## library(colorBrewer)
  ## colorRampPalette(c("blue", "red"))( 4)
  ## palette(rainbow(6))
  
  #palette <- palette(c(
  palette <- c(
    rgb(150, 90, 180, maxColorValue=255),
    rgb(190, 80, 190, maxColorValue=255),
    rgb(170, 100, 180, maxColorValue=255),
    rgb(180, 80, 200, maxColorValue=255),
    rgb(160, 90, 190, maxColorValue=255),
    rgb(200, 70, 180, maxColorValue=255),
    rgb(140, 110, 170, maxColorValue=255),
    rgb(210, 60, 190, maxColorValue=255),
    rgb(130, 120, 160, maxColorValue=255),
    rgb(220, 50, 200, maxColorValue=255),
    rgb(120, 130, 150, maxColorValue=255),
    rgb(230, 40, 190, maxColorValue=255),
    rgb(110, 140, 140, maxColorValue=255),
    rgb(240, 30, 180, maxColorValue=255),
    rgb(100, 150, 130, maxColorValue=255),
    rgb(250, 20, 170, maxColorValue=255),
    rgb(90, 160, 120, maxColorValue=255),
    rgb(260, 10, 160, maxColorValue=255),
    rgb(80, 170, 110, maxColorValue=255),
    rgb(270, 0, 150, maxColorValue=255),
    rgb(70, 180, 100, maxColorValue=255),
    rgb(280, 10, 140, maxColorValue=255),
    rgb(60, 190, 90, maxColorValue=255),
    rgb(290, 20, 130, maxColorValue=255),
    rgb(50, 200, 80, maxColorValue=255),
    rgb(300, 30, 120, maxColorValue=255),
    rgb(40, 210, 70, maxColorValue=255),
    rgb(310, 40, 110, maxColorValue=255),
    rgb(30, 220, 60, maxColorValue=255),
    rgb(320, 50, 100, maxColorValue=255),
    rgb(20, 230, 50, maxColorValue=255),
    rgb(330, 60, 90, maxColorValue=255),
    rgb(10, 240, 40, maxColorValue=255),
    rgb(340, 70, 80, maxColorValue=255),
    rgb(0, 250, 30, maxColorValue=255),
    rgb(350, 80, 70, maxColorValue=255),
    rgb(0, 255, 20, maxColorValue=255),
    rgb(360, 90, 60, maxColorValue=255),
    rgb(10, 250, 10, maxColorValue=255),
    rgb(350, 100, 70, maxColorValue=255),
    rgb(20, 240, 0, maxColorValue=255),
    rgb(340, 110, 80, maxColorValue=255),
    rgb(30, 230, 10, maxColorValue=255),
    rgb(330, 120, 90, maxColorValue=255),
    rgb(40, 220, 20, maxColorValue=255),
    rgb(320, 130, 100, maxColorValue=255),
    rgb(50, 210, 30, maxColorValue=255),
    rgb(310, 140, 110, maxColorValue=255),
    rgb(60, 200, 40, maxColorValue=255),
    rgb(300, 150, 120, maxColorValue=255),
    rgb(70, 190, 50, maxColorValue=255),
    rgb(290, 160, 130, maxColorValue=255),
    rgb(80, 180, 60, maxColorValue=255),
    rgb(280, 170, 140, maxColorValue=255),
    rgb(90, 170, 70, maxColorValue=255),
    rgb(270, 180, 150, maxColorValue=255),
    rgb(100, 160, 80, maxColorValue=255),
    rgb(260, 190, 160, maxColorValue=255),
    rgb(110, 150, 90, maxColorValue=255),
    rgb(250, 200, 170, maxColorValue=255),
    rgb(120, 140, 100, maxColorValue=255),
    rgb(240, 210, 180, maxColorValue=255),
    rgb(130, 130, 110, maxColorValue=255),
    rgb(230, 220, 190, maxColorValue=255),
    rgb(140, 120, 120, maxColorValue=255),
    rgb(220, 230, 200, maxColorValue=255),
    rgb(150, 110, 130, maxColorValue=255),
    rgb(210, 240, 210, maxColorValue=255),
    rgb(160, 100, 140, maxColorValue=255),
    rgb(200, 250, 220, maxColorValue=255),
    rgb(170, 90, 150, maxColorValue=255),
    rgb(190, 260, 230, maxColorValue=255),
    rgb(180, 80, 160, maxColorValue=255),
    rgb(180, 270, 240, maxColorValue=255),
    rgb(190, 70, 170, maxColorValue=255),
    rgb(170, 280, 250, maxColorValue=255),
    rgb(200, 60, 180, maxColorValue=255),
    rgb(160, 290, 260, maxColorValue=255),
    rgb(210, 50, 190, maxColorValue=255),
    rgb(150, 300, 270, maxColorValue=255),
    rgb(220, 40, 200, maxColorValue=255),
    rgb(140, 310, 280, maxColorValue=255),
    rgb(230, 30, 190, maxColorValue=255),
    rgb(130, 320, 290, maxColorValue=255),
    rgb(240, 20, 180, maxColorValue=255),
    rgb(120, 330, 300, maxColorValue=255),
    rgb(250, 10, 170, maxColorValue=255),
    rgb(110, 340, 310, maxColorValue=255),
    rgb(260, 0, 160, maxColorValue=255),
    rgb(100, 350, 320, maxColorValue=255),
    rgb(270, 10, 150, maxColorValue=255),
    rgb(90, 360, 330, maxColorValue=255),
    rgb(280, 20, 140, maxColorValue=255),
    rgb(80, 370, 340, maxColorValue=255),
    rgb(290, 30, 130, maxColorValue=255),
    rgb(70, 380, 350, maxColorValue=255),
    rgb(300, 40, 120, maxColorValue=255),
    rgb(60, 390, 360, maxColorValue=255),
    rgb(310, 50, 110, maxColorValue=255)
  )
  #))
  return(palette)
}
colorPalette <- function(){
  palette <- c(
    "blue",
    "red",
    "yellow",
    "green",
    "brown",
    "deepskyblue",
    "orange",
    "deeppink",
    "aquamarine",
    "burlywood",
    "cadetblue",
    "coral",
    "cornflowerblue",
    "cyan",
    "darkblue",
    "firebrick",
    "goldenrod",
    "indianred",
    "khaki",
    "magenta",
    "maroon",
    "beige",
    "moccasin",
    "olivedrab",
    "orangered",
    "orchid",
    "paleturquoise3",
    "rosybrown",
    "salmon",
    "seagreen3",
    "skyblue",
    "steelblue",
    "darkgoldenrod",
    "darkgreen",
    "darkkhaki",
    "darkmagenta",
    "darkolivegreen",
    "darkorange",
    "darkorchid",
    "darkred",
    "darksalmon",
    "darkseagreen",
    "darkslateblue",
    "darkslategray",
    "darkturquoise",
    "darkviolet",
    "deepskyblue",
    "dimgray",
    "dodgerblue",
    "firebrick",
    "forestgreen",
    "gold",
    "goldenrod",
    "gray",
    "green",
    "greenyellow",
    "hotpink",
    "indianred",
    "khaki",
    "lavender",
    "lavenderblush",
    "lawngreen",
    "lemonchiffon",
    "lightblue",
    "lightcoral",
    "lightcyan",
    "lightgoldenrodyellow",
    "lightgray",
    "lightgreen",
    "lightpink",
    "lightsalmon",
    "lightseagreen",
    "lightskyblue",
    "lightslategray",
    "lightsteelblue",
    "lightyellow",
    "limegreen",
    "linen",
    "magenta",
    "maroon",
    "mediumaquamarine",
    "mediumblue",
    "mediumorchid",
    "mediumpurple",
    "mediumseagreen",
    "mediumslateblue",
    "mediumspringgreen",
    "mediumturquoise",
    "mediumvioletred",
    "midnightblue",
    "mintcream",
    "mistyrose",
    "moccasin",
    "navajowhite",
    "navy",
    "oldlace",
    "olivedrab",
    "orange",
    "orangered",
    "orchid",
    "palegoldenrod",
    "palegreen",
    "paleturquoise",
    "palevioletred",
    "papayawhip",
    "peachpuff",
    "peru",
    "pink",
    "plum",
    "powderblue",
    "purple",
    "red",
    "rosybrown",
    "royalblue",
    "saddlebrown",
    "salmon",
    "sandybrown",
    "seagreen",
    "sienna",
    "skyblue",
    "slateblue",
    "slategray",
    "snow",
    "springgreen",
    "steelblue",
    "tan",
    "thistle",
    "tomato",
    "turquoise",
    "violet",
    "wheat",
    "white",
    "whitesmoke",
    "yellow",
    "yellowgreen"
  )
  return(palette)
}
colorPaletteScores <- function(){
  palette <- colorPalette()
  palette <- c(
    palette[ 8: 1],
    palette[16: 9],
    palette[24:17],
    palette[32:25]
  )
  return(palette)
}
plotFragmentsFromDataList <- function(dataList, xInterval = NULL, yInterval = NULL, relative = FALSE){
  if(is.null(xInterval)){
    xMin <- min(dataList$fragmentMasses)
    xMax <- max(dataList$fragmentMasses)
    xInterval <- c(xMin, xMax)
  } else {
    xMin <- xInterval[[1]]
    xMax <- xInterval[[2]]
  }
  
  massIntervalSelection <- dataList$ms2_masses >= xMin & dataList$ms2_masses <= xMax
  #numberOfFragments <- dataList$ms2_numberOfFragments[massIntervalSelection]
  #masses            <- dataList$ms2_masses[massIntervalSelection]
  
  minimumNumberOfFragments <- 5
  selection <- massIntervalSelection & (dataList$ms2_numberOfFragments >= minimumNumberOfFragments)
  
  numberOfFragments <- dataList$ms2_numberOfFragments[selection]
  masses            <- dataList$ms2_masses[selection]
  
  colors <- cmap(x = numberOfFragments, map = dataList$colorMapFragmentData)
  
  #colors <- rep(x = "black", times = length(dataList$ms2_masses))
  colors <- cmap(x = numberOfFragments, map = dataList$colorMapFragmentData)
  
  if(relative)
    numberOfFragments <- numberOfFragments / dataList$numberOfPrecursors
  
  plotFragments(masses=masses, numberOfFragments=numberOfFragments, colors = colors, numberOfPrecursors=dataList$numberOfPrecursors, xInterval=xInterval, yInterval=yInterval)
}  
plotFragments <- function(masses, numberOfFragments, colors = NULL, numberOfPrecursors, title = NULL, xInterval = NULL, yInterval = NULL){
  if(is.null(xInterval)){
    xMin <- min(masses)
    xMax <- max(masses)
    xInterval <- c(xMin, xMax)
  } else {
    xMin <- xInterval[[1]]
    xMax <- xInterval[[2]]
  }
  
  yMin <- 0
  if(length(masses) == 0)
    yMax <- 1
  else
    yMax <- max(numberOfFragments)
  if(is.null(yInterval))
    yInterval <- c(yMin, yMax)
  
  if(is.null(colors))
    colors <- rep(x = "black", times = length(masses))
  
  #########################################################################################################
  ## plot
  par(mar=c(5,3,ifelse(test = is.null(title), yes = 2, no = 4),3), mgp = c(2, 1, 0))  ## c(bottom, left, top, right)
  #plot(x = dataList$ms2_masses, y = dataList$ms2_numberOfFragments, xlab = "Fragment mass", ylab = "Precursors", xlim = xInterval, ylim = yInterval, main = "Fragment plot", col = colors, pch=19, cex=1., xaxt='n')
  #plot(x = masses, y = numberOfFragments, xlab = "", ylab = "Precursors", xlim = xInterval, ylim = yInterval, main = NULL, col = colors, pch=19, cex=1., xaxt='n')
  #plot(x = NULL, y = NULL, xlab = "m/z", ylab = "Number of spectra", xlim = xInterval, ylim = yInterval, main = NULL, col = colors, pch=19, cex=1., xaxt='n')
  plot(x = NULL, y = NULL, xlab = "m/z", ylab = "Number of spectra", xlim = xInterval, ylim = yInterval, main = NULL, pch=19, cex=1., xaxt='n')
  if(!is.null(title))
    title(title, line = 3)
  axis(side = 3)
  
  ## axis
  dataOrder <- order(numberOfFragments)
  #axis(side = 1, at = dataList$ms2_masses, labels = dataList$ms2_masses, las = 2, tick = TRUE, col = colors)
  #for(i in 1:length(dataList$ms2_masses))
  for(i in dataOrder)
    axis(side = 1, at = masses[[i]], labels = format(x = masses[[i]], digits = 1, nsmall = 4), las = 2, tick = TRUE, col.axis = colors[[i]])
  
  points(x = masses[dataOrder], y = numberOfFragments[dataOrder], col = colors[dataOrder], type = "h", lwd=4)
  #points(x = masses[dataOrder], y = numberOfFragments[dataOrder], col = colors[dataOrder], pch=19, cex=1.)
  
  numberOfFragmentsInPercent <- numberOfFragments / numberOfPrecursors * 100
  yInterval <- c(0, yInterval[[2]] / numberOfPrecursors * 100)
  par(new = TRUE)
  plot(x = c(0, masses), y = c(0, numberOfFragmentsInPercent), xlim = xInterval, ylim = yInterval, axes=FALSE, type="n", xlab = "", ylab = "")
  axis(side = 4, line = NA, at = as.integer(pretty(c(0, numberOfFragmentsInPercent))))
  mtext(side = 4, line = 2, text = "Number of spectra in %")
  
  resultObj <- list()
  resultObj$poiFragmentX <- masses
  resultObj$poiFragmentY <- numberOfFragments
  
  return(resultObj)
}
plotFragments2 <- function(masses, numberOfFragments, numberOfPrecursors, xInterval = NULL, yInterval = NULL){
  if(FALSE){
    masses_ <<- masses
    numberOfFragments_ <<- numberOfFragments
    numberOfPrecursors_ <<- numberOfPrecursors
  }
  if(FALSE){
    masses <- masses_
    numberOfFragments <- numberOfFragments_
    numberOfPrecursors <- numberOfPrecursors_
  }
  
  
  if(is.null(xInterval)){
    xMin <- min(masses)
    xMax <- max(masses)
    xInterval <- c(xMin, xMax)
  } else {
    xMin <- xInterval[[1]]
    xMax <- xInterval[[2]]
  }
  
  massIntervalSelection <- masses >= xMin & masses <= xMax
  #numberOfFragments <- numberOfFragments[massIntervalSelection]
  #masses            <- masses[massIntervalSelection]
  
  minimumNumberOfFragments <- 1
  selection <- massIntervalSelection & (numberOfFragments >= minimumNumberOfFragments)
  
  numberOfFragments <- numberOfFragments[selection]
  masses            <- masses[selection]
  
  ms2PlotDataColorMapFragmentData  <- makecmap(
    x = c(0, max(numberOfFragments)), n = 100, 
    colFn = colorRampPalette(c('grey', 'black'))
  )
  #colors <- rep(x = "black", times = length(masses))
  colors <- cmap(x = numberOfFragments, map = ms2PlotDataColorMapFragmentData)
  
  yMin <- 0
  if(sum(selection) == 0)
    yMax <- 1
  else
    yMax <- max(numberOfFragments)
  if(is.null(yInterval))
    yInterval <- c(yMin, yMax)
  
  
  #########################################################################################################
  ## plot
  par(mar=c(5,3,2,3), mgp = c(2, 1, 0))  ## c(bottom, left, top, right)
  #plot(x = masses, y = numberOfFragments, xlab = "Fragment mass", ylab = "Precursors", xlim = xInterval, ylim = yInterval, main = "Fragment plot", col = colors, pch=19, cex=1., xaxt='n')
  #plot(x = masses, y = numberOfFragments, xlab = "", ylab = "Precursors", xlim = xInterval, ylim = yInterval, main = NULL, col = colors, pch=19, cex=1., xaxt='n')
  plot(x = NULL, y = NULL, xlab = "m/z", ylab = "Number of spectra", xlim = xInterval, ylim = yInterval, main = NULL, col = colors, pch=19, cex=1., xaxt='n')
  axis(side = 3)
  
  ## axis
  dataOrder <- order(numberOfFragments)
  #axis(side = 1, at = masses, labels = masses, las = 2, tick = TRUE, col = colors)
  #for(i in 1:length(masses))
  for(i in dataOrder)
    axis(side = 1, at = masses[[i]], labels = format(x = masses[[i]], digits = 1, nsmall = 4), las = 2, tick = TRUE, col.axis = colors[[i]])
  
  points(x = masses[dataOrder], y = numberOfFragments[dataOrder], col = colors[dataOrder], type = "h", lwd=4)
  #points(x = masses[dataOrder], y = numberOfFragments[dataOrder], col = colors[dataOrder], pch=19, cex=1.)
  
  ## 2nd y-axis TODO
  numberOfFragmentsInPercent <- numberOfFragments / numberOfPrecursors * 100
  par(new = TRUE)
  plot(x = c(0, masses), y = c(0, numberOfFragmentsInPercent), xlim = xInterval, axes=FALSE, type="n", xlab = "", ylab = "")
  axis(side = 4, line = NA, at = as.integer(pretty(c(0, numberOfFragmentsInPercent))))
  mtext(side = 4, line = 2, text = "Number of spectra in %")
  
  resultObj <- list()
  resultObj$poiFragmentX <- masses
  resultObj$poiFragmentY <- numberOfFragments
  
  return(resultObj)
}
calcPlotSpectrumVsClass_small_old <- function(dataX_spec, dataY_spec, dataX_class, dataY_class, xInterval){
  yInterval <- c(-1, 1)
  
  colors_spec <- rep(x = "grey", times = length(dataX_spec))
  colors_spec[dataX_spec %in% dataX_class] <- "black"
  
  colors_class <- rep(x = "black", times = length(dataY_spec))
  
  dataY_class <- -dataY_class
  
  par(mar=c(0,0,0,0))  ## c(bottom, left, top, right)
  plot(NA, ylab = "", xlab = "", xlim = xInterval, ylim = yInterval, xaxt='n', yaxt='n')
  
  segments(x0 = xInterval[[1]], x1 = xInterval[[2]], y0 = 0, y1 = 0, col = "black", lwd = 1)
  
  points(x = dataX_spec,  y = dataY_spec,  col = colors_spec,  type = "h", lwd=4)
  points(x = dataX_class, y = dataY_class, col = "black", type = "h", lwd=4)
  
}
calcPlotSpectrumVsClass_small <- function(masses_spec, intensity_spec, colors_spec, masses_class, frequency_class, colors_class, xInterval){
  yInterval <- c(-1, 1)
  
  intensity_spec[intensity_spec > 1] <- 1
  frequency_class <- -frequency_class
  
  ## plot
  par(mar=c(0,0,0,0))  ## c(bottom, left, top, right)
  plot(NA, ylab = "", xlab = "", xlim = xInterval, ylim = yInterval, xaxt='n', yaxt='n')
  
  ## x-axis line
  xIntervalSize <- xInterval[[2]] - xInterval[[1]]
  xl <- xInterval[[1]] - xIntervalSize
  xr <- xInterval[[2]] + xIntervalSize
  segments(x0 = xl, x1 = xr, y0 = 0, y1 = 0, col = "black", lwd = 1)
  
  ## sticks
  points(x = masses_spec,  y = intensity_spec,  col = colors_spec,  type = "h", lwd=4)
  points(x = masses_class, y = frequency_class, col = colors_class, type = "h", lwd=4)
}
calcPlotSpectrumVsClass_big <- function(masses_spec, intensity_spec, colors_spec, masses_class, frequency_class, colors_class, singleSpec, xInterval){
  if(TRUE){
    masses_spec_ <<- masses_spec
    intensity_spec_ <<- intensity_spec
    colors_spec_ <<- colors_spec
    masses_class_ <<- masses_class
    frequency_class_ <<- frequency_class
    colors_class_ <<- colors_class
    singleSpec_ <<- singleSpec
    xInterval_ <<- xInterval
  }
  if(FALSE){
    masses_spec <- masses_spec_
    intensity_spec <- intensity_spec_
    colors_spec <- colors_spec_
    masses_class <- masses_class_
    frequency_class <- frequency_class_
    colors_class <- colors_class_
    singleSpec <<- singleSpec_
    xInterval <- xInterval_
  }
  
  onlyClass <- is.null(masses_class)
  yInterval <- c(ifelse(test = is.null(masses_class), yes = 0, no = -1), 1)
  
  ## abundances greater one
  intensity_spec[intensity_spec > 1] <- 1
  
  if(!is.null(frequency_class))
    frequency_class <- -frequency_class
  
  yTickPositions <- c(-1, -0.75, -0.5, -0.25, 0, 0.25, 0.5, 0.75, 1)
  yTickLabels <- c(1, "", 0.5, "", 0, "", 0.5, "", 1)
  
  pointSizes <- rep(x = ms2StickPointSizeInitial, times = length(masses_spec))
  pointSizesSmall <- rep(x = ms2StickPointSizeInitialSmall, times = length(masses_spec))
  pointColors <- rep(x = "black", times = length(masses_spec))
  pointColorsSmall <- rep(x = "gray", times = length(masses_spec))
  
  these <- which(colors_spec == "black")
  if(length(these) == 0)
    these <- length(masses_spec)+1
  
  plotTitle <-  ifelse(test = singleSpec, yes = "Spectrum versus class", no = 
                ifelse(test = onlyClass,  yes = "Metabolite family spectrum", no = "Metabolite family versus class"))
  yAxisLabel <- ifelse(test = singleSpec, yes = "Frequency / Intensity", no = 
                ifelse(test = onlyClass,  yes = "Frequency", no = "Frequency / Frequency"))
  
  ## plot
  par(mar=c(6,4.1,4,0.1), mgp = c(3, 1, 0))  ## c(bottom, left, top, right)
  plot(NA, ylab = yAxisLabel, xlab = "m/z", xlim = xInterval, ylim = yInterval, xaxt='n', yaxt='n')
  axis(side = 2, at = yTickPositions, labels = yTickLabels)
  axis(side = 3)
  title(plotTitle, line = 2.5)
  #mtext(side = 3, "m/z", line = 2)
  
  ## x-axis line
  xIntervalSize <- xInterval[[2]] - xInterval[[1]]
  xl <- xInterval[[1]] - xIntervalSize
  xr <- xInterval[[2]] + xIntervalSize
  segments(x0 = xl, x1 = xr, y0 = 0, y1 = 0, col = "black", lwd = 1)
  
  ## axis with the individual fragment m/z's (ticks, labels)
  axis(side = 1, at = masses_spec, labels = FALSE, las = 2)
  axis(side = 1, at = masses_spec[-these], labels = format(x = masses_spec[-these], digits = 1, nsmall = 4), las = 2, tick = FALSE, col.axis = "grey")
  if(length(these) == 1){
    if(these != length(masses_spec)+1)
      axis(side = 1, at = masses_spec[ these], labels = format(x = masses_spec[ these], digits = 1, nsmall = 4), las = 2, tick = FALSE, col.axis = "black")
  } else {
    axis(side = 1, at = masses_spec[ these], labels = format(x = masses_spec[ these], digits = 1, nsmall = 4), las = 2, tick = FALSE, col.axis = "black")
  }
  
  ## sticks
  points(x = masses_spec[-these],  y = intensity_spec[-these],  col = colors_spec[-these],  type = "h", lwd=4)
  if(!is.null(masses_class)){
    these2 <- colors_class == "black"
    points(x = masses_class[!these2], y = frequency_class[!these2], col = colors_class[!these2], type = "h", lwd=4)
    points(x = masses_class[ these2], y = frequency_class[ these2], col = colors_class[ these2], type = "h", lwd=4)
  }
  
  ## points
  points(x = masses_spec, y = intensity_spec, col = pointColors,      pch=19, cex=pointSizes)
  points(x = masses_spec, y = intensity_spec, col = pointColorsSmall, pch=19, cex=pointSizesSmall)
  
  ## black ones
  points(x = masses_spec[these], y = intensity_spec[these], col = colors_spec[these], type = "h", lwd=4)
  points(x = masses_spec[these], y = intensity_spec[these], col = pointColors[these], pch=19, cex=pointSizes[these])
  points(x = masses_spec[these], y = intensity_spec[these], col = pointColorsSmall[these], pch=19, cex=pointSizesSmall[these])
  
  ## plot labels
  graphics::text(labels = ifelse(test = singleSpec, yes = "Fragments from spectrum", no = "Fragments from spectra"), x = xInterval[[2]], y = 0.9, pos = 2, adj = c(0,0))
  graphics::text(labels = "Fragments from class",    x = xInterval[[2]], y = -0.9, pos = 2, adj = c(0,0))
}

================
File: R/R_packages.R
================
load_metfamily_dependencies <- function() 
{
  ##############################################################################################################
  ## GUI
  library("shiny")
  library("htmltools")
  library("shinyjs")
  library("DT")
  library("colourpicker")
  library("shinyBS")
  library("shinybusy")
  library(egg)
  
  ##############################################################################################################
  ## mass spectrometry
  library("mzR")
  library("xcms")
  
  ##############################################################################################################
  ## MS1 analyses
  library("FactoMineR")
  library("mixOmics")
  library("pcaMethods")
  library(searchable)
  library(gdata)
  ##############################################################################################################
  ## tools
  library("matrixStats")
  library("Matrix")
  library("tools")
  library("stringr")
  library("slam")
  
  ##############################################################################################################
  ## pdf report
  library("knitr")
  
  ##############################################################################################################
  ## plot
  library("cba")
  library("squash")
  library("plotrix")
  library("plotly")
  library("RColorBrewer")
}

================
File: R/readMetaboScape.R
================
library(openxlsx2)
library(dplyr)
library(purrr)
library(QFeatures)
library(SummarizedExperiment)

#' Read Metaboscape Output File into a QFeatures Object
#'
#' This function reads a metabolite profile output file (.xlsx) from Metaboscape and 
#' converts it into a QFeatures object.
#'
#' @param file A character string specifying the path to the Metaboscape output file (Excel format).
#' @param version A character string specifying the version of Metaboscape used to generate the file.
#'   This parameter is currently not used.
#'
#' @return A QFeatures object containing:
#'   \itemize{
#'     \item An assay named "exampleAssay" with the metabolite counts.
#'     \item Row data (feature metadata) extracted from the input file.
#'     \item Column data (sample metadata) extracted from the sample names, including injection order and sample name.
#'   }
#'   
#' @importFrom openxlsx2 read_xlsx
#' @importFrom QFeatures QFeatures
#' @importFrom SummarizedExperiment SummarizedExperiment
#'
#' @export
#'
#' @examples
#' \dontrun{
#' # Assuming you have a Metaboscape output file named "data.xlsx":
#' qf <- readMetaboscape("data.xlsx") #TODO: System file 
#'
#' 
#' # Examine the structure of the resulting QFeatures object
#' qf
#' 
#' # Access the assay data
#' assay(qf[["exampleAssay"]])
#' 
#' # Access the row data (feature metadata)
#' rowData(qf[["exampleAssay"]])
#' 
#' # Access the column data (sample metadata)
#' colData(qf)
#' }
#'
#'
#' @details
#' @note 
#'
#' @seealso 
#' \code{\link[QFeatures]{QFeatures}} for more information on the QFeatures class.
#' \code{\link[SummarizedExperiment]{SummarizedExperiment}} for details on the underlying data structure.
#' 
#' @references
#' #TODO: Bruker metaboscape site 
#' #TODO: Ordering ?
#' 

readMetaboscape <- function(file, version){
  
  table <- read_xlsx(file)
  rownames(table) <- table[,1]
  colnames <- colnames(table)
  colIdsSamples <- grepl("\\d+$", colnames)
  
  startOfSamples <- which(colIdsSamples)[1]
  
  # Extract ids and counts data
  ids <- table[,1]
  countsRaw     <- table[,colIdsSamples]
  countsNumeric <- apply(countsRaw, 2, as.numeric)
  counts <- as.matrix(countsNumeric)
  rownames(counts) <- ids
  
  # Extract rowData
  rowData <- table[,!colIdsSamples]
  rownames(rowData) <- ids 
 
  # Extract colData from sample Names
  sampleNames <- colnames(table[,colIdsSamples])
  colDataRaw <- sapply(sampleNames, function(x) {
    # find position of the first character before the Run number
    pos <- max(gregexpr("[^0-9]", x)[[1]])
      c(substr(x, 1, (pos - 1)), substr(x, pos + 1, nchar(x)))
  })
  colData <- data.frame("Injection order" = colDataRaw[2,],
                       "Sample name" = colDataRaw[1,])
                    
  # Create SummarizedExperiment object
  sumExp <- SummarizedExperiment(assays = list(counts = counts),
                                 rowData = rowData,
                                 colData = colData)
  rownames(sumExp)
  # Create QFeatures object
  qf <- QFeatures(list(exampleAssay = sumExp), colData = colData(sumExp))
  qf
}

================
File: R/readMSDial.R
================
#' Read MS-DIAL Output File into a QFeatures Object
#'
#' This function reads the output file from MS-DIAL and 
#' converts it into a QFeatures object.
#'
#' @param file A string with the path to the MS-DIAL output file.
#' @param version A character string specifying the version of MS-DIAL used to generate the file.
#'   This parameter is currently not used.
#'
#' @return A QFeatures object containing:
#'   \itemize{
#'     \item An assay named "exampleAssay" with the metabolite counts.
#'     \item Row data (feature metadata) extracted from the input file.
#'     \item Column data (sample metadata) extracted from the input file.
#'   }
#'
#' @export
#'
#' @examples
#' \dontrun{
#' # Assuming you have an MS-DIAL output file named "Metabolite_profile_showcase.txt" in a "data" directory:
#' qf <- readMSDial("data/Metabolite_profile_showcase.txt")
#' 
#' # Examine the structure of the resulting QFeatures object
#' qf
#' 
#' # Access the assay data
#' assay(qf[["exampleAssay"]])
#' 
#' # Access the row data (feature metadata)
#' rowData(qf[["exampleAssay"]])
#' 
#' # Access the column data (sample metadata)
#' colData(qf)
#' }
#'
#' @importFrom QFeatures QFeatures
#' @importFrom SummarizedExperiment SummarizedExperiment
#' @importFrom S4Vectors DataFrame
#'
#' @seealso 
#' \code{\link[QFeatures]{QFeatures}} for more information on the QFeatures class.
#' \code{\link[SummarizedExperiment]{SummarizedExperiment}} for details on the underlying data structure.
#'
#' @note 
#'
#'
#' @references
#' 
readMSDial <- function(file, version){
    table <- read.table(file, fill = TRUE, sep = "\t",
                        quote = "", header = FALSE)
    
    # Identify the starting row and column of the data
    startRow <- which(table[, 1] != "")[1]
    startCol <- which(table[1, ] != "")[1]
    ##TODO: version dependent error message if startRow or startCol are not as expected.
    
    # Split the table in parts
    colDataRaw <- table[1:startRow, startCol:ncol(table)]
    rowDataRaw <- table[startRow:nrow(table), 1:(startCol)]
    countsRaw <- table[startRow:nrow(table), startCol:ncol(table)]
    
    # Extract ids and counts data
    ids <- rowDataRaw[-1, 1]
    counts <- as.matrix(countsRaw[-1, -1])
    counts <- matrix(as.numeric(counts), nrow = nrow(counts), ncol = ncol(counts))
    colnames(counts) <- as.character(countsRaw[1, -1])
    rownames(counts) <- ids
    
    # Ensure row names of colData match counts column names
    colData <- data.frame(t(colDataRaw[-nrow(colDataRaw), -1]))
    rownames(colData) <- as.character(colDataRaw[nrow(colDataRaw), -1])
    colnames(colData) <- as.character(colDataRaw[-nrow(colDataRaw), 1])

    # Ensure row names of rowData match counts row names
    rowData <- data.frame(rowDataRaw[-1, ], row.names = ids)
    colnames(rowData) <- as.character(rowDataRaw[1,])

    # Create SummarizedExperiment object
   
    sumExp <- SummarizedExperiment(assays = list(counts = counts),
                                    rowData = rowData,
                                    colData = colData)
    ##TODO: Metadata with data source and version 
    
    # Create QFeatures object
    qf <- QFeatures(list(exampleAssay = sumExp), colData = colData(sumExp))
    qf
    ##TODO: name
  }

================
File: R/runMetFamily.R
================
##' Run the web app in browser
##'
##' @title Start the web app in browser
##' @export
##' @author Hendrik Treutler, Steffen Neumann
##' @examples
##' \dontrun{
##' runMetFamily()
##' }
runMetFamily <- function(){
  shiny::runApp(appDir = system.file("MetFamily", package = "MetFamily"), 
  launch.browser = TRUE)
}

startMetFamily <- runMetFamily

================
File: R/TreeAlgorithms.R
================
#########################################################################################
## tree helper
analyzeTreeFromRoot <- function(dataList, cluster, filter){
  numberOfPrecursorsFiltered <- length(filter)
  numberOfInnerNodes <- numberOfPrecursorsFiltered - 1
  rootIndex <- length(cluster$height)
  
  ## create fields and compute stuff
  innerNodeHeightIncreasesHere <<- vector(mode = "logical", length = numberOfInnerNodes)
  innerNodeMembersTreeLeavesHere <<- list()
  innerNodeMembersPrecursorsHere <<- list()
  innerNodeMembersTreeClustersHere <<- list()
  innerNodeFeaturesIntersectionHere <<- list()
  innerNodeFeaturesUnionHere <<- list()
  innerNodeFeaturesCountsMatrixHere <<- sparseMatrix(i = numberOfInnerNodes, j = length(dataList$fragmentMasses), x = 0)
  innerNodeFeaturesPresentHere <<- list()
  #innerNodeFeaturesIntersectionCounterHere <<- vector(mode = "numeric", length = numberOfInnerNodes)
  #innerNodeFeaturesUnionCounterHere <<- vector(mode = "logical", length = numberOfInnerNodes)
  innerNodePositionHere <<- vector(mode = "numeric", length = numberOfInnerNodes)
  leafHeightsHere <<- vector(mode = "numeric", length = numberOfPrecursorsFiltered)
  innerNodeMembersPrecursorsHere[seq_len(numberOfPrecursorsFiltered)] <<- NA
  
  analyzeTree(dataList, cluster, filter, rootIndex)
  
  ## box
  resultObj <- list()
  resultObj$innerNodeHeightIncreases <- innerNodeHeightIncreasesHere
  resultObj$innerNodeMembersTreeLeaves <- innerNodeMembersTreeLeavesHere
  resultObj$innerNodeMembersPrecursors <- innerNodeMembersPrecursorsHere
  resultObj$innerNodeMembersTreeClusters <- innerNodeMembersTreeClustersHere
  resultObj$innerNodeFeaturesIntersection <- innerNodeFeaturesIntersectionHere
  resultObj$innerNodeFeaturesUnion <- innerNodeFeaturesUnionHere
  resultObj$innerNodeFeaturesCountsMatrix <- innerNodeFeaturesCountsMatrixHere
  resultObj$innerNodeFeaturesPresent <- innerNodeFeaturesPresentHere
  #resultObj$innerNodeFeaturesIntersectionCounter <- innerNodeFeaturesIntersectionCounterHere
  #resultObj$innerNodeFeaturesUnionCounter <- innerNodeFeaturesUnionCounterHere
  resultObj$innerNodePosition <- innerNodePositionHere
  resultObj$leafHeights <- leafHeightsHere
  
  return(resultObj)
}
analyzeTree <- function(dataList, cluster, filter, nodeIdx){
  if(nodeIdx < 0){
    ###################################
    ## leaf
    leafIdx <- -nodeIdx
    precursorIndex <- filter[leafIdx]
    featureValues <- dataList$featureMatrix[precursorIndex, ]
    featuresBinary <- featureValues != 0
    featuresBinaryIntersection <- featuresBinary
    featuresBinaryUnion        <- featuresBinary
    featureCounts <- vector(length = length(featuresBinary))
    featureCounts[featuresBinary] <- 1
    featuresCounter <- sum(featuresBinary)
    #featuresCounterIntersection <- featuresCounter
    #featuresCounterUnion        <- featuresCounter
    position <- match(x = leafIdx, table = cluster$order)
    featuresAnnotations <- dataList$annoArrayOfLists[[precursorIndex]]
    
    ## box
    resultObj <- list()
    resultObj$membersTreeLeaves <- leafIdx
    resultObj$membersPrecursors <- precursorIndex
    resultObj$membersTreeClusters <- NULL
    resultObj$featuresBinaryIntersection <- featuresBinaryIntersection
    resultObj$featuresBinaryUnion <- featuresBinaryUnion
    resultObj$featuresCounts <- featureCounts
    #resultObj$featuresCounterIntersection <- featuresCounterIntersection
    #resultObj$featuresCounterUnion        <- featuresCounterUnion
    resultObj$position <- position
    resultObj$featuresAnnotations <- featuresAnnotations
    
    return(resultObj)
  } else {
    ###################################
    ## inner node
    resultObj.l <- analyzeTree(dataList, cluster, filter, cluster$merge[nodeIdx, 1])
    resultObj.r <- analyzeTree(dataList, cluster, filter, cluster$merge[nodeIdx, 2])
    
    membersTreeLeaves <- c(resultObj.l$membersTreeLeaves, resultObj.r$membersTreeLeaves)
    membersPrecursors <- c(resultObj.l$membersPrecursors, resultObj.r$membersPrecursors)
    membersTreeClusters <- c(resultObj.l$membersTreeClusters, resultObj.r$membersTreeClusters, nodeIdx)
    featuresBinaryIntersection <- resultObj.l$featuresBinaryIntersection & resultObj.r$featuresBinaryIntersection
    featuresBinaryUnion        <- resultObj.l$featuresBinaryUnion        | resultObj.r$featuresBinaryUnion
    featuresCounts <- resultObj.l$featuresCounts + resultObj.r$featuresCounts
    #featuresCounterIntersection <- sum(featuresBinaryIntersection)
    #featuresCounterUnion        <- sum(featuresBinaryUnion)
    position <- (resultObj.l$position + resultObj.r$position) / 2
    featuresAnnotations <- intersect(x = unlist(resultObj.l$featuresAnnotations), y = unlist(resultObj.r$featuresAnnotations))
    
    ## box
    resultObj <- list()
    resultObj$membersTreeLeaves <- membersTreeLeaves
    resultObj$membersPrecursors <- membersPrecursors
    resultObj$membersTreeClusters <- membersTreeClusters
    resultObj$featuresBinaryIntersection <- featuresBinaryIntersection
    resultObj$featuresBinaryUnion <- featuresBinaryUnion
    resultObj$featuresCounts <- featuresCounts
    #resultObj$featuresCounterIntersection <- featuresCounterIntersection
    #resultObj$featuresCounterUnion <- featuresCounterUnion
    resultObj$position <- position
    resultObj$featuresAnnotations <- featuresAnnotations
    
    ## set values
    innerNodeMembersTreeLeavesHere[[nodeIdx]] <<- resultObj$membersTreeLeaves
    innerNodeMembersTreeClustersHere[[nodeIdx]] <<- resultObj$membersTreeClusters
    innerNodeMembersPrecursorsHere[[nodeIdx]] <<- resultObj$membersPrecursors
    innerNodePositionHere[[nodeIdx]] <<- resultObj$position
    innerNodeFeaturesIntersectionHere[[nodeIdx]] <<- which(resultObj$featuresBinaryIntersection)
    innerNodeFeaturesUnionHere[[nodeIdx]] <<- which(resultObj$featuresBinaryUnion)
    innerNodeFeaturesCountsMatrixHere[nodeIdx, ] <<- resultObj$featuresCounts
    innerNodeFeaturesPresentHere[[nodeIdx]] <<- sum(resultObj$featuresCounts / length(resultObj$membersPrecursors) >= minimumProportionOfLeafs)
    #innerNodeFeaturesIntersectionCounterHere[[nodeIdx]] <<- resultObj$featuresCounterIntersection
    #innerNodeFeaturesUnionCounterHere[[nodeIdx]] <<- resultObj$featuresCounterUnion
    
    ## leaf heights in case of leafs and check wether to show a poi or not
    height <- cluster$height[[nodeIdx]]
    idxLeft <- cluster$merge[[nodeIdx, 1]]
    idxRight <- cluster$merge[[nodeIdx, 2]]
    increaseBelow <- FALSE
    
    ## left and right node height
    if(idxLeft < 0){
      height.l <- height
      leafHeightsHere[[-idxLeft]] <<- height.l
    } else {
      height.l <- cluster$height[[idxLeft]]
      increaseBelow <- increaseBelow | innerNodeHeightIncreasesHere[[idxLeft]]
    }
    if(idxRight < 0){
      height.r <- height
      leafHeightsHere[[-idxRight]] <<- height.r
    } else {
      height.r <- cluster$height[[idxRight]]
      increaseBelow <- increaseBelow | innerNodeHeightIncreasesHere[[idxRight]]
    }
    
    ## is only two leafs below?
    increasesHere <- any(height > height.l, height > height.r, increaseBelow)
    innerNodeHeightIncreasesHere[[nodeIdx]] <<- any(height > height.l, height > height.r, increaseBelow)
    
    if(increasesHere){
      if(idxLeft >= 0)  innerNodeHeightIncreasesHere[[idxLeft]] <<- TRUE
      if(idxRight >= 0) innerNodeHeightIncreasesHere[[idxRight]] <<- TRUE
    }
    
    return(resultObj)
  }
}
analyzeTreeFromRootForAnnotations <- function(dataList, cluster, filter){
  numberOfPrecursorsFiltered <- length(filter)
  numberOfInnerNodes <- numberOfPrecursorsFiltered - 1
  rootIndex <- length(cluster$height)
  
  ## create fields and compute stuff
  innerNodeFeaturesAnnotationsHere <<- list()
  
  analyzeTreeForAnnotations(dataList, cluster, filter, rootIndex)
  
  ## box
  resultObj <- list()
  resultObj$innerNodeFeaturesAnnotations <- innerNodeFeaturesAnnotationsHere
  
  return(resultObj)
}
analyzeTreeForAnnotations <- function(dataList, cluster, filter, nodeIdx){
  if(nodeIdx < 0){
    ###################################
    ## leaf
    leafIdx <- -nodeIdx
    precursorIndex <- filter[leafIdx]
    featuresAnnotations <- dataList$annoArrayOfLists[[precursorIndex]]
    
    #print(paste(nodeIdx, featuresAnnotations, class(featuresAnnotations), length(featuresAnnotations)))
    
    ## box
    resultObj <- list()
    resultObj$featuresAnnotations <- featuresAnnotations
    
    return(resultObj)
  } else {
    ###################################
    ## inner node
    resultObj.l <- analyzeTreeForAnnotations(dataList, cluster, filter, cluster$merge[nodeIdx, 1])
    resultObj.r <- analyzeTreeForAnnotations(dataList, cluster, filter, cluster$merge[nodeIdx, 2])
    
    if(length(resultObj.l$featuresAnnotations) > 0 & length(resultObj.r$featuresAnnotations) > 0)
      featuresAnnotations <- intersect(x = unlist(resultObj.l$featuresAnnotations), y = unlist(resultObj.r$featuresAnnotations))
    else
      featuresAnnotations <- ""
    
    resultObj <- list()
    if(any(length(featuresAnnotations) == 0, featuresAnnotations == "")){
      featuresAnnotations <- NULL
      resultObj$featuresAnnotations <- ""
    } else {
      resultObj$featuresAnnotations <- featuresAnnotations
      innerNodeFeaturesAnnotationsHere[[nodeIdx]] <<- resultObj$featuresAnnotations
    }
    
    return(resultObj)
  }
}
analyzeTreeForFrequentFragments <- function(clusterDataList, nodeIdx, minimumNumberOfChildren){
  if(nodeIdx < 0){
    ###################################
    ## leaf
    #leafIdx <- -nodeIdx
    #precursorIndex <- filter[leafIdx]
    #getMS2spectrumInfoForPrecursorLeaf()
    
    ## box
    return(data.frame("NodeIdx" = nodeIdx, "numberOfChildren" = 0, "numberOfFrequentFeatures" = NA))
  } else {
    ###################################
    ## inner node
    df.l <- analyzeTreeForFrequentFragments(clusterDataList, clusterDataList$cluster$merge[nodeIdx, 1], minimumNumberOfChildren)
    df.r <- analyzeTreeForFrequentFragments(clusterDataList, clusterDataList$cluster$merge[nodeIdx, 2], minimumNumberOfChildren)
    df <- rbind(df.l, df.r)
    numberOfChildren <- sum(df$"NodeIdx" < 0)
    
    if(numberOfChildren >= minimumNumberOfChildren & any(clusterDataList$innerNodeFeaturesCountsMatrix[nodeIdx, ] > (numberOfChildren * minimumProportionOfLeafs))){
      if(any(df$numberOfFrequentFeatures > 0, na.rm = TRUE))
        df <- df[-which(df$numberOfFrequentFeatures > 0), ]
      df[nrow(df)+1, ] <- c(nodeIdx, numberOfChildren, sum(clusterDataList$innerNodeFeaturesCountsMatrix[nodeIdx, ] > (numberOfChildren * minimumProportionOfLeafs)))
    }
    
    return(df)
  }
}
getSetOfSubTreesFromRootForMass <- function(dataList, fragmentMass, filter, clusterDataList){
  yesNoFunction <- function(precursorIndex){
    features <- dataList$featureIndeces[[precursorIndex]]
    fragmentMasses <- dataList$fragmentMasses[features]
    comprisesFragmentMass <- any(fragmentMasses == fragmentMass)
    return(comprisesFragmentMass)
  }
  getSetOfSubTreesFromRoot(
    filter = filter, 
    clusterDataList = clusterDataList, 
    yesNoFunction = yesNoFunction
  )
}
getSetOfSubTreesFromRootForPrecursorSet <- function(dataList, precursorSet, filter, clusterDataList){
  yesNoFunction <- function(precursorIndex){
    take <- precursorIndex %in% precursorSet
    return(take)
  }
  getSetOfSubTreesFromRoot(
    filter = filter, 
    clusterDataList = clusterDataList, 
    yesNoFunction = yesNoFunction
  )
}
getSetOfSubTreesFromRoot <- function(filter, clusterDataList, yesNoFunction){
  rootIndex <- length(clusterDataList$cluster$height)
  result <- getSetOfSubTrees(filter, clusterDataList, yesNoFunction, rootIndex)
  if(result$criterionFulfilled)
    result$results <- c(result$results, rootIndex)
  return(result$results)
}
getSetOfSubTrees <- function(filter, clusterDataList, yesNoFunction, index){
  result <- list()
  if(index<0){ # it is a leaf
    leafIndex <- -index
    precursorIndex <- filter[[leafIndex]]
    criterionFulfilled <- yesNoFunction(precursorIndex)
    
    result$results <- NULL
    result$criterionFulfilled <- criterionFulfilled
  } else {
    result.l  <- getSetOfSubTrees(filter, clusterDataList, yesNoFunction, clusterDataList$cluster$merge[index, 1])
    result.r  <- getSetOfSubTrees(filter, clusterDataList, yesNoFunction, clusterDataList$cluster$merge[index, 2])
    
    result$results <- c(result.l$results, result.r$results)
    if(result.l$criterionFulfilled & result.r$criterionFulfilled){
      ## both children do comprise the fragment
      result$criterionFulfilled <- TRUE
    } else {
      result$criterionFulfilled <- FALSE
      if((!result.l$criterionFulfilled & result.r$criterionFulfilled) | (result.l$criterionFulfilled & !result.r$criterionFulfilled)){
        ## only one child does comprise the fragment
        if(result.l$criterionFulfilled)
          result$results <- c(result$results, clusterDataList$cluster$merge[index, 1])
        else
          result$results <- c(result$results, clusterDataList$cluster$merge[index, 2])
      } else {
        ## no child does comprise the fragment
      }
    }
  }
  
  #print(paste(index, result$criterionFulfilled, paste(result$results, collapse = ";")))
  return(result)
}
colorSubTree <- function(cluster, index, lwd = 1, lty = 1, col = "black"){
  if(index<0){ # it is a leaf
    a2r_counter <<- a2r_counter + 1
    return(list(
      x = a2r_counter
    ))       
  }
  
  h.m   <- cluster$height[index]
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~ do left
  index.l  <- cluster$merge[index,1]
  
  h.l <- if(index.l<0) 0 else cluster$height[index.l]
  
  out.l   <- colorSubTree(cluster = cluster, index = index.l, col=col, lty=lty, lwd=lwd)
  x.l     <- out.l$x
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~ do right
  index.r  <- cluster$merge[index,2]
  h.r <- if(index.r<0) 0 else cluster$height[index.r]
  out.r   <- colorSubTree(cluster = cluster, index = index.r, col=col, lty=lty, lwd=lwd)
  x.r     <- out.r$x
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~ draw what you have to draw
  x.m  <- (x.r + x.l) / 2  
  
  segments(
    x0  = c(x.l, x.l, x.r),
    x1  = c(x.l, x.r, x.r),
    y0  = c(h.l, h.m, h.r),
    y1  = c(h.m, h.m, h.m),
    col = col,
    lty = lty,
    lwd = lwd
  )
  
  list(x=x.m)
}
colorSubTreeForAnnotations <- function(cluster, index, innerNodeAnnotations, setOfColorSets, parentIndex, parentAnnotation, parentColor, lwd = 1, lty = 1){
  #########################################################################################
  ## leaf case
  if(index<0){ # it is a leaf
    a2r_counter <<- a2r_counter + 1
    return(list(
      x = a2r_counter
    ))       
  }
  
  #########################################################################################
  ## determine color by annotations
  
  ## parent annotations
  if(any(is.null(parentIndex), length(innerNodeAnnotations) < parentIndex))
    ## no parent or no annotation entry
    parentAnnotations <- NULL
  else
    ## there is annotation entry - possibly NULL
    parentAnnotations <- innerNodeAnnotations[[parentIndex]]
  
  ## current annotations
  if(length(innerNodeAnnotations) < index)
    ## no annotation entry
    currentAnnotations <- NULL
  else
    ## there is annotation entry - possibly NULL
    currentAnnotations <- innerNodeAnnotations[[index]]
  
  ## calculate the current color
  newAnnotations <- setdiff(x = currentAnnotations, y = parentAnnotations)
  
  if(length(newAnnotations) == 0){
    if(length(parentAnnotations) == 0){
      ## no annotations at all
      annotation <- "Unknown"
      color      <- "black"
    } else {
      ## there are annotations, but no new ones
      #color <- setOfColorSets[[parentIndex]][[1]]
      annotation <- parentAnnotation
      color      <- parentColor
    }
  } else{
    ## there are new annotations -> take the first new annotation
    #color <- setOfColorSets[[index]][[1]]
    #color <- setOfColorSets[[index]][[length(setOfColorSets[[index]])]]
    newAnnotationsIndeces <- match(x = newAnnotations, table = currentAnnotations)
    
    newAnnotations <- innerNodeAnnotations[[index]][newAnnotationsIndeces]
    newColors      <- setOfColorSets[[index]][newAnnotationsIndeces]
    
    annotation <- newAnnotations[[1]]
    color      <- newColors[[1]]
  }
  
  innerNodeAnnotations[[index]] <<- annotation
  innerNodeColors[[index]] <<- color
  
  #########################################################################################
  ## draw recursively
  h.m   <- cluster$height[index]
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~ do left
  index.l  <- cluster$merge[index,1]
  
  h.l <- if(index.l<0) 0 else cluster$height[index.l]
  
  out.l   <- colorSubTreeForAnnotations(cluster = cluster, index = index.l, innerNodeAnnotations = innerNodeAnnotations, setOfColorSets = setOfColorSets, parentIndex = index, parentAnnotation = annotation, parentColor = color, lty=lty, lwd=lwd)
  x.l     <- out.l$x
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~ do right
  index.r  <- cluster$merge[index,2]
  h.r <- if(index.r<0) 0 else cluster$height[index.r]
  out.r   <- colorSubTreeForAnnotations(cluster = cluster, index = index.r, innerNodeAnnotations = innerNodeAnnotations, setOfColorSets = setOfColorSets, parentIndex = index, parentAnnotation = annotation, parentColor = color, lty=lty, lwd=lwd)
  x.r     <- out.r$x
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~ draw what you have to draw
  x.m  <- (x.r + x.l) / 2  
  
  x0  <- c(out.l$x0,  c(x.l,   x.l,   x.r  ), out.r$x0 )
  x1  <- c(out.l$x1,  c(x.l,   x.r,   x.r  ), out.r$x1 )
  y0  <- c(out.l$y0,  c(h.l,   h.m,   h.r  ), out.r$y0 )
  y1  <- c(out.l$y1,  c(h.m,   h.m,   h.m  ), out.r$y1 )
  col <- c(out.l$col, c(color, color, color), out.r$col)
  
  #segments(
  #  x0  = c(x.l, x.l, x.r),
  #  x1  = c(x.l, x.r, x.r),
  #  y0  = c(h.l, h.m, h.r),
  #  y1  = c(h.m, h.m, h.m),
  #  col = color,
  #  lty = lty,
  #  lwd = lwd
  #)
  
  list(
    x   = x.m,
    x0  = x0,
    x1  = x1,
    y0  = y0,
    y1  = y1,
    col = col
  )
}
drawDendrogram <- function(cluster, index, lwd = 1, lty = 1){
  #########################################################################################
  ## leaf case
  if(index<0){ # it is a leaf
    a2r_counter <<- a2r_counter + 1
    return(list(
      x = a2r_counter
    ))       
  }
  
  #########################################################################################
  ## draw recursively
  h.m   <- cluster$height[index]
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~ do left
  index.l  <- cluster$merge[index,1]
  
  h.l <- ifelse(index.l<0, 0, cluster$height[index.l])
  
  out.l   <- drawDendrogram(cluster = cluster, index = index.l, lty=lty, lwd=lwd)
  x.l     <- out.l$x
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~ do right
  index.r  <- cluster$merge[index,2]
  h.r <- ifelse(index.r<0, 0, cluster$height[index.r])
  out.r   <- drawDendrogram(cluster = cluster, index = index.r, lty=lty, lwd=lwd)
  x.r     <- out.r$x
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~ draw what you have to draw
  x.m  <- (x.r + x.l) / 2  
  
  x0  <- c(out.l$x0,  c(x.l,   x.l,   x.r  ), out.r$x0 )
  x1  <- c(out.l$x1,  c(x.l,   x.r,   x.r  ), out.r$x1 )
  y0  <- c(out.l$y0,  c(h.l,   h.m,   h.r  ), out.r$y0 )
  y1  <- c(out.l$y1,  c(h.m,   h.m,   h.m  ), out.r$y1 )
  #col <- c(out.l$col, c(color, color, color), out.r$col)
  
  #segments(
  #  x0  = c(x.l, x.l, x.r),
  #  x1  = c(x.l, x.r, x.r),
  #  y0  = c(h.l, h.m, h.r),
  #  y1  = c(h.m, h.m, h.m),
  #  col = color,
  #  lty = lty,
  #  lwd = lwd
  #)
  
  list(
    x   = x.m,
    x0  = x0,
    x1  = x1,
    y0  = y0,
    y1  = y1#,
    #col = col
  )
}
colorSubTreeForAnnotations2 <- function(cluster, index, dataList, filter, lwd = 1, lty = 1){
  #########################################################################################
  ## leaf case
  if(index<0){ # it is a leaf
    a2r_counter <<- a2r_counter + 1
    annos  <- unlist(dataList$annoArrayOfLists[filter][[-index]])
    #annos  <- dataList$annoArrayOfLists[[cluster$order[[-index]]]]
    #annos  <- dataList$annoArrayOfLists[[which(cluster$order == -index)]]
    colors <- dataList$annoPresentColorsList[unlist(dataList$annoPresentAnnotationsList) %in% annos]
    
    #print(paste(index, paste(colors, collapse = "-"), paste(annos, collapse = "-")))
    #print(paste("leaf", a2r_counter, index, paste(colors, collapse = "-"), cluster$order[[-index]], which(cluster$order == -index)))
    
    return(list(
      x = a2r_counter,
      x0  = vector(length = 0, mode = "numeric"),
      x1  = vector(length = 0, mode = "numeric"),
      y0  = vector(length = 0, mode = "numeric"),
      y1  = vector(length = 0, mode = "numeric"),
      col = vector(length = 0, mode = "character"),
      annos  = annos,
    #  annos  = "Unknown",
      colors = colors
    #  colors = "black"
    ))
  }
  
  #########################################################################################
  ## draw recursively
  h.m   <- cluster$height[index]
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~ do left
  index.l  <- cluster$merge[index,1]
  
  h.l <- if(index.l<0) 0 else cluster$height[index.l]
  
  out.l     <- colorSubTreeForAnnotations2(cluster = cluster, index = index.l, dataList = dataList, filter = filter, lty=lty, lwd=lwd)
  x.l       <- out.l$x
  annos.l   <- out.l$annos
  colors.l  <- out.l$colors
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~ do right
  index.r  <- cluster$merge[index,2]
  h.r <- if(index.r<0) 0 else cluster$height[index.r]
  out.r     <- colorSubTreeForAnnotations2(cluster = cluster, index = index.r, dataList = dataList, filter = filter, lty=lty, lwd=lwd)
  x.r       <- out.r$x
  annos.r   <- out.r$annos
  colors.r  <- out.r$colors
  
  
  #########################################################################################
  ## determine color by annotations
  annos <- intersect(annos.r, annos.l)
  
  if(length(annos) == 0){
    ## no common annotations
    annos  <- "Unknown"
    colors <- "black"
    color  <- "black"
  } else {
    colors <- colors.l[annos.l %in% annos]
    color  <- colors[[1]]
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~ draw what you have to draw
  x.m  <- (x.r + x.l) / 2  
  
  ## left from bottom to top; on top from left to right; right from bottom to top
  x0  <- c(out.l$x0,  c(x.l,   x.l,   x.r  ), out.r$x0 )
  x1  <- c(out.l$x1,  c(x.l,   x.r,   x.r  ), out.r$x1 )
  y0  <- c(out.l$y0,  c(h.l,   h.m,   h.r  ), out.r$y0 )
  y1  <- c(out.l$y1,  c(h.m,   h.m,   h.m  ), out.r$y1 )
  #col <- c(out.l$col, color, color, color, out.r$col)
  col <- c(out.l$col, color, out.r$col)
  
  #print(paste(
  #  index, index.l, index.r, color
  #  #length(out.l$col), length(out.r$col), length(col), 
  #  #paste(out.l$col, collapse = "-"), paste(out.r$col, collapse = "-"), 
  #  #paste(col, collapse = "-")
  #))
  
  #print(paste("cluster", index, "(", index.l, index.r, ")", color, x.l, x.m, x.r, h.l, h.m, h.r))
  
  #segments(
  #  x0  = c(x.l, x.l, x.r),
  #  x1  = c(x.l, x.r, x.r),
  #  y0  = c(h.l, h.m, h.r),
  #  y1  = c(h.m, h.m, h.m),
  #  col = color,
  #  lty = lty,
  #  lwd = lwd
  #)
  
  list(
    x   = x.m,
    x0  = x0,
    x1  = x1,
    y0  = y0,
    y1  = y1,
    col = col,
    annos  = annos,
    colors = colors
  )
}

================
File: tests/testthat/test_dataprocessing.R
================
test_that("metaboliteProfileParsing works", {
  load(system.file("extdata/testdata/processMS1data.Rdata", package = "MetFamily"))

  d <- dataColumnsNameFunctionFromGroupIndex(groupIdx = 2, sampleNamesToExclude = NA)
  
  ## Test dimensions  
  expect_equal(length(d), 3)
  
  result <- processMS1data(sampleNamesToExclude=sampleNamesToExclude,
                           numberOfMS1features=numberOfMS1features,
                           precursorLabels=precursorLabels,
                           grouXXXps=c("TRI", "LVS"),
                           metaboliteProfileColumnNames=metaboliteProfileColumnNames,
                           dataColumnIndecesFunctionFromGroupIndex=dataColumnIndecesFunctionFromGroupIndex,
                           dataColumnsNameFunctionFromGroupIndex=dataColumnsNameFunctionFromGroupIndex,
                           dataColumnsNameFunctionFromGroupName=dataColumnsNameFunctionFromGroupName,
                           dataColumnsNameFunctionFromGroupNames=dataColumnsNameFunctionFromGroupNames,
                           groupNameFunctionFromDataColumnName=groupNameFunctionFromDataColumnName,
                           tagsSector=tagsSector,
                           metaboliteProfile=metaboliteProfile,
                           progress=FALSE)

expect_equal(min(result$dataFrameMeasurements[,1]), 0)

})

================
File: tests/testthat/test_fileinput.R
================
test_that("trivial", {
    expect_equal(1, 1)
})

test_that("exampledata", {
  filePeakMatrix <- system.file("extdata/showcase/Metabolite_profile_showcase.txt", package = "MetFamily")
  data <- parsePeakAbundanceMatrix(filePeakMatrix, doPrecursorDeisotoping=TRUE,
                                   mzDeviationInPPM_precursorDeisotoping=10, mzDeviationAbsolute_precursorDeisotoping=0.01,
                                   maximumRtDifference=0.05,
                                   progress=FALSE)

  ## Test dimensions  
  expect_equal(nrow(data$dataFrame1), 5403)
  expect_equal(ncol(data$dataFrame1),   20)

  ## Test some values
  expect_true(all(summary(t(data$dataFrame1[1,c("TRI03", "TRI02", "TRI01", "LVS03", "LVS02", "LVS01")])) == c("Min.   : 236.0  ", "1st Qu.: 306.2  ", "Median : 357.5  ", "Mean   : 501.0  ", "3rd Qu.: 554.2  ", "Max.   :1146.0  ")))
  expect_true(all(round(summary(data$dataFrame1[, "TRI01"])) == c(0,     809,    1537,    9818,    3207, 4407926)))
})

test_that("MS-Dial 4.X", {
#   filePeakMatrix <- system.file("extdata/showcase/Metabolite_profile_showcase.txt", package = "MetFamily")
#     data <- parsePeakAbundanceMatrix(filePeakMatrix, doPrecursorDeisotoping, 
# 	mzDeviationInPPM_precursorDeisotoping, mzDeviationAbsolute_precursorDeisotoping, 
# 	maximumRtDifference, 
# 	progress=FALSE)
# 
#     expect_equal(ncol(data$dataFrame), 41)
})

test_that("MSP reading works", {
  
  if(FALSE) {
  fileSpectra <- system.file("extdata/showcase/Metabolite_profile_showcase.msp", package = "MetFamily")
  #load(system.file("extdata/testdata/readMSPreturnObj.Rdata", package = "MetFamily"))
  
  returnObj <- parseMSP(fileSpectra = fileSpectra, 
                        minimumIntensityOfMaximalMS2peak = 2000, 
                        minimumProportionOfMS2peaks = 0.05, 
                        neutralLossesPrecursorToFragments = TRUE,
                        neutralLossesFragmentsToFragments = FALSE,
                        progress = FALSE)

  
  expect_equal(returnObj$numberOfSpectra, 2640)
  expect_equal(returnObj$numberOfSpectraOriginal, 5824)
  expect_equal(returnObj$numberOfMS2PeaksOriginal, 145973)
  expect_equal(returnObj$numberOfMS2PeaksWithNeutralLosses, 68738)
  expect_equal(returnObj$numberOfMS2PeaksAboveThreshold, 34369)
  expect_equal(returnObj$numberOfMS2PeaksBelowThreshold, 109797)
  expect_equal(returnObj$numberOfTooHeavyFragments, 1807)
  expect_equal(returnObj$numberOfSpectraDiscardedDueToNoPeaks, 15)
  expect_equal(returnObj$numberOfSpectraDiscardedDueToMaxIntensity, 3163)
  expect_equal(returnObj$numberOfSpectraDiscardedDueToTooHeavy, 5)
  expect_equal(length(returnObj$precursorMz), 2640)
  expect_equal(returnObj$precursorMz[1], 85)
  expect_equal(length(returnObj$precursorRt), 2640)
  expect_equal(returnObj$precursorRt[1], 10.98)
  
  }
  
  # > str(returnObj, max.level = 1)
  # List of 14
  # $ fileSpectra                              : chr "/tmp/RtmpL82I4E/ff16bb92ac5e87cb202eec2e/0.msp"
  # $ spectraList                              :List of 2640
  # $ numberOfSpectra                          : int 2640
  # $ numberOfSpectraOriginal                  : int 5824
  # $ numberOfMS2PeaksOriginal                 : num 145973
  # $ numberOfMS2PeaksWithNeutralLosses        : num 68738
  # $ numberOfMS2PeaksAboveThreshold           : num 34369
  # $ numberOfMS2PeaksBelowThreshold           : num 109797
  # $ numberOfTooHeavyFragments                : num 1807
  # $ numberOfSpectraDiscardedDueToNoPeaks     : num 15
  # $ numberOfSpectraDiscardedDueToMaxIntensity: num 3163
  # $ numberOfSpectraDiscardedDueToTooHeavy    : num 5
  # $ precursorMz                              : num [1:2640] 85 85 85 85 85 ...
  # $ precursorRt                              : num [1:2640] 10.98 7.42 12.4 16.26 13 ...
  # 
  
  
  
  ##
  ## returnObj contains the following elements:
  ##
  
  # returnObj <- list()
  # returnObj$fileSpectra <- fileSpectra
  # returnObj$spectraList <- list()
  # returnObj$numberOfSpectra <- 0
  # returnObj$numberOfMS2PeaksOriginal <- 0
  # returnObj$numberOfMS2PeaksWithNeutralLosses <- 0
  # returnObj$numberOfMS2PeaksAboveThreshold <- 0
  # returnObj$numberOfMS2PeaksBelowThreshold <- 0
  # returnObj$precursorMz <- vector(mode = "numeric")
  # returnObj$precursorRt <- vector(mode = "numeric")
  
})

test_that("Project reading works", {
    fileName <- system.file("extdata/showcase/Project_file_showcase_annotated.csv.gz", package = "MetFamily")
    readDataList <- readClusterDataFromProjectFile(
      file = fileName,
      progress = FALSE)
    #load("inst/extdata/testdata/readClusterDataFromProjectFile.Rdata")
    
    expect_equal(length(readDataList), 59)
    expect_equal(nrow(readDataList$dataFrameHeader), 3)
    expect_equal(ncol(readDataList$dataFrameHeader), 14570)
    expect_equal(length(readDataList$importParameterSet), 19)

  # 
  # > str(dataList, max.level = 1)
  # List of 59
  # $ dataFrameHeader                        :'data.frame':	3 obs. of  14570 variables:
  #   $ dataFrameMS1Header                     :'data.frame':	3 obs. of  23 variables:
  #   $ dataFrameInfos                         :'data.frame':	2585 obs. of  23 variables:
  #   $ importParameterSet                     :List of 19
  # $ numberOfPrecursors                     : int 2585
  # $ numberOfDuplicatedPrecursors           : int 0
  # $ grouXXXps                              : chr [1:2] "TRI" "LVS"
  # $ columnGroupLabels                      : chr [1:3, 1:2] "TRI" "TRI" "TRI" "LVS" ...
  # ..- attr(*, "dimnames")=List of 2
  # $ groupSampleDataFrame                   :'data.frame':	6 obs. of  4 variables:
  #   $ metaboliteProfileColumnNames           : chr [1:23] "m/z" "RT" "Annotation" "Alignment ID" ...
  # $ tagsSector                             : chr [1:23] "ID" "ID" "AnnotationColors={AS=#0000FF, SQT-glucosides=#FF0000}" "" ...
  # $ fragmentMasses                         : num [1:14547] 69 71 71 71 73 ...
  # $ fragmentFrequency                      : int [1:14547] 19 149 3 4 15 77 1 6 11 1 ...
  # $ fragmentAbundance                      : num [1:14547] 0.1162 0.0899 0.131 0.1033 0.1987 ...
  # $ minimumMass                            : num -1008
  # $ maximumMass                            : num 1198
  # $ precursorLabels                        : chr [1:2585] "    85.005 /   7.42" "    85.005 / 10.98" "    85.005 /   8.58" "    85.005 / 12.40" ...
  # $ dataFrameMeasurements                  :'data.frame':	2585 obs. of  13 variables:
  #   $ meanAllMax                             : num 2441679
  # $ logFoldChangeMax                       : num 10.5
  # $ logAbsMax                              : num 6.7
  # $ colorMatrixDataFrame                   : chr [1:2585, 1:13] "#8AFF00" "#E0FF00" "#9CFF00" "#EBFF00" ...
  # ..- attr(*, "dimnames")=List of 2
  # $ colorMapAbsoluteData                   :List of 6
  # $ colorMapLogFoldChange                  :List of 6
  # $ dataColumnsNameFunctionFromGroupName   :function (group, sampleNamesToExclude)  
  #   ..- attr(*, "srcref")= 'srcref' int [1:8] 666 43 668 3 43 3 3786 3788
  # .. ..- attr(*, "srcfile")=Classes 'srcfilealias', 'srcfile' <environment: 0x555c0c5c55d0> 
  #   $ dataColumnsNameFunctionFromGroupIndex  :function (groupIdx, sampleNamesToExclude)  
  #     ..- attr(*, "srcref")= 'srcref' int [1:8] 662 44 664 3 44 3 3782 3784
  # .. ..- attr(*, "srcfile")=Classes 'srcfilealias', 'srcfile' <environment: 0x555c0c5c55d0> 
  #   $ dataColumnsNameFunctionFromGroupNames  :function (grouXXXps, sampleNamesToExclude)  
  #     ..- attr(*, "srcref")= 'srcref' int [1:8] 670 44 674 3 44 3 3790 3794
  # .. ..- attr(*, "srcfile")=Classes 'srcfilealias', 'srcfile' <environment: 0x555c0c5c55d0> 
  #   $ groupNameFunctionFromDataColumnName    :function (dataColumnName, sampleNamesToExclude)  
  #     ..- attr(*, "srcref")= 'srcref' int [1:8] 676 42 682 3 42 3 3796 3802
  # .. ..- attr(*, "srcfile")=Classes 'srcfilealias', 'srcfile' <environment: 0x555c0c5c55d0> 
  #   $ lfcColumnNameFunctionFromString        :function (columnName)  
  #     ..- attr(*, "srcref")= 'srcref' int [1:8] 464 38 469 3 38 3 3584 3589
  # .. ..- attr(*, "srcfile")=Classes 'srcfilealias', 'srcfile' <environment: 0x555c0c5c55d0> 
  #   $ dataMeanColumnNameFunctionFromString   :function (columnName)  
  #     ..- attr(*, "srcref")= 'srcref' int [1:8] 470 43 473 3 43 3 3590 3593
  # .. ..- attr(*, "srcfile")=Classes 'srcfilealias', 'srcfile' <environment: 0x555c0c5c55d0> 
  #   $ dataColumnIndecesFunctionFromGroupIndex:function (groupIdx, sampleNamesToExclude)  
  #     ..- attr(*, "srcref")= 'srcref' int [1:8] 658 46 660 3 46 3 3778 3780
  # .. ..- attr(*, "srcfile")=Classes 'srcfilealias', 'srcfile' <environment: 0x555c0c5c55d0> 
  #   $ dataMeanColumnNameFunctionFromName     :function (group)  
  #     ..- attr(*, "srcref")= 'srcref' int [1:8] 800 42 802 3 42 3 3920 3922
  # .. ..- attr(*, "srcfile")=Classes 'srcfilealias', 'srcfile' <environment: 0x555c0c5c55d0> 
  #   $ dataMeanColumnNameFunctionFromIndex    :function (groupIdx)  
  #     ..- attr(*, "srcref")= 'srcref' int [1:8] 804 43 806 3 43 3 3924 3926
  # .. ..- attr(*, "srcfile")=Classes 'srcfilealias', 'srcfile' <environment: 0x555c0c5c55d0> 
  #   $ lfcColumnNameFunctionFromName          :function (groupOne, groupTwo)  
  #     ..- attr(*, "srcref")= 'srcref' int [1:8] 808 36 810 3 36 3 3928 3930
  # .. ..- attr(*, "srcfile")=Classes 'srcfilealias', 'srcfile' <environment: 0x555c0c5c55d0> 
  #   $ lfcColumnNameFunctionFromIndex         :function (groupIdxOne, groupIdxTwo)  
  #     ..- attr(*, "srcref")= 'srcref' int [1:8] 812 37 814 3 37 3 3932 3934
  # .. ..- attr(*, "srcfile")=Classes 'srcfilealias', 'srcfile' <environment: 0x555c0c5c55d0> 
  #   $ groupNameFromGroupIndex                :function (groupIdx)  
  #     ..- attr(*, "srcref")= 'srcref' int [1:8] 816 30 818 3 30 3 3936 3938
  # .. ..- attr(*, "srcfile")=Classes 'srcfilealias', 'srcfile' <environment: 0x555c0c5c55d0> 
  #   $ groupIdxFromGroupName                  :function (group)  
  #     ..- attr(*, "srcref")= 'srcref' int [1:8] 820 28 822 3 28 3 3940 3942
  # .. ..- attr(*, "srcfile")=Classes 'srcfilealias', 'srcfile' <environment: 0x555c0c5c55d0> 
  #   $ featureMatrix                          :Formal class 'dgCMatrix' [package "Matrix"] with 6 slots
  # $ featureIndeces                         :List of 2585
  # $ featureCount                           : num [1:2585] 1 1 1 1 1 1 1 1 1 1 ...
  # $ featureIndexMatrix                     : int [1:2585, 1:90] 15 15 15 15 15 15 15 15 15 15 ...
  # ..- attr(*, "dimnames")=List of 2
  # $ ms2_numberOfFragments                  : int [1:14547] 19 149 3 4 15 77 1 6 11 1 ...
  # $ ms2_averageAbundance                   : num [1:14547] 0.1162 0.0899 0.131 0.1033 0.1987 ...
  # $ ms2_masses                             : num [1:14547] 69 71 71 71 73 ...
  # $ colorMapFragmentData                   :List of 6
  # $ annotationColumnName                   : chr "Annotation"
  # $ annotationColorsName                   : chr "AnnotationColors"
  # $ annotationColumnIndex                  : int 3
  # $ annotationValueIgnore                  : chr "Ignore"
  # $ annotationColorIgnore                  : chr "red"
  # $ annoArrayOfLists                       :List of 2585
  # $ annoArrayIsArtifact                    : logi [1:2585] FALSE FALSE FALSE FALSE FALSE FALSE ...
  # $ annoPresentAnnotationsList             :List of 3
  # $ annoPresentColorsList                  :List of 3
  # $ orderColumnNames                       :function (groupSampleDataFrame, columnNames)  
  #   ..- attr(*, "srcref")= 'srcref' int [1:8] 685 23 691 3 23 3 3805 3811
  # .. ..- attr(*, "srcfile")=Classes 'srcfilealias', 'srcfile' <environment: 0x555c0c5c55d0> 
  #   $ excludedSamples                        :function (groupSampleDataFrame, grouXXXps = dataList$grouXXXps)  
  #     ..- attr(*, "srcref")= 'srcref' int [1:8] 695 22 700 3 22 3 3815 3820
  # .. ..- attr(*, "srcfile")=Classes 'srcfilealias', 'srcfile' <environment: 0x555c0c5c55d0> 
  #   $ includedSamples                        :function (groupSampleDataFrame, grouXXXps = dataList$grouXXXps)  
  #     ..- attr(*, "srcref")= 'srcref' int [1:8] 702 22 707 3 22 3 3822 3827
  # .. ..- attr(*, "srcfile")=Classes 'srcfilealias', 'srcfile' <environment: 0x555c0c5c55d0> 
  #   $ includedGroups                         :function (groupSampleDataFrame, samples = dataList$groupSampleDataFrame[, "Sample"])  
  #     ..- attr(*, "srcref")= 'srcref' int [1:8] 710 21 714 3 21 3 3830 3834
  # .. ..- attr(*, "srcfile")=Classes 'srcfilealias', 'srcfile' <environment: 0x555c0c5c55d0> 
  #   $ excludedGroups                         :function (groupSampleDataFrame, samples = dataList$groupSampleDataFrame[, "Sample"])  
  #     ..- attr(*, "srcref")= 'srcref' int [1:8] 716 21 718 3 21 3 3836 3838
  # .. ..- attr(*, "srcfile")=Classes 'srcfilealias', 'srcfile' <environment: 0x555c0c5c55d0> 
  #   
  #   
  #   
})

================
File: tests/testthat/test-readMetaboScape.R
================
filePath <- system.file("extdata/testdata/MetaboScape_rye_data.xlsx", package = "MetFamily")
qf <- readMetaboscape(filePath)

test_that("Sum of Intensities is correct", {
  sumQf <- sum(colSums(assay(qf)))
  expect_equal(sumQf,307716661)
})

test_that("Number of Rows and Columns are correct", {
  
  # check if number of rows is identical
  nrowQf <- nrow(assay(qf))
  expect_equal(nrowQf, 805L)
  
  # check if number of cols is identical
  ncolQf <- ncol(assay(qf))+ ncols(rowData(qf))
  expect_equal(as.integer(ncolQf), 73)
  #TODO: Alignment id 0 vs 1 
})

================
File: tests/testthat/test-readMSDial.R
================
filePeakMatrix <- system.file("extdata/showcase/Metabolite_profile_showcase.txt", package = "MetFamily")
qf <- readMSDial(filePeakMatrix)

test_that("exampledata", {
  data <- parsePeakAbundanceMatrixQF(qf, doPrecursorDeisotoping=TRUE,
                                   mzDeviationInPPM_precursorDeisotoping=10, mzDeviationAbsolute_precursorDeisotoping=0.01,
                                   maximumRtDifference=0.05,
                                   progress=FALSE)
  
  
  ## Test dimensions  
  expect_equal(nrow(data$dataFrame), 5403)
  expect_equal(ncol(data$dataFrame),   20)
  
  ## Test some values
  expect_true(all(summary(t(data$dataFrame[1,c("TRI03", "TRI02", "TRI01", "LVS03", "LVS02", "LVS01")])) == c("Min.   : 236.0  ", "1st Qu.: 306.2  ", "Median : 357.5  ", "Mean   : 501.0  ", "3rd Qu.: 554.2  ", "Max.   :1146.0  ")))
  expect_true(all(round(summary(data$dataFrame[, "TRI01"])) == c(0,     809,    1537,    9818,    3207, 4407926)))
})


test_that("Sum of Intensities is correct", {
  
  sumQf <- sum(colSums(assay(qf)))
  expect_equal(sumQf, 232301678)

})

test_that("Number of Rows and Columns are correct", {
  
  # check if number of rows is identical
  nrowQf <- nrow(assay(qf))
  expect_equal(nrowQf, 5823L)
  
  # check if number of cols is identical
  ncolQf <- ncol(assay(qf))+ ncols(rowData(qf))
  expect_equal(as.integer(ncolQf), 20)
  
})

================
File: tests/testthat.R
================
library("testthat")

## somehow source all required files 

test_check("MetFamily")

================
File: vignettes/biomed-central.csl
================
<?xml version="1.0" encoding="utf-8"?>
<style xmlns="http://purl.org/net/xbiblio/csl" class="in-text" version="1.0" demote-non-dropping-particle="sort-only" default-locale="en-US">
  <info>
    <title>BioMed Central</title>
    <id>http://www.zotero.org/styles/biomed-central</id>
    <link href="http://www.zotero.org/styles/biomed-central" rel="self"/>
    <link href="http://www.biomedcentral.com/bmcbioinformatics/authors/instructions/researcharticle#formatting-references" rel="documentation"/>
    <!-- This documentation link contains incorrect information about the number of authors for supplemental info; it was confirmed directly by BMC that the correct max number of authors to list is 30, see also https://github.com/citation-style-language/styles/issues/190
         <link href="http://www.biomedcentral.com/authors/instprepdoc#refs" rel="documentation"/>
    -->
    <author>
      <name>Robert M Flight</name>
      <email>rflight79@gmail.com</email>
    </author>
    <category citation-format="numeric"/>
    <category field="medicine"/>
    <category field="biology"/>
    <updated>2013-01-12T23:55:23+00:00</updated>
    <rights license="http://creativecommons.org/licenses/by-sa/3.0/">This work is licensed under a Creative Commons Attribution-ShareAlike 3.0 License</rights>
  </info>
  <locale xml:lang="en">
    <terms>
      <term name="collection-editor" form="long">
        <single>Series editor</single>
        <multiple>Series editors</multiple>
      </term>
    </terms>
  </locale>
  <macro name="author">
    <names variable="author" suffix=": ">
      <name sort-separator=" " initialize-with="" name-as-sort-order="all" delimiter=", " delimiter-precedes-last="always"/>
      <label form="short" prefix=" (" suffix=")" text-case="capitalize-first" strip-periods="true"/>
      <substitute>
        <names variable="editor"/>
      </substitute>
    </names>
  </macro>
  <macro name="editor">
    <names variable="editor" suffix=".">
      <label form="verb" suffix=" " text-case="capitalize-first"/>
      <name sort-separator=" " initialize-with="" name-as-sort-order="all" delimiter=", " delimiter-precedes-last="always"/>
    </names>
  </macro>
  <macro name="publisher">
    <group delimiter=": ">
      <choose>
        <if type="thesis" match="none">
          <text variable="publisher-place"/>
        </if>
      </choose>
      <text variable="publisher"/>
    </group>
  </macro>
  <macro name="container-title">
    <choose>
      <if type="article-journal" match="any">
        <text variable="container-title" font-style="italic" form="short" strip-periods="true"/>
      </if>
      <else>
        <text variable="container-title" font-style="italic"/>
      </else>
    </choose>
  </macro>
  <macro name="title">
    <choose>
      <if type="bill book graphic legal_case legislation motion_picture report song" match="any">
        <text variable="title" font-style="italic" text-case="title"/>
      </if>
      <else>
        <text variable="title" font-weight="bold"/>
      </else>
    </choose>
  </macro>
  <macro name="volume">
    <choose>
      <if type="article-journal article-magazine" match="any">
        <text variable="volume" font-weight="bold"/>
      </if>
    </choose>
  </macro>
  <macro name="volume-book">
    <choose>
      <if type="article-journal article-magazine" match="none">
        <group delimiter=" " font-style="italic">
          <text term="volume" text-case="capitalize-first"/>
          <text variable="volume"/>
        </group>
      </if>
    </choose>
  </macro>
  <macro name="edition">
    <choose>
      <if is-numeric="edition">
        <group delimiter=" ">
          <number variable="edition" form="ordinal"/>
          <text term="edition" form="long" suffix="."/>
        </group>
      </if>
      <else>
        <text variable="edition" suffix="."/>
      </else>
    </choose>
  </macro>
  <citation collapse="citation-number">
    <sort>
      <key variable="citation-number"/>
    </sort>
    <layout prefix="[" suffix="]" delimiter=", ">
      <text variable="citation-number"/>
    </layout>
  </citation>
  <bibliography et-al-min="31" et-al-use-first="30">
    <layout>
      <text variable="citation-number" suffix=". "/>
      <choose>
        <if type="webpage">
          <!-- The webpages will be the bane of my existence -->
          <text macro="title"/>
          <text variable="URL" prefix=" [" suffix="]"/>
        </if>
        <else>
          <!-- Now for everything else -->
          <group suffix=".">
            <text macro="author"/>
            <text macro="title" suffix=". "/>
            <choose>
              <if type="bill book graphic legal_case legislation motion_picture report song thesis" match="any">
                <group delimiter=". " prefix=" " suffix="; ">
                  <text macro="edition"/>
                  <text macro="volume-book"/>
                  <text variable="genre" font-style="italic"/>
                  <text macro="publisher"/>
                </group>
              </if>
              <else-if type="chapter paper-conference" match="any">
                <group delimiter=". " suffix="; ">
                  <group delimiter=" ">
                    <text term="in" text-case="capitalize-first"/>
                    <text macro="container-title"/>
                  </group>
                  <text macro="volume-book"/>
                  <text macro="edition"/>
                  <text macro="editor"/>
                  <text macro="publisher"/>
                </group>
              </else-if>
              <else>
                <text macro="container-title" suffix=" "/>
              </else>
            </choose>
            <date variable="issued">
              <date-part name="year"/>
            </date>
            <text macro="volume" prefix=", "/>
            <!-- This will hopefully deal with supplements at least reasonably well -->
            <choose>
              <if is-numeric="issue">
              </if>
              <else>
                <text variable="issue" prefix="(" suffix=")"/>
              </else>
            </choose>
            <text variable="page" prefix=":"/>
          </group>
          <group prefix=" [" suffix="]" delimiter=": ">
            <names variable="collection-editor">
              <name sort-separator=" " initialize-with="" name-as-sort-order="all" delimiter=", " delimiter-precedes-last="always"/>
              <label prefix=" (" suffix=")" form="long"/>
            </names>
            <group delimiter=", ">
              <text variable="collection-title" font-style="italic" text-case="title"/>
              <choose>
                <if is-numeric="collection-number">
                  <text variable="collection-number" prefix="vol. "/>
                </if>
                <else>
                  <text variable="collection-number"/>
                </else>
              </choose>
            </group>
          </group>
        </else>
      </choose>
    </layout>
  </bibliography>
</style>

================
File: vignettes/discoveringregulatedmetabolitefamilies.Rmd
================
---
title: "Discovering regulated Metabolite Families"
author:
- name: Khabat Vahabi
  affiliation: Leibniz Institute of Plant Biochemistry
- name: Steffen Neumann
  affiliation: Leibniz Institute of Plant Biochemistry
  email: sneumann@ipb-halle.de
package: MetFamily
output:
  BiocStyle::html_document:
    toc_float: true
abstract: |
  Description of the MetFamily R package
vignette: |
  %\VignetteIndexEntry{Discovering regulated Metabolite Families with MetFamily}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography: references.bib
csl: biomed-central.csl
---

```{r setup, include=FALSE, echo=FALSE}
library(MetFamily)
```

# Introduction

Some text about the scenario, data and MTBLS297.

Cool paper [@Treutler16DiscoveringRegulatedMetabolite].
 
Cool R package: `r Githubpkg("ipb-halle/MetFamily")`



# Loading the data

First, we load the data and summarise it

```{r load-data}

fileName <- system.file("extdata/showcase/Project_file_showcase_annotated.csv.gz", package = "MetFamily")

#qfeatures <- readMSDial()

# f <- system.file("extdata", "minimona.msp", package = "MsBackendMsp") ## Change to MetFamily example files
# spectra <- readMsp(f)

#convertQfeaturesSpectraToProjectFile <- function(qfeatures, 
#                                 spectra, 
#                                 parameterSet, 
#                                 progress = FALSE)


project <- readClusterDataFromProjectFile(file = fileName)

```

# Filtering data

We can filter the data to remove low quality data points

```{r filter-data}

# todo...

```


# PCA

PCA on MS1 in Figure \@ref(fig:pca). 

```{r pca, fig.cap="PCA of MS1.", echo=FALSE}
fileName <- system.file("extdata/testdata/filterObj.Rdata", package = "MetFamily")
load(fileName) 

pca <- calculatePCA(dataList=project, 
                         filterObj=filterObj, 
                         ms1AnalysisMethod="PCA (Principal Component Analysis)", 
                         scaling="None", 
                    logTransform=FALSE)

## Need to be global variables because they are not 
## passed to getPcaPerformanceIndicator() as parameters. 
pcaDimensionOne <<- 1
pcaDimensionTwo <<- 2

  resultObj <- calcPlotPCAscores(
    pcaObj = pca, 
    dataList = project, 
    filterObj = filterObj,
    pcaDimensionOne = pcaDimensionOne, 
    pcaDimensionTwo = pcaDimensionTwo, 
    showScoresLabels = FALSE, 
    xInterval = NULL, 
    yInterval = NULL
)

  resultObj <- calcPlotPCAloadings(
    pcaObj = pca, 
    dataList = project, 
    filter = filterObj, 
    pcaDimensionOne = pcaDimensionOne, 
    pcaDimensionTwo = pcaDimensionTwo, 
    selectionFragmentPcaLoadingSet = NULL,
    selectionAnalysisPcaLoadingSet = NULL,
    selectionSearchPcaLoadingSet   = NULL,
    xInterval = NULL, 
    yInterval = NULL,
    loadingsLabels = "None", 
    showLoadingsAbundance = FALSE, 
    showLoadingsFeaturesAnnotated   = TRUE,
    showLoadingsFeaturesUnannotated = TRUE,
    showLoadingsFeaturesSelected    = TRUE,
    showLoadingsFeaturesUnselected  = TRUE
  )

    
    
```

# HCA

HCA on MS2 in Figure \@ref(fig:hca). 

```{r hca, fig.cap="HCA on MS2.", echo=FALSE}

if (FALSE) {
p <- calcPlotDendrogram_plotly(dataList=project, 
                               filterObj=filterObj, 
                               clusterDataList=project, 
  distanceMeasure = "Jaccard", 
  showClusterLabels=FALSE, 
  hcaPrecursorLabels="m/z / RT", 
  selectionFragmentTreeNodeSet = NULL, 
  selectionAnalysisTreeNodeSet = NULL, 
  selectionSearchTreeNodeSet = NULL, 
  selectedSelection, 
  heatmapContent, 
  heatmapOrdering, 
  heatmapProportion)
}

fileName <- system.file("extdata/testdata/clusterDataList.Rdata", package = "MetFamily")
load(fileName) 
fileName <- system.file("extdata/testdata/hcaFilter.Rdata", package = "MetFamily")
load(fileName) 

returnObj <- calcPlotDendrogram(dataList=project, 
                                filter=filter, 
                                clusterDataList=clusterDataList, 
                                annoPresentAnnotationsList = annoPresentAnnotationsList ,
                                annoPresentColorsList = annoPresentColorsList,
                                distanceMeasure="Jaccard (intensity-weighted)", 
                                selectionFragmentTreeNodeSet = NULL, 
                                selectionAnalysisTreeNodeSet = NULL, 
                                selectionSearchTreeNodeSet = NULL, 
                                showClusterLabels = TRUE, 
                                hcaPrecursorLabels = "m/z / RT", 
                                xInterval = c(1,219))

  
```

# References {.unnumbered}

<div id="refs"></div>

# Appendix {.unnumbered}

## Session info

```{r sessionInfo, echo=FALSE}
sessionInfo()
```

================
File: vignettes/references.bib
================
@Article{Treutler16DiscoveringRegulatedMetabolite,
  Title                    = {{D}iscovering {R}egulated {M}etabolite {F}amilies in {U}ntargeted {M}etabolomics {S}tudies.},
  Author                   = {Treutler, Hendrik and Tsugawa, Hiroshi and Porzel, Andrea and Gorzolka, Karin and Tissier, Alain and Neumann, Steffen and Balcke, Gerd Ulrich},
  Journal                  = {Anal Chem},
  Year                     = {2016},

  Month                    = {Aug},

  Abstract                 = {The identification of metabolites by mass spectrometry constitutes a major bottleneck which considerably limits the throughput of metabolomics studies in biomedical or plant research. Here, we present a novel approach to analyze metabolomics data from untargeted, data-independent LC-MS/MS measurements. By integrated analysis of MS(1) abundances and MS/MS spectra, the identification of regulated metabolite families is achieved. This approach offers a global view on metabolic regulation in comparative metabolomics. We implemented our approach in the web application "MetFamily", which is freely available at http://msbi.ipb-halle.de/MetFamily/ . MetFamily provides a dynamic link between the patterns based on MS(1)-signal intensity and the corresponding structural similarity at the MS/MS level. Structurally related metabolites are annotated as metabolite families based on a hierarchical cluster analysis of measured MS/MS spectra. Joint examination with principal component analysis of MS(1) patterns, where this annotation is preserved in the loadings, facilitates the interpretation of comparative metabolomics data at the level of metabolite families. As a proof of concept, we identified two trichome-specific metabolite families from wild-type tomato Solanum habrochaites LA1777 in a fully unsupervised manner and validated our findings based on earlier publications and with NMR.},
  Doi                      = {10.1021/acs.analchem.6b01569},
  Institution              = {Leibniz Institute of Plant Biochemistry , Department of Cell and Metabolic Biology, Weinberg 3, D-06120 Halle/Saale, Germany.},
  Language                 = {eng},
  Medline-pst              = {aheadofprint},
  Owner                    = {sneumann},
  Pmid                     = {27452369},
  Timestamp                = {2016.08.12},
  Url                      = {http://dx.doi.org/10.1021/acs.analchem.6b01569}
}

================
File: .gitignore
================
.Rproj.user
.Rhistory
.RData
.Ruserdata
*~

================
File: .Rbuildignore
================
^.*\.Rproj$
^\.Rproj\.user$

================
File: DESCRIPTION
================
Package: MetFamily
Type: Package
Title: MetFamily: Discovering Regulated Metabolite Families in Untargeted Metabolomics Studies
Version: 0.99.4
Date: 2024-08-22
Author: c( person("Hendrik", "Treutler, role = c("aut"), email = "hendrik.treutler@ipb-halle.de"),
           person("Khabat", "Vahabi", role = c("aut"), email = "khabat.vahabi@ipb-halle.de"),
           person("Norman", "Storz", role = c("aut"), email = "nstorz@ipb-halle.de"),
           person(given = "Steffen", family = "Neumann", email = "sneumann@ipb-halle.de",
           role = c("aut", "cre"), comment = c(ORCID = "0000-0002-7899-7192")) )
Depends:
    R (>= 3.5.0),
    htmltools,
    shiny,
    shinyBS,
    shinyjs,
    shinybusy,
    DT,
    colourpicker,
    Matrix,
    squash,
    FactoMineR,
    mixOmics,
    pcaMethods,
    cba,
    cowplot,
    gdata,
    searchable, 
    tools,
    stringr,
    mzR,
    matrixStats,
    plotrix,
    slam,
    plotly
Imports:
    egg,
    graphics,
    grDevices,
    methods,
    QFeatures,
    stats,
    utils,
    S4Vectors, 
    SummarizedExperiment,
    openxlsx2
Remotes: 
    decisionpatterns/searchable
Suggests:
    knitr,
    BiocStyle,
    testthat,
    shinytest2
VignetteBuilder: knitr
Maintainer: Steffen Neumann <sneumann@ipb-halle.de>
Description: Untargeted discovery 
  of metabolite families offering a bird's eye view of metabolic regulation 
  in comparative metabolomics. We implemented the presented methodology 
  in the easy-to-use web application MetFamily to enable the analysis 
  of comprehensive metabolomics studies for all researchers worldwide.
License: GPL (>= 2) + file LICENSE
biocViews: Software, Visualization
Collate:
    'Annotation.R'
    'Classifiers.R'
    'runMetFamily.R'
    'FragmentMatrixFunctions.R'
    'DataProcessing.R'
    'Analysis.R'
    'TreeAlgorithms.R'
    'Plots.R'
    'R_packages.R'
    parsePeakAbundanceMatrixQF.R
    readMSDial.R
    readMetaboScape.R
RoxygenNote: 7.2.3
Encoding: UTF-8

================
File: Dockerfile
================
#FROM sneumann/metfamily-base:latest
FROM sneumann/metfamily-base:4.4
#FROM sneumann/metfamily-base:4.3.2
#FROM sneumann/metfamily-base:4.0.5
#FROM sneumann/metfamily-base:3.6.3

LABEL maintainer="Steffen Neumann <sneumann@ipb-halle.de>"
LABEL Description="MetFamily helps identifying metabolites and groups them into metabolite clusters (a.k.a. families)."

ADD . /tmp/MetFamily

RUN R CMD INSTALL /tmp/MetFamily

WORKDIR /srv/shiny-server
RUN rm -rf *
ADD inst/MetFamily /srv/shiny-server/

================
File: Dockerfile-base
================
# syntax=docker/dockerfile:1.3-labs
FROM rocker/shiny:4.4

LABEL maintainer="Steffen Neumann <sneumann@ipb-halle.de>"
LABEL Description="MetFamily Base Image with dependencies."

## Older base images might need libigraph0-dev instead of libigraph-dev 
RUN apt-get -y --allow-releaseinfo-change update && apt-get -y install \
  netcdf-bin libnetcdf-dev libdigest-sha-perl libigraph-dev \
  xorg-dev libglu1-mesa-dev freeglut3-dev libgomp1 libxml2-dev gcc g++ libcurl4-gnutls-dev libssl-dev gdebi-core libharfbuzz-dev libfribidi-dev libtiff5-dev

ENV NETCDF_INCLUDE=/usr/include
RUN echo 'sanitize_errors off;disable_protocols xdr-streaming xhr-streaming iframe-eventsource iframe-htmlfile;' >> /etc/shiny-server/shiny-server.conf

## The following Rprofile allows to use CRAN snapshots
## (The HERE document COPY <<EOF requires syntax=docker/dockerfile:1.3-labs)
## We have tested the following combinations of FROM and CRAN:
## rocker/shiny:4.3.2
## rocker/shiny:3.6.3	https://packagemanager.posit.co/cran/2020-04-23/
## rocker/shiny:4.0.5	https://packagemanager.posit.co/cran/2021-03-01/
## rocker/shiny:4.3.2	https://packagemanager.posit.co/cran/2023-12-01/

## COPY <<EOF /root/.Rprofile
## local({
##   r <- getOption(\"repos\")
##   r[\"CRAN\"] <- \"https://packagemanager.posit.co/cran/2021-03-01/\"
##   options(repos=r)
## })
## EOF

ADD DESCRIPTION /tmp/MetFamily/DESCRIPTION
RUN R -e 'options(warn=2) ; install.packages("devtools")'
RUN R -e 'library(devtools); options(warn=2) ; install_deps("/tmp/MetFamily")'

WORKDIR /srv/shiny-server

================
File: Dockerfile-rstudio
================
FROM sneumann/metfamily-base:latest

MAINTAINER Steffen Neumann <sneumann@ipb-halle.de>

LABEL Description="Add rstudio server on top of MetFamily, esp. for debugging"

WORKDIR /tmp

RUN wget https://download2.rstudio.org/server/bionic/amd64/rstudio-server-1.4.1103-amd64.deb
RUN apt -y install psmisc libapparmor1 libclang-dev libpq5 git
RUN dpkg -i rstudio-server-1.4.1103-amd64.deb

RUN apt -y install supervisor
COPY supervisord-rstudio.conf /etc/supervisor/conf.d/supervisord.conf

RUN useradd -p $(openssl passwd -crypt rstudio) rstudio ; mkdir /home/rstudio ; chown rstudio /home/rstudio

WORKDIR /home/rstudio
#RUN git clone https://github.com/ipb-halle/MetFamily.git

CMD ["/usr/bin/supervisord", "-c", "/etc/supervisor/conf.d/supervisord.conf"]

================
File: LICENSE
================
GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    {one line to give the program's name and a brief idea of what it does.}
    Copyright (C) {year}  {name of author}

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    {project}  Copyright (C) {year}  {fullname}
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<http://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<http://www.gnu.org/philosophy/why-not-lgpl.html>.

================
File: MetFamily.Rproj
================
Version: 1.0

RestoreWorkspace: Default
SaveWorkspace: Default
AlwaysSaveHistory: Default

EnableCodeIndexing: Yes
UseSpacesForTab: Yes
NumSpacesForTab: 2
Encoding: UTF-8

RnwWeave: Sweave
LaTeX: pdfLaTeX

BuildType: Package
PackageUseDevtools: Yes
PackageInstallArgs: --no-multiarch --with-keep.source

================
File: NAMESPACE
================
# Generated by roxygen2: do not edit by hand

export(calcPlotDendrogram_plotly)
export(calcPlotHeatmapLegend)
export(castListEntries)
export(data.numericmatrix)
export(metaboliteFamilyVersusClass)
export(mzClustGeneric)
export(parsePeakAbundanceMatrixQF)
export(processMS1data)
export(readClusterDataFromProjectFile)
export(readMSDial)
export(readMetaboscape)
export(readProjectData)
export(runMetFamily)
importFrom(QFeatures,QFeatures)
importFrom(S4Vectors,DataFrame)
importFrom(SummarizedExperiment,SummarizedExperiment)
importFrom(grDevices,colorRampPalette)
importFrom(grDevices,rainbow)
importFrom(grDevices,rgb)
importFrom(openxlsx2,read_xlsx)


## Hardcoded:
exportPattern("^[^\\.]")
import(egg)
importFrom("grDevices", "as.raster", "rainbow", "rgb")
importFrom("methods", "as")
importFrom("graphics", "axis", "mtext", "par", "plot.new",
           "plot.window", "points", "rasterImage", "rect", "segments",
           "title")
importFrom("methods", "as", "is")
importFrom("stats", "as.dendrogram", "cor", "dendrapply", "dist",
           "hclust", "is.leaf", "median", "na.omit", "predict", "sd")
importFrom("utils", "flush.console", "read.table")


importFrom(SummarizedExperiment,colData)
importFrom(SummarizedExperiment,rowData)
importFrom(SummarizedExperiment,assay)

================
File: NEWS
================
CHANGES IN VERSION 0.99.4
-------------------------
NEW FEATURES

    o Reading and parsing of intensity matrix now via QFeatures package
    o First parallelisation (and speedup) in distance matrix calculation
    o Adding of new contributor, change of maintainer


CHANGES IN VERSION 0.99.2
-------------------------

BUG FIXES

    o Now producing correct PCA on R-4.0.0+ by using a custom data.matrix() function with old R-3.6.3 behaviour

CHANGES IN VERSION 0.99.2
-------------------------

NEW FEATURES

    o More and better colors available for plotting (thanks @khabatv)
    o improving package and app source organisation
    o runMetFamily() function to launch the Shiny app
    o Started testing infrastructure

================
File: README.md
================
[![build](https://github.com/ipb-halle/MetFamily/actions/workflows/build.yml/badge.svg)](https://github.com/ipb-halle/MetFamily/actions/workflows/build.yml)

# MetFamily
Understanding metabolism is fundamental in biomedical and plant research and the identification and quantification of thousands of metabolites by mass spectrometry in modern metabolomics is a prerequisite for elucidating this area. However, the identification of metabolites is a major bottleneck in traditional approaches hampering advances. Here, we present a novel approach for the untargeted discovery of metabolite families offering a bird's eye view of metabolic regulation in comparative metabolomics. We implemented the presented methodology in the easy-to-use web application MetFamily to enable the analysis of comprehensive metabolomics studies for all researchers worldwide.  MetFamily is available under http://msbi.ipb-halle.de/MetFamily/.

# Docker images
The image `sneumann/metfamily-base` contains all dependencies
for the MetFamily web application.

## Building the container(s)
Build via `docker build -t sneumann/metfamily-base -f Dockerfile-base . `

The image `sneumann/metfamily` is built on top and contains
the actual MetFamily code and web application.

Build via `docker build -t sneumann/metfamily . `

The build of the metfamily-base image https://hub.docker.com/r/sneumann/metfamily-base is triggerd whenever in the `master` branch a tag `basechange-<date>` e.g. `basechange-20190804` is specified.

## Running from a container

To run the resulting container, start with
`docker run --rm -p 3838:3838 sneumann/metfamily:latest`

and point your browser to http://localhost:3838/

## Developing and debugging in a container

If you want to develop and debug stuff, you can build a container
on top of `metfamily:latest` that has an added rstudio server.
First build using `docker build -t metfamily-rstudio -f Dockerfile-rstudio .`
and then run via `docker run -it --rm -p 8787:8787 metfamily-rstudio:latest`.
CAVEAT: the `Dockerfile-rstudio` specifies a fixed user/password combo
of `rstudio:rstudio`. Do not use in Production !

You can also pass a local directory with checked out MetFamily git tree
via the `docker run -v` argument.

## Running locally with MetFamily R Package

After installing the `MetFamily` R package and its dependencies, you can
```
library(MetFamily)
runApp(system.file("MetFamily", package="MetFamily"))
```

## Running through Kubernetes

At IPB we are running MetFamily inside a Kubernetes cluster.
Please contact us for questions.

================
File: supervisord-rstudio.conf
================
[supervisord]
nodaemon=true
logfile=/var/log/supervisor/supervisord.log
pidfile = /tmp/supervisord.pid

user = root

#[program:userconf]
##command=/usr/bin/userconf.sh
#command=/rocker_scripts/userconf.sh
#stdout_logfile=/var/log/supervisor/%(program_name)s.log
#stderr_logfile=/var/log/supervisor/%(program_name)s.log
#startsecs=0
#autorestart=false
#exitcodes=0

[program:rserver]
command=/usr/lib/rstudio-server/bin/rserver
stdout_logfile=/var/log/supervisor/%(program_name)s.log
stderr_logfile=/var/log/supervisor/%(program_name)s.log
user=root
startsecs=0
autorestart=false

================
File: supervisord.conf
================
[supervisord]
nodaemon=true
logfile=/var/log/supervisor/supervisord.log
pidfile = /tmp/supervisord.pid

[program:shinyserver]
user=root
startsecs=0
process_name=%(program_name)s_%(process_num)02d
numprocs=1
command=/bin/bash -c "exec /usr/bin/shiny-server --pidfile=/var/run/shiny-server.pid >> /var/log/shiny-server.log 2>&1"
stdout_logfile=/var/log/supervisor/%(program_name)s.log
stderr_logfile=/var/log/supervisor/%(program_name)s.log
autostart=true
autorestart=false
redirect_stderr=true
